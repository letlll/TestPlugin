/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/json5/dist/index.js
var require_dist = __commonJS({
  "node_modules/json5/dist/index.js"(exports, module2) {
    (function(global, factory) {
      typeof exports === "object" && typeof module2 !== "undefined" ? module2.exports = factory() : typeof define === "function" && define.amd ? define(factory) : global.JSON5 = factory();
    })(exports, function() {
      "use strict";
      function createCommonjsModule(fn, module3) {
        return module3 = { exports: {} }, fn(module3, module3.exports), module3.exports;
      }
      var _global = createCommonjsModule(function(module3) {
        var global = module3.exports = typeof window != "undefined" && window.Math == Math ? window : typeof self != "undefined" && self.Math == Math ? self : Function("return this")();
        if (typeof __g == "number") {
          __g = global;
        }
      });
      var _core = createCommonjsModule(function(module3) {
        var core = module3.exports = { version: "2.6.5" };
        if (typeof __e == "number") {
          __e = core;
        }
      });
      var _core_1 = _core.version;
      var _isObject = function(it) {
        return typeof it === "object" ? it !== null : typeof it === "function";
      };
      var _anObject = function(it) {
        if (!_isObject(it)) {
          throw TypeError(it + " is not an object!");
        }
        return it;
      };
      var _fails = function(exec) {
        try {
          return !!exec();
        } catch (e) {
          return true;
        }
      };
      var _descriptors = !_fails(function() {
        return Object.defineProperty({}, "a", { get: function() {
          return 7;
        } }).a != 7;
      });
      var document2 = _global.document;
      var is = _isObject(document2) && _isObject(document2.createElement);
      var _domCreate = function(it) {
        return is ? document2.createElement(it) : {};
      };
      var _ie8DomDefine = !_descriptors && !_fails(function() {
        return Object.defineProperty(_domCreate("div"), "a", { get: function() {
          return 7;
        } }).a != 7;
      });
      var _toPrimitive = function(it, S) {
        if (!_isObject(it)) {
          return it;
        }
        var fn, val;
        if (S && typeof (fn = it.toString) == "function" && !_isObject(val = fn.call(it))) {
          return val;
        }
        if (typeof (fn = it.valueOf) == "function" && !_isObject(val = fn.call(it))) {
          return val;
        }
        if (!S && typeof (fn = it.toString) == "function" && !_isObject(val = fn.call(it))) {
          return val;
        }
        throw TypeError("Can't convert object to primitive value");
      };
      var dP = Object.defineProperty;
      var f = _descriptors ? Object.defineProperty : function defineProperty(O, P, Attributes) {
        _anObject(O);
        P = _toPrimitive(P, true);
        _anObject(Attributes);
        if (_ie8DomDefine) {
          try {
            return dP(O, P, Attributes);
          } catch (e) {
          }
        }
        if ("get" in Attributes || "set" in Attributes) {
          throw TypeError("Accessors not supported!");
        }
        if ("value" in Attributes) {
          O[P] = Attributes.value;
        }
        return O;
      };
      var _objectDp = {
        f
      };
      var _propertyDesc = function(bitmap, value) {
        return {
          enumerable: !(bitmap & 1),
          configurable: !(bitmap & 2),
          writable: !(bitmap & 4),
          value
        };
      };
      var _hide = _descriptors ? function(object, key2, value) {
        return _objectDp.f(object, key2, _propertyDesc(1, value));
      } : function(object, key2, value) {
        object[key2] = value;
        return object;
      };
      var hasOwnProperty = {}.hasOwnProperty;
      var _has = function(it, key2) {
        return hasOwnProperty.call(it, key2);
      };
      var id = 0;
      var px = Math.random();
      var _uid = function(key2) {
        return "Symbol(".concat(key2 === void 0 ? "" : key2, ")_", (++id + px).toString(36));
      };
      var _library = false;
      var _shared = createCommonjsModule(function(module3) {
        var SHARED = "__core-js_shared__";
        var store = _global[SHARED] || (_global[SHARED] = {});
        (module3.exports = function(key2, value) {
          return store[key2] || (store[key2] = value !== void 0 ? value : {});
        })("versions", []).push({
          version: _core.version,
          mode: _library ? "pure" : "global",
          copyright: "\xA9 2019 Denis Pushkarev (zloirock.ru)"
        });
      });
      var _functionToString = _shared("native-function-to-string", Function.toString);
      var _redefine = createCommonjsModule(function(module3) {
        var SRC = _uid("src");
        var TO_STRING = "toString";
        var TPL = ("" + _functionToString).split(TO_STRING);
        _core.inspectSource = function(it) {
          return _functionToString.call(it);
        };
        (module3.exports = function(O, key2, val, safe) {
          var isFunction = typeof val == "function";
          if (isFunction) {
            _has(val, "name") || _hide(val, "name", key2);
          }
          if (O[key2] === val) {
            return;
          }
          if (isFunction) {
            _has(val, SRC) || _hide(val, SRC, O[key2] ? "" + O[key2] : TPL.join(String(key2)));
          }
          if (O === _global) {
            O[key2] = val;
          } else if (!safe) {
            delete O[key2];
            _hide(O, key2, val);
          } else if (O[key2]) {
            O[key2] = val;
          } else {
            _hide(O, key2, val);
          }
        })(Function.prototype, TO_STRING, function toString() {
          return typeof this == "function" && this[SRC] || _functionToString.call(this);
        });
      });
      var _aFunction = function(it) {
        if (typeof it != "function") {
          throw TypeError(it + " is not a function!");
        }
        return it;
      };
      var _ctx = function(fn, that, length) {
        _aFunction(fn);
        if (that === void 0) {
          return fn;
        }
        switch (length) {
          case 1:
            return function(a) {
              return fn.call(that, a);
            };
          case 2:
            return function(a, b) {
              return fn.call(that, a, b);
            };
          case 3:
            return function(a, b, c2) {
              return fn.call(that, a, b, c2);
            };
        }
        return function() {
          return fn.apply(that, arguments);
        };
      };
      var PROTOTYPE = "prototype";
      var $export = function(type, name, source2) {
        var IS_FORCED = type & $export.F;
        var IS_GLOBAL = type & $export.G;
        var IS_STATIC = type & $export.S;
        var IS_PROTO = type & $export.P;
        var IS_BIND = type & $export.B;
        var target = IS_GLOBAL ? _global : IS_STATIC ? _global[name] || (_global[name] = {}) : (_global[name] || {})[PROTOTYPE];
        var exports2 = IS_GLOBAL ? _core : _core[name] || (_core[name] = {});
        var expProto = exports2[PROTOTYPE] || (exports2[PROTOTYPE] = {});
        var key2, own, out, exp;
        if (IS_GLOBAL) {
          source2 = name;
        }
        for (key2 in source2) {
          own = !IS_FORCED && target && target[key2] !== void 0;
          out = (own ? target : source2)[key2];
          exp = IS_BIND && own ? _ctx(out, _global) : IS_PROTO && typeof out == "function" ? _ctx(Function.call, out) : out;
          if (target) {
            _redefine(target, key2, out, type & $export.U);
          }
          if (exports2[key2] != out) {
            _hide(exports2, key2, exp);
          }
          if (IS_PROTO && expProto[key2] != out) {
            expProto[key2] = out;
          }
        }
      };
      _global.core = _core;
      $export.F = 1;
      $export.G = 2;
      $export.S = 4;
      $export.P = 8;
      $export.B = 16;
      $export.W = 32;
      $export.U = 64;
      $export.R = 128;
      var _export = $export;
      var ceil = Math.ceil;
      var floor = Math.floor;
      var _toInteger = function(it) {
        return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
      };
      var _defined = function(it) {
        if (it == void 0) {
          throw TypeError("Can't call method on  " + it);
        }
        return it;
      };
      var _stringAt = function(TO_STRING) {
        return function(that, pos2) {
          var s = String(_defined(that));
          var i = _toInteger(pos2);
          var l = s.length;
          var a, b;
          if (i < 0 || i >= l) {
            return TO_STRING ? "" : void 0;
          }
          a = s.charCodeAt(i);
          return a < 55296 || a > 56319 || i + 1 === l || (b = s.charCodeAt(i + 1)) < 56320 || b > 57343 ? TO_STRING ? s.charAt(i) : a : TO_STRING ? s.slice(i, i + 2) : (a - 55296 << 10) + (b - 56320) + 65536;
        };
      };
      var $at = _stringAt(false);
      _export(_export.P, "String", {
        // 21.1.3.3 String.prototype.codePointAt(pos)
        codePointAt: function codePointAt2(pos2) {
          return $at(this, pos2);
        }
      });
      var codePointAt = _core.String.codePointAt;
      var max = Math.max;
      var min = Math.min;
      var _toAbsoluteIndex = function(index, length) {
        index = _toInteger(index);
        return index < 0 ? max(index + length, 0) : min(index, length);
      };
      var fromCharCode = String.fromCharCode;
      var $fromCodePoint = String.fromCodePoint;
      _export(_export.S + _export.F * (!!$fromCodePoint && $fromCodePoint.length != 1), "String", {
        // 21.1.2.2 String.fromCodePoint(...codePoints)
        fromCodePoint: function fromCodePoint2(x) {
          var arguments$1 = arguments;
          var res = [];
          var aLen = arguments.length;
          var i = 0;
          var code;
          while (aLen > i) {
            code = +arguments$1[i++];
            if (_toAbsoluteIndex(code, 1114111) !== code) {
              throw RangeError(code + " is not a valid code point");
            }
            res.push(
              code < 65536 ? fromCharCode(code) : fromCharCode(((code -= 65536) >> 10) + 55296, code % 1024 + 56320)
            );
          }
          return res.join("");
        }
      });
      var fromCodePoint = _core.String.fromCodePoint;
      var Space_Separator = /[\u1680\u2000-\u200A\u202F\u205F\u3000]/;
      var ID_Start = /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE83\uDE86-\uDE89\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]/;
      var ID_Continue = /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u09FC\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9-\u0AFF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D00-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF9\u1D00-\u1DF9\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDE00-\uDE3E\uDE47\uDE50-\uDE83\uDE86-\uDE99\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD47\uDD50-\uDD59]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/;
      var unicode = {
        Space_Separator,
        ID_Start,
        ID_Continue
      };
      var util = {
        isSpaceSeparator: function isSpaceSeparator(c2) {
          return typeof c2 === "string" && unicode.Space_Separator.test(c2);
        },
        isIdStartChar: function isIdStartChar(c2) {
          return typeof c2 === "string" && (c2 >= "a" && c2 <= "z" || c2 >= "A" && c2 <= "Z" || c2 === "$" || c2 === "_" || unicode.ID_Start.test(c2));
        },
        isIdContinueChar: function isIdContinueChar(c2) {
          return typeof c2 === "string" && (c2 >= "a" && c2 <= "z" || c2 >= "A" && c2 <= "Z" || c2 >= "0" && c2 <= "9" || c2 === "$" || c2 === "_" || c2 === "\u200C" || c2 === "\u200D" || unicode.ID_Continue.test(c2));
        },
        isDigit: function isDigit(c2) {
          return typeof c2 === "string" && /[0-9]/.test(c2);
        },
        isHexDigit: function isHexDigit(c2) {
          return typeof c2 === "string" && /[0-9A-Fa-f]/.test(c2);
        }
      };
      var source;
      var parseState;
      var stack;
      var pos;
      var line;
      var column;
      var token;
      var key;
      var root;
      var parse2 = function parse3(text, reviver) {
        source = String(text);
        parseState = "start";
        stack = [];
        pos = 0;
        line = 1;
        column = 0;
        token = void 0;
        key = void 0;
        root = void 0;
        do {
          token = lex();
          parseStates[parseState]();
        } while (token.type !== "eof");
        if (typeof reviver === "function") {
          return internalize({ "": root }, "", reviver);
        }
        return root;
      };
      function internalize(holder, name, reviver) {
        var value = holder[name];
        if (value != null && typeof value === "object") {
          if (Array.isArray(value)) {
            for (var i = 0; i < value.length; i++) {
              var key2 = String(i);
              var replacement = internalize(value, key2, reviver);
              if (replacement === void 0) {
                delete value[key2];
              } else {
                Object.defineProperty(value, key2, {
                  value: replacement,
                  writable: true,
                  enumerable: true,
                  configurable: true
                });
              }
            }
          } else {
            for (var key$1 in value) {
              var replacement$1 = internalize(value, key$1, reviver);
              if (replacement$1 === void 0) {
                delete value[key$1];
              } else {
                Object.defineProperty(value, key$1, {
                  value: replacement$1,
                  writable: true,
                  enumerable: true,
                  configurable: true
                });
              }
            }
          }
        }
        return reviver.call(holder, name, value);
      }
      var lexState;
      var buffer;
      var doubleQuote;
      var sign;
      var c;
      function lex() {
        lexState = "default";
        buffer = "";
        doubleQuote = false;
        sign = 1;
        for (; ; ) {
          c = peek();
          var token2 = lexStates[lexState]();
          if (token2) {
            return token2;
          }
        }
      }
      function peek() {
        if (source[pos]) {
          return String.fromCodePoint(source.codePointAt(pos));
        }
      }
      function read() {
        var c2 = peek();
        if (c2 === "\n") {
          line++;
          column = 0;
        } else if (c2) {
          column += c2.length;
        } else {
          column++;
        }
        if (c2) {
          pos += c2.length;
        }
        return c2;
      }
      var lexStates = {
        default: function default$1() {
          switch (c) {
            case "	":
            case "\v":
            case "\f":
            case " ":
            case "\xA0":
            case "\uFEFF":
            case "\n":
            case "\r":
            case "\u2028":
            case "\u2029":
              read();
              return;
            case "/":
              read();
              lexState = "comment";
              return;
            case void 0:
              read();
              return newToken("eof");
          }
          if (util.isSpaceSeparator(c)) {
            read();
            return;
          }
          return lexStates[parseState]();
        },
        comment: function comment() {
          switch (c) {
            case "*":
              read();
              lexState = "multiLineComment";
              return;
            case "/":
              read();
              lexState = "singleLineComment";
              return;
          }
          throw invalidChar(read());
        },
        multiLineComment: function multiLineComment() {
          switch (c) {
            case "*":
              read();
              lexState = "multiLineCommentAsterisk";
              return;
            case void 0:
              throw invalidChar(read());
          }
          read();
        },
        multiLineCommentAsterisk: function multiLineCommentAsterisk() {
          switch (c) {
            case "*":
              read();
              return;
            case "/":
              read();
              lexState = "default";
              return;
            case void 0:
              throw invalidChar(read());
          }
          read();
          lexState = "multiLineComment";
        },
        singleLineComment: function singleLineComment() {
          switch (c) {
            case "\n":
            case "\r":
            case "\u2028":
            case "\u2029":
              read();
              lexState = "default";
              return;
            case void 0:
              read();
              return newToken("eof");
          }
          read();
        },
        value: function value() {
          switch (c) {
            case "{":
            case "[":
              return newToken("punctuator", read());
            case "n":
              read();
              literal("ull");
              return newToken("null", null);
            case "t":
              read();
              literal("rue");
              return newToken("boolean", true);
            case "f":
              read();
              literal("alse");
              return newToken("boolean", false);
            case "-":
            case "+":
              if (read() === "-") {
                sign = -1;
              }
              lexState = "sign";
              return;
            case ".":
              buffer = read();
              lexState = "decimalPointLeading";
              return;
            case "0":
              buffer = read();
              lexState = "zero";
              return;
            case "1":
            case "2":
            case "3":
            case "4":
            case "5":
            case "6":
            case "7":
            case "8":
            case "9":
              buffer = read();
              lexState = "decimalInteger";
              return;
            case "I":
              read();
              literal("nfinity");
              return newToken("numeric", Infinity);
            case "N":
              read();
              literal("aN");
              return newToken("numeric", NaN);
            case '"':
            case "'":
              doubleQuote = read() === '"';
              buffer = "";
              lexState = "string";
              return;
          }
          throw invalidChar(read());
        },
        identifierNameStartEscape: function identifierNameStartEscape() {
          if (c !== "u") {
            throw invalidChar(read());
          }
          read();
          var u = unicodeEscape();
          switch (u) {
            case "$":
            case "_":
              break;
            default:
              if (!util.isIdStartChar(u)) {
                throw invalidIdentifier();
              }
              break;
          }
          buffer += u;
          lexState = "identifierName";
        },
        identifierName: function identifierName() {
          switch (c) {
            case "$":
            case "_":
            case "\u200C":
            case "\u200D":
              buffer += read();
              return;
            case "\\":
              read();
              lexState = "identifierNameEscape";
              return;
          }
          if (util.isIdContinueChar(c)) {
            buffer += read();
            return;
          }
          return newToken("identifier", buffer);
        },
        identifierNameEscape: function identifierNameEscape() {
          if (c !== "u") {
            throw invalidChar(read());
          }
          read();
          var u = unicodeEscape();
          switch (u) {
            case "$":
            case "_":
            case "\u200C":
            case "\u200D":
              break;
            default:
              if (!util.isIdContinueChar(u)) {
                throw invalidIdentifier();
              }
              break;
          }
          buffer += u;
          lexState = "identifierName";
        },
        sign: function sign$1() {
          switch (c) {
            case ".":
              buffer = read();
              lexState = "decimalPointLeading";
              return;
            case "0":
              buffer = read();
              lexState = "zero";
              return;
            case "1":
            case "2":
            case "3":
            case "4":
            case "5":
            case "6":
            case "7":
            case "8":
            case "9":
              buffer = read();
              lexState = "decimalInteger";
              return;
            case "I":
              read();
              literal("nfinity");
              return newToken("numeric", sign * Infinity);
            case "N":
              read();
              literal("aN");
              return newToken("numeric", NaN);
          }
          throw invalidChar(read());
        },
        zero: function zero() {
          switch (c) {
            case ".":
              buffer += read();
              lexState = "decimalPoint";
              return;
            case "e":
            case "E":
              buffer += read();
              lexState = "decimalExponent";
              return;
            case "x":
            case "X":
              buffer += read();
              lexState = "hexadecimal";
              return;
          }
          return newToken("numeric", sign * 0);
        },
        decimalInteger: function decimalInteger() {
          switch (c) {
            case ".":
              buffer += read();
              lexState = "decimalPoint";
              return;
            case "e":
            case "E":
              buffer += read();
              lexState = "decimalExponent";
              return;
          }
          if (util.isDigit(c)) {
            buffer += read();
            return;
          }
          return newToken("numeric", sign * Number(buffer));
        },
        decimalPointLeading: function decimalPointLeading() {
          if (util.isDigit(c)) {
            buffer += read();
            lexState = "decimalFraction";
            return;
          }
          throw invalidChar(read());
        },
        decimalPoint: function decimalPoint() {
          switch (c) {
            case "e":
            case "E":
              buffer += read();
              lexState = "decimalExponent";
              return;
          }
          if (util.isDigit(c)) {
            buffer += read();
            lexState = "decimalFraction";
            return;
          }
          return newToken("numeric", sign * Number(buffer));
        },
        decimalFraction: function decimalFraction() {
          switch (c) {
            case "e":
            case "E":
              buffer += read();
              lexState = "decimalExponent";
              return;
          }
          if (util.isDigit(c)) {
            buffer += read();
            return;
          }
          return newToken("numeric", sign * Number(buffer));
        },
        decimalExponent: function decimalExponent() {
          switch (c) {
            case "+":
            case "-":
              buffer += read();
              lexState = "decimalExponentSign";
              return;
          }
          if (util.isDigit(c)) {
            buffer += read();
            lexState = "decimalExponentInteger";
            return;
          }
          throw invalidChar(read());
        },
        decimalExponentSign: function decimalExponentSign() {
          if (util.isDigit(c)) {
            buffer += read();
            lexState = "decimalExponentInteger";
            return;
          }
          throw invalidChar(read());
        },
        decimalExponentInteger: function decimalExponentInteger() {
          if (util.isDigit(c)) {
            buffer += read();
            return;
          }
          return newToken("numeric", sign * Number(buffer));
        },
        hexadecimal: function hexadecimal() {
          if (util.isHexDigit(c)) {
            buffer += read();
            lexState = "hexadecimalInteger";
            return;
          }
          throw invalidChar(read());
        },
        hexadecimalInteger: function hexadecimalInteger() {
          if (util.isHexDigit(c)) {
            buffer += read();
            return;
          }
          return newToken("numeric", sign * Number(buffer));
        },
        string: function string() {
          switch (c) {
            case "\\":
              read();
              buffer += escape();
              return;
            case '"':
              if (doubleQuote) {
                read();
                return newToken("string", buffer);
              }
              buffer += read();
              return;
            case "'":
              if (!doubleQuote) {
                read();
                return newToken("string", buffer);
              }
              buffer += read();
              return;
            case "\n":
            case "\r":
              throw invalidChar(read());
            case "\u2028":
            case "\u2029":
              separatorChar(c);
              break;
            case void 0:
              throw invalidChar(read());
          }
          buffer += read();
        },
        start: function start() {
          switch (c) {
            case "{":
            case "[":
              return newToken("punctuator", read());
          }
          lexState = "value";
        },
        beforePropertyName: function beforePropertyName() {
          switch (c) {
            case "$":
            case "_":
              buffer = read();
              lexState = "identifierName";
              return;
            case "\\":
              read();
              lexState = "identifierNameStartEscape";
              return;
            case "}":
              return newToken("punctuator", read());
            case '"':
            case "'":
              doubleQuote = read() === '"';
              lexState = "string";
              return;
          }
          if (util.isIdStartChar(c)) {
            buffer += read();
            lexState = "identifierName";
            return;
          }
          throw invalidChar(read());
        },
        afterPropertyName: function afterPropertyName() {
          if (c === ":") {
            return newToken("punctuator", read());
          }
          throw invalidChar(read());
        },
        beforePropertyValue: function beforePropertyValue() {
          lexState = "value";
        },
        afterPropertyValue: function afterPropertyValue() {
          switch (c) {
            case ",":
            case "}":
              return newToken("punctuator", read());
          }
          throw invalidChar(read());
        },
        beforeArrayValue: function beforeArrayValue() {
          if (c === "]") {
            return newToken("punctuator", read());
          }
          lexState = "value";
        },
        afterArrayValue: function afterArrayValue() {
          switch (c) {
            case ",":
            case "]":
              return newToken("punctuator", read());
          }
          throw invalidChar(read());
        },
        end: function end() {
          throw invalidChar(read());
        }
      };
      function newToken(type, value) {
        return {
          type,
          value,
          line,
          column
        };
      }
      function literal(s) {
        for (var i = 0, list = s; i < list.length; i += 1) {
          var c2 = list[i];
          var p = peek();
          if (p !== c2) {
            throw invalidChar(read());
          }
          read();
        }
      }
      function escape() {
        var c2 = peek();
        switch (c2) {
          case "b":
            read();
            return "\b";
          case "f":
            read();
            return "\f";
          case "n":
            read();
            return "\n";
          case "r":
            read();
            return "\r";
          case "t":
            read();
            return "	";
          case "v":
            read();
            return "\v";
          case "0":
            read();
            if (util.isDigit(peek())) {
              throw invalidChar(read());
            }
            return "\0";
          case "x":
            read();
            return hexEscape();
          case "u":
            read();
            return unicodeEscape();
          case "\n":
          case "\u2028":
          case "\u2029":
            read();
            return "";
          case "\r":
            read();
            if (peek() === "\n") {
              read();
            }
            return "";
          case "1":
          case "2":
          case "3":
          case "4":
          case "5":
          case "6":
          case "7":
          case "8":
          case "9":
            throw invalidChar(read());
          case void 0:
            throw invalidChar(read());
        }
        return read();
      }
      function hexEscape() {
        var buffer2 = "";
        var c2 = peek();
        if (!util.isHexDigit(c2)) {
          throw invalidChar(read());
        }
        buffer2 += read();
        c2 = peek();
        if (!util.isHexDigit(c2)) {
          throw invalidChar(read());
        }
        buffer2 += read();
        return String.fromCodePoint(parseInt(buffer2, 16));
      }
      function unicodeEscape() {
        var buffer2 = "";
        var count = 4;
        while (count-- > 0) {
          var c2 = peek();
          if (!util.isHexDigit(c2)) {
            throw invalidChar(read());
          }
          buffer2 += read();
        }
        return String.fromCodePoint(parseInt(buffer2, 16));
      }
      var parseStates = {
        start: function start() {
          if (token.type === "eof") {
            throw invalidEOF();
          }
          push();
        },
        beforePropertyName: function beforePropertyName() {
          switch (token.type) {
            case "identifier":
            case "string":
              key = token.value;
              parseState = "afterPropertyName";
              return;
            case "punctuator":
              pop();
              return;
            case "eof":
              throw invalidEOF();
          }
        },
        afterPropertyName: function afterPropertyName() {
          if (token.type === "eof") {
            throw invalidEOF();
          }
          parseState = "beforePropertyValue";
        },
        beforePropertyValue: function beforePropertyValue() {
          if (token.type === "eof") {
            throw invalidEOF();
          }
          push();
        },
        beforeArrayValue: function beforeArrayValue() {
          if (token.type === "eof") {
            throw invalidEOF();
          }
          if (token.type === "punctuator" && token.value === "]") {
            pop();
            return;
          }
          push();
        },
        afterPropertyValue: function afterPropertyValue() {
          if (token.type === "eof") {
            throw invalidEOF();
          }
          switch (token.value) {
            case ",":
              parseState = "beforePropertyName";
              return;
            case "}":
              pop();
          }
        },
        afterArrayValue: function afterArrayValue() {
          if (token.type === "eof") {
            throw invalidEOF();
          }
          switch (token.value) {
            case ",":
              parseState = "beforeArrayValue";
              return;
            case "]":
              pop();
          }
        },
        end: function end() {
        }
      };
      function push() {
        var value;
        switch (token.type) {
          case "punctuator":
            switch (token.value) {
              case "{":
                value = {};
                break;
              case "[":
                value = [];
                break;
            }
            break;
          case "null":
          case "boolean":
          case "numeric":
          case "string":
            value = token.value;
            break;
        }
        if (root === void 0) {
          root = value;
        } else {
          var parent = stack[stack.length - 1];
          if (Array.isArray(parent)) {
            parent.push(value);
          } else {
            Object.defineProperty(parent, key, {
              value,
              writable: true,
              enumerable: true,
              configurable: true
            });
          }
        }
        if (value !== null && typeof value === "object") {
          stack.push(value);
          if (Array.isArray(value)) {
            parseState = "beforeArrayValue";
          } else {
            parseState = "beforePropertyName";
          }
        } else {
          var current = stack[stack.length - 1];
          if (current == null) {
            parseState = "end";
          } else if (Array.isArray(current)) {
            parseState = "afterArrayValue";
          } else {
            parseState = "afterPropertyValue";
          }
        }
      }
      function pop() {
        stack.pop();
        var current = stack[stack.length - 1];
        if (current == null) {
          parseState = "end";
        } else if (Array.isArray(current)) {
          parseState = "afterArrayValue";
        } else {
          parseState = "afterPropertyValue";
        }
      }
      function invalidChar(c2) {
        if (c2 === void 0) {
          return syntaxError("JSON5: invalid end of input at " + line + ":" + column);
        }
        return syntaxError("JSON5: invalid character '" + formatChar(c2) + "' at " + line + ":" + column);
      }
      function invalidEOF() {
        return syntaxError("JSON5: invalid end of input at " + line + ":" + column);
      }
      function invalidIdentifier() {
        column -= 5;
        return syntaxError("JSON5: invalid identifier character at " + line + ":" + column);
      }
      function separatorChar(c2) {
        console.warn("JSON5: '" + formatChar(c2) + "' in strings is not valid ECMAScript; consider escaping");
      }
      function formatChar(c2) {
        var replacements = {
          "'": "\\'",
          '"': '\\"',
          "\\": "\\\\",
          "\b": "\\b",
          "\f": "\\f",
          "\n": "\\n",
          "\r": "\\r",
          "	": "\\t",
          "\v": "\\v",
          "\0": "\\0",
          "\u2028": "\\u2028",
          "\u2029": "\\u2029"
        };
        if (replacements[c2]) {
          return replacements[c2];
        }
        if (c2 < " ") {
          var hexString = c2.charCodeAt(0).toString(16);
          return "\\x" + ("00" + hexString).substring(hexString.length);
        }
        return c2;
      }
      function syntaxError(message) {
        var err = new SyntaxError(message);
        err.lineNumber = line;
        err.columnNumber = column;
        return err;
      }
      var stringify = function stringify2(value, replacer, space) {
        var stack2 = [];
        var indent = "";
        var propertyList;
        var replacerFunc;
        var gap = "";
        var quote;
        if (replacer != null && typeof replacer === "object" && !Array.isArray(replacer)) {
          space = replacer.space;
          quote = replacer.quote;
          replacer = replacer.replacer;
        }
        if (typeof replacer === "function") {
          replacerFunc = replacer;
        } else if (Array.isArray(replacer)) {
          propertyList = [];
          for (var i = 0, list = replacer; i < list.length; i += 1) {
            var v = list[i];
            var item = void 0;
            if (typeof v === "string") {
              item = v;
            } else if (typeof v === "number" || v instanceof String || v instanceof Number) {
              item = String(v);
            }
            if (item !== void 0 && propertyList.indexOf(item) < 0) {
              propertyList.push(item);
            }
          }
        }
        if (space instanceof Number) {
          space = Number(space);
        } else if (space instanceof String) {
          space = String(space);
        }
        if (typeof space === "number") {
          if (space > 0) {
            space = Math.min(10, Math.floor(space));
            gap = "          ".substr(0, space);
          }
        } else if (typeof space === "string") {
          gap = space.substr(0, 10);
        }
        return serializeProperty("", { "": value });
        function serializeProperty(key2, holder) {
          var value2 = holder[key2];
          if (value2 != null) {
            if (typeof value2.toJSON5 === "function") {
              value2 = value2.toJSON5(key2);
            } else if (typeof value2.toJSON === "function") {
              value2 = value2.toJSON(key2);
            }
          }
          if (replacerFunc) {
            value2 = replacerFunc.call(holder, key2, value2);
          }
          if (value2 instanceof Number) {
            value2 = Number(value2);
          } else if (value2 instanceof String) {
            value2 = String(value2);
          } else if (value2 instanceof Boolean) {
            value2 = value2.valueOf();
          }
          switch (value2) {
            case null:
              return "null";
            case true:
              return "true";
            case false:
              return "false";
          }
          if (typeof value2 === "string") {
            return quoteString(value2, false);
          }
          if (typeof value2 === "number") {
            return String(value2);
          }
          if (typeof value2 === "object") {
            return Array.isArray(value2) ? serializeArray(value2) : serializeObject(value2);
          }
          return void 0;
        }
        function quoteString(value2) {
          var quotes = {
            "'": 0.1,
            '"': 0.2
          };
          var replacements = {
            "'": "\\'",
            '"': '\\"',
            "\\": "\\\\",
            "\b": "\\b",
            "\f": "\\f",
            "\n": "\\n",
            "\r": "\\r",
            "	": "\\t",
            "\v": "\\v",
            "\0": "\\0",
            "\u2028": "\\u2028",
            "\u2029": "\\u2029"
          };
          var product = "";
          for (var i2 = 0; i2 < value2.length; i2++) {
            var c2 = value2[i2];
            switch (c2) {
              case "'":
              case '"':
                quotes[c2]++;
                product += c2;
                continue;
              case "\0":
                if (util.isDigit(value2[i2 + 1])) {
                  product += "\\x00";
                  continue;
                }
            }
            if (replacements[c2]) {
              product += replacements[c2];
              continue;
            }
            if (c2 < " ") {
              var hexString = c2.charCodeAt(0).toString(16);
              product += "\\x" + ("00" + hexString).substring(hexString.length);
              continue;
            }
            product += c2;
          }
          var quoteChar = quote || Object.keys(quotes).reduce(function(a, b) {
            return quotes[a] < quotes[b] ? a : b;
          });
          product = product.replace(new RegExp(quoteChar, "g"), replacements[quoteChar]);
          return quoteChar + product + quoteChar;
        }
        function serializeObject(value2) {
          if (stack2.indexOf(value2) >= 0) {
            throw TypeError("Converting circular structure to JSON5");
          }
          stack2.push(value2);
          var stepback = indent;
          indent = indent + gap;
          var keys = propertyList || Object.keys(value2);
          var partial = [];
          for (var i2 = 0, list2 = keys; i2 < list2.length; i2 += 1) {
            var key2 = list2[i2];
            var propertyString = serializeProperty(key2, value2);
            if (propertyString !== void 0) {
              var member = serializeKey(key2) + ":";
              if (gap !== "") {
                member += " ";
              }
              member += propertyString;
              partial.push(member);
            }
          }
          var final;
          if (partial.length === 0) {
            final = "{}";
          } else {
            var properties;
            if (gap === "") {
              properties = partial.join(",");
              final = "{" + properties + "}";
            } else {
              var separator = ",\n" + indent;
              properties = partial.join(separator);
              final = "{\n" + indent + properties + ",\n" + stepback + "}";
            }
          }
          stack2.pop();
          indent = stepback;
          return final;
        }
        function serializeKey(key2) {
          if (key2.length === 0) {
            return quoteString(key2, true);
          }
          var firstChar = String.fromCodePoint(key2.codePointAt(0));
          if (!util.isIdStartChar(firstChar)) {
            return quoteString(key2, true);
          }
          for (var i2 = firstChar.length; i2 < key2.length; i2++) {
            if (!util.isIdContinueChar(String.fromCodePoint(key2.codePointAt(i2)))) {
              return quoteString(key2, true);
            }
          }
          return key2;
        }
        function serializeArray(value2) {
          if (stack2.indexOf(value2) >= 0) {
            throw TypeError("Converting circular structure to JSON5");
          }
          stack2.push(value2);
          var stepback = indent;
          indent = indent + gap;
          var partial = [];
          for (var i2 = 0; i2 < value2.length; i2++) {
            var propertyString = serializeProperty(String(i2), value2);
            partial.push(propertyString !== void 0 ? propertyString : "null");
          }
          var final;
          if (partial.length === 0) {
            final = "[]";
          } else {
            if (gap === "") {
              var properties = partial.join(",");
              final = "[" + properties + "]";
            } else {
              var separator = ",\n" + indent;
              var properties$1 = partial.join(separator);
              final = "[\n" + indent + properties$1 + ",\n" + stepback + "]";
            }
          }
          stack2.pop();
          indent = stepback;
          return final;
        }
      };
      var JSON52 = {
        parse: parse2,
        stringify
      };
      var lib = JSON52;
      var es5 = lib;
      return es5;
    });
  }
});

// src/main.ts
var main_exports = {};
__export(main_exports, {
  ObsidianSpreadsheet: () => ObsidianSpreadsheet,
  default: () => main_default
});
module.exports = __toCommonJS(main_exports);
var import_obsidian10 = require("obsidian");

// src/settings.ts
var import_obsidian = require("obsidian");
var SheetSettingsTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Advanced Table XT \u8BBE\u7F6E" });
    new import_obsidian.Setting(containerEl).setName("\u539F\u751F\u8868\u683C\u540E\u5904\u7406").setDesc("\u542F\u7528\u6B64\u8BBE\u7F6E\u4EE5\u4F7F\u7528Obsidian Sheets\u7684\u6E32\u67D3\u5668").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.nativeProcessing).onChange(async (value) => {
        var _a, _b;
        this.plugin.settings.nativeProcessing = value;
        await this.plugin.saveSettings();
        (_a = this.app.workspace.activeLeaf) == null ? void 0 : _a.rebuildView();
        (_b = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView)) == null ? void 0 : _b.previewMode.rerender(true);
      })
    );
    new import_obsidian.Setting(containerEl).setName("\u5728\u5355\u5143\u683C\u4E2D\u4F7F\u7528\u6BB5\u843D").setDesc("\u542F\u7528\u6B64\u8BBE\u7F6E\u4EE5\u5728\u8868\u683C\u5355\u5143\u683C\u4E2D\u4F7F\u7528\u6BB5\u843D").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.paragraphs).onChange(async (value) => {
        var _a, _b;
        this.plugin.settings.paragraphs = value;
        await this.plugin.saveSettings();
        (_a = this.app.workspace.activeLeaf) == null ? void 0 : _a.rebuildView();
        (_b = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView)) == null ? void 0 : _b.previewMode.rerender(true);
      })
    );
    containerEl.createEl("h3", { text: "\u5DE5\u5177\u680F\u8BBE\u7F6E" });
    new import_obsidian.Setting(containerEl).setName("\u542F\u7528\u8868\u683C\u5DE5\u5177\u680F").setDesc("\u542F\u7528\u6216\u7981\u7528\u8868\u683C\u5DE5\u5177\u680F\u529F\u80FD").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.toolbarEnabled).onChange(async (value) => {
        this.plugin.settings.toolbarEnabled = value;
        await this.plugin.saveSettings();
        if (value) {
          this.plugin.createToolbar();
        } else {
          document.querySelectorAll(".advanced-table-toolbar-container").forEach((container) => {
            container.remove();
          });
        }
      })
    );
    containerEl.createEl("h3", { text: "\u7F16\u8F91\u6A21\u5F0F\u64CD\u4F5C" });
    new import_obsidian.Setting(containerEl).setName("\u542F\u7528\u7F16\u8F91\u6A21\u5F0F\u4E0B\u7684\u8868\u683C\u64CD\u4F5C").setDesc("\u5141\u8BB8\u5728\u7F16\u8F91\u6A21\u5F0F\u4E0B\u76F4\u63A5\u4FEE\u6539 Markdown \u6E90\u7801\u4E2D\u7684\u8868\u683C").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.enableEditModeOperations).onChange(async (value) => {
        this.plugin.settings.enableEditModeOperations = value;
        await this.plugin.saveSettings();
      })
    );
    containerEl.createEl("h3", { text: "\u5355\u5143\u683C\u5408\u5E76" });
    new import_obsidian.Setting(containerEl).setName("\u542F\u7528\u5355\u5143\u683C\u5408\u5E76").setDesc("\u542F\u7528\u4F7F\u7528 < \u548C ^ \u6807\u8BB0\u8FDB\u884C\u5355\u5143\u683C\u5408\u5E76\u7684\u529F\u80FD").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.enableCellMerging).onChange(async (value) => {
        var _a;
        this.plugin.settings.enableCellMerging = value;
        await this.plugin.saveSettings();
        (_a = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView)) == null ? void 0 : _a.previewMode.rerender(true);
      })
    );
    new import_obsidian.Setting(containerEl).setName("\u5408\u5E76\u975E\u7A7A\u5355\u5143\u683C\u65F6\u786E\u8BA4").setDesc("\u5F53\u5408\u5E76\u5305\u542B\u5185\u5BB9\u7684\u5355\u5143\u683C\u65F6\u663E\u793A\u786E\u8BA4\u5BF9\u8BDD\u6846").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.confirmMergeNonEmpty).onChange(async (value) => {
        this.plugin.settings.confirmMergeNonEmpty = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("\u81EA\u52A8\u5C45\u4E2D\u5408\u5E76\u5355\u5143\u683C").setDesc("\u81EA\u52A8\u5C06\u5408\u5E76\u5355\u5143\u683C\u4E2D\u7684\u5185\u5BB9\u5C45\u4E2D\u663E\u793A").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.autoCenterMergedCells).onChange(async (value) => {
        var _a;
        this.plugin.settings.autoCenterMergedCells = value;
        await this.plugin.saveSettings();
        (_a = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView)) == null ? void 0 : _a.previewMode.rerender(true);
      })
    );
    containerEl.createEl("h3", { text: "\u8868\u683CID\u8BBE\u7F6E" });
    new import_obsidian.Setting(containerEl).setName("\u542F\u7528\u8868\u683CID").setDesc("\u81EA\u52A8\u4E3A\u8868\u683C\u6DFB\u52A0ID\u4F5C\u4E3AHTML\u6CE8\u91CA").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.enableTableIds).onChange(async (value) => {
        this.plugin.settings.enableTableIds = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("\u4F7F\u7528\u8868\u683C\u6CE8\u91CA\u5939\u6A21\u5F0F").setDesc('\u5728\u8868\u683C\u524D\u540E\u6DFB\u52A0\u914D\u5BF9\u7684HTML\u6CE8\u91CA\uFF0C\u5F62\u6210"\u6CE8\u91CA\u5939"\uFF0C\u63D0\u9AD8\u8868\u683CID\u8BC6\u522B\u7684\u51C6\u786E\u6027').addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.useTableWrapperComments).onChange(async (value) => {
        this.plugin.settings.useTableWrapperComments = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("\u8868\u683CID\u524D\u7F00").setDesc("\u751F\u6210\u7684\u8868\u683CID\u524D\u7F00").addText(
      (text) => text.setValue(this.plugin.settings.idPrefix).onChange(async (value) => {
        this.plugin.settings.idPrefix = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("\u8868\u683C\u7279\u5F81\u5339\u914D\u76F8\u4F3C\u5EA6\u9608\u503C").setDesc("\u5F53\u901A\u8FC7\u7279\u5F81\u5339\u914D\u8868\u683C\u65F6\uFF0C\u9700\u8981\u8FBE\u5230\u7684\u6700\u5C0F\u76F8\u4F3C\u5EA6\uFF080-1\u4E4B\u95F4\uFF0C\u9ED8\u8BA40.7\uFF09").addSlider(
      (slider) => slider.setLimits(0.5, 1, 0.05).setValue(this.plugin.settings.featureSimilarityThreshold || 0.7).setDynamicTooltip().onChange(async (value) => {
        this.plugin.settings.featureSimilarityThreshold = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("\u4F18\u5148\u4F7F\u7528\u8868\u683C\u7279\u5F81\u5339\u914D").setDesc("\u542F\u7528\u540E\uFF0C\u5C06\u4F18\u5148\u4F7F\u7528\u7279\u5F81\u5339\u914D\u800C\u975E\u4F4D\u7F6E\u5339\u914D\u6765\u8BC6\u522B\u8868\u683CID").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.preferFeatureMatching || false).onChange(async (value) => {
        this.plugin.settings.preferFeatureMatching = value;
        await this.plugin.saveSettings();
      })
    );
    containerEl.createEl("h3", { text: "\u6570\u636E\u5B58\u50A8\u8BBE\u7F6E" });
    new import_obsidian.Setting(containerEl).setName("\u4F18\u5148\u4F7F\u7528\u6587\u4EF6\u5B58\u50A8").setDesc("\u542F\u7528\u540E\uFF0C\u8868\u683C\u6570\u636E\u5C06\u4F18\u5148\u5B58\u50A8\u5728Markdown\u6587\u4EF6\u4E2D\uFF0C\u800C\u4E0D\u662Fdata.json\u6587\u4EF6\u4E2D").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.preferFileStorage || false).onChange(async (value) => {
        this.plugin.settings.preferFileStorage = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("\u81EA\u52A8\u5BFC\u51FA\u5230\u6587\u4EF6").setDesc("\u542F\u7528\u540E\uFF0C\u5373\u4F7F\u4F7F\u7528data.json\u5B58\u50A8\u6570\u636E\uFF0C\u4E5F\u4F1A\u81EA\u52A8\u5C06\u6570\u636E\u5BFC\u51FA\u5230Markdown\u6587\u4EF6\u4E2D").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.autoExportToFile || false).onChange(async (value) => {
        this.plugin.settings.autoExportToFile = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("\u4F7F\u7528\u7D27\u51D1\u683C\u5F0F\u5B58\u50A8\u6570\u636E").setDesc("\u542F\u7528\u540E\uFF0C\u8868\u683C\u6570\u636E\u5C06\u4EE5\u66F4\u7D27\u51D1\u7684\u81EA\u5B9A\u4E49\u683C\u5F0F\u5B58\u50A8\uFF0C\u800C\u4E0D\u662F\u5B8C\u6574\u7684JSON\u683C\u5F0F").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.useCompactFormat || true).onChange(async (value) => {
        this.plugin.settings.useCompactFormat = value;
        await this.plugin.saveSettings();
      })
    );
  }
};

// src/sheetElement.ts
var import_obsidian2 = require("obsidian");
var JSON5 = __toESM(require_dist());
var MERGE_UP_SIGNIFIER = "^";
var MERGE_LEFT_SIGNIFIER = "<";
var HEADER_DELIMETER = "-";
var META_DELIMETER = "---";
var SheetElement = class extends import_obsidian2.MarkdownRenderChild {
  constructor(el, source, ctx, app, plugin) {
    super(el);
    this.el = el;
    this.source = source;
    this.ctx = ctx;
    this.app = app;
    this.plugin = plugin;
    this.globalStyle = {};
    this.cellMaxLength = 0;
    this.rowMaxLength = 0;
    this.rowStyles = [];
    this.colStyles = [];
    this.domGrid = [];
  }
  async onload() {
    this.metaRE = new RegExp(String.raw`^${META_DELIMETER}\s*?(?:~(.*?))?\s*?\n+`, "mg");
    this.newLineRE = new RegExp(String.raw`\n`);
    this.cellBorderRE = new RegExp(String.raw`(?<!\\)\|`);
    this.headerRE = new RegExp(String.raw`^\s*?(:)?(?:${HEADER_DELIMETER})+?(:)?\s*?(?:(?<!\\)~(.*?))?$`);
    this.parseInputToGrid();
    this.validateInput();
    this.normalizeGrid();
    this.table = this.el;
    this.table.id = "obsidian-sheets-parsed";
    this.tableHead = this.table.createEl("thead");
    this.tableBody = this.table.createEl("tbody");
    this.getHeaderBoundaries();
    this.getHeaderStyles();
    this.buildDomTable();
  }
  onunload() {
  }
  displayError(error) {
    this.el.createDiv({
      text: `
Error: \`${error}\`

`,
      cls: "obs-sheets_error"
    });
    this.unload();
  }
  parseInputToGrid() {
    var _a;
    if (!this.metaRE.test(this.source))
      return this.contentGrid = this.source.split(this.newLineRE).filter((row) => this.cellBorderRE.test(row)).map((row) => row.split(this.cellBorderRE).map((cell) => cell.trim()));
    const [meta, unparsedStyle, source] = this.source.split(this.metaRE);
    this.parseMetadata(meta);
    if (unparsedStyle) {
      let cellStyle = {};
      const cls = unparsedStyle.match(/\.\S+/g) || [];
      cls.forEach((cssClass) => {
        var _a2;
        cellStyle = { ...cellStyle, ...((_a2 = this.styles) == null ? void 0 : _a2[cssClass.slice(1)]) || {} };
      });
      const inlineStyle = ((_a = unparsedStyle.match(/\{.*\}/)) == null ? void 0 : _a[0]) || "{}";
      try {
        cellStyle = { ...cellStyle, ...JSON5.parse(inlineStyle) };
      } catch (e) {
        console.error(`Invalid cell style \`${inlineStyle}\``);
      }
      this.globalStyle = cellStyle;
    }
    return this.contentGrid = source.split(this.newLineRE).map((row) => row.split(this.cellBorderRE).map((cell) => cell.trim()));
  }
  parseMetadata(meta) {
    let metadata;
    try {
      metadata = JSON5.parse(meta);
    } catch (error) {
      return this.displayError("Metadata is not proper JSON");
    }
    this.metadata = metadata;
    if (metadata.classes) {
      this.styles = metadata.classes;
    }
  }
  validateInput() {
    if (!this.contentGrid.every(
      (row) => {
        var _a, _b;
        return !((_a = row.pop()) == null ? void 0 : _a.trim()) && !((_b = row.shift()) == null ? void 0 : _b.trim());
      }
    ))
      return this.displayError("Malformed table");
  }
  normalizeGrid() {
    for (let rowIndex = 0; rowIndex < this.contentGrid.length; rowIndex++) {
      const row = this.contentGrid[rowIndex];
      if (this.rowMaxLength < row.length)
        this.rowMaxLength = row.length;
      for (let colIndex = 0; colIndex < row.length; colIndex++)
        if (this.cellMaxLength < row[colIndex].trim().length)
          this.cellMaxLength = row[colIndex].trim().length;
    }
    this.contentGrid = this.contentGrid.map(
      (line) => Array.from(
        { ...line, length: this.rowMaxLength },
        (cell) => cell || ""
      )
    );
  }
  getHeaderBoundaries() {
    this.headerRow = this.contentGrid.findIndex(
      (headerRow) => headerRow.every((headerCol) => this.headerRE.test(headerCol))
    );
    this.headerCol = this.contentGrid[0].map(
      (_, i) => this.contentGrid.map((row) => row[i])
    ).findIndex(
      (headerCol) => headerCol.every((headerCol2) => this.headerRE.test(headerCol2))
    );
  }
  getHeaderStyles() {
    if (this.headerRow !== -1)
      this.colStyles = this.contentGrid[this.headerRow].map((rowHead) => {
        var _a, _b;
        let styles = {};
        const alignment = rowHead.match(this.headerRE);
        if (!alignment)
          return { classes: [], styles };
        else if (alignment[1] && alignment[2])
          styles["textAlign"] = "center";
        else if (alignment[1])
          styles["textAlign"] = "left";
        else if (alignment[2])
          styles["textAlign"] = "right";
        const classes = ((_b = (_a = alignment[3]) == null ? void 0 : _a.match(/\.\S+/g)) == null ? void 0 : _b.map(String)) || [];
        classes.forEach(
          (cssClass) => {
            var _a2;
            return styles = {
              ...styles,
              ...((_a2 = this.styles) == null ? void 0 : _a2[cssClass.slice(1)]) || {}
            };
          }
        );
        return { classes, styles };
      });
    if (this.headerCol !== -1)
      this.rowStyles = this.contentGrid[0].map(
        (_, i) => this.contentGrid.map((row) => row[i])
      )[this.headerCol].map((rowHead) => {
        var _a, _b;
        let styles = {};
        const alignment = rowHead.match(this.headerRE);
        if (!alignment)
          return { classes: [], styles };
        else if (alignment[1] && alignment[2])
          styles["textAlign"] = "center";
        else if (alignment[1])
          styles["textAlign"] = "left";
        else if (alignment[2])
          styles["textAlign"] = "right";
        const classes = ((_b = (_a = alignment[3]) == null ? void 0 : _a.match(/\.\S+/g)) == null ? void 0 : _b.map(String)) || [];
        classes.forEach(
          (cssClass) => {
            var _a2;
            return styles = {
              ...styles,
              ...((_a2 = this.styles) == null ? void 0 : _a2[cssClass.slice(1)]) || {}
            };
          }
        );
        return { classes, styles };
      });
  }
  buildDomTable() {
    for (let rowIndex = 0; rowIndex < this.contentGrid.length; rowIndex++)
      this.buildDomRow(rowIndex);
  }
  buildDomRow(rowIndex) {
    const rowContents = this.contentGrid[rowIndex];
    let rowNode = this.tableBody.createEl("tr");
    if (rowIndex < this.headerRow)
      rowNode = this.tableHead.createEl("tr");
    else if (rowIndex === this.headerRow)
      return;
    this.domGrid[rowIndex] = [];
    for (let columnIndex = 0; columnIndex < rowContents.length; columnIndex++)
      this.buildDomCell(rowIndex, columnIndex, rowNode);
  }
  async buildDomCell(rowIndex, columnIndex, rowNode) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i;
    const [
      cellContent,
      cellStyles
    ] = this.contentGrid[rowIndex][columnIndex].split(/(?<![\\~])~(?!~)/);
    let cls = [];
    let cellStyle = this.globalStyle;
    if (this.rowStyles[rowIndex]) {
      cellStyle = { ...cellStyle, ...this.rowStyles[rowIndex].styles };
      cls.push(...this.rowStyles[rowIndex].classes);
    }
    if (this.colStyles[columnIndex]) {
      cellStyle = { ...cellStyle, ...this.colStyles[columnIndex].styles };
      cls.push(...this.colStyles[columnIndex].classes);
    }
    if (cellStyles) {
      cls = cellStyles.match(/(?<=\.)\S+/g) || [];
      cls.forEach((cssClass) => {
        var _a2;
        cellStyle = { ...cellStyle, ...((_a2 = this.styles) == null ? void 0 : _a2[cssClass]) || {} };
      });
      const inlineStyle = ((_a = cellStyles.match(/\{.*\}/)) == null ? void 0 : _a[0]) || "{}";
      try {
        cellStyle = { ...cellStyle, ...JSON5.parse(inlineStyle) };
      } catch (e) {
        console.error(`Invalid cell style \`${inlineStyle}\``);
      }
    }
    let cellTag = "td";
    let cell;
    if (columnIndex === this.headerCol || rowIndex === this.headerRow)
      return;
    else if (columnIndex < this.headerCol || rowIndex < this.headerRow)
      cellTag = "th";
    if (cellContent == MERGE_LEFT_SIGNIFIER && ((_c = (_b = this.domGrid) == null ? void 0 : _b[rowIndex]) == null ? void 0 : _c[columnIndex - 1])) {
      cell = this.domGrid[rowIndex][columnIndex - 1];
      (cell == null ? void 0 : cell.colSpan) || Object.assign(cell, { colSpan: 1 });
      cell.colSpan = columnIndex - parseInt(cell.getAttribute("col-index") || columnIndex.toString()) + 1;
    } else if (cellContent == MERGE_UP_SIGNIFIER && ((_e = (_d = this.domGrid) == null ? void 0 : _d[rowIndex - 1]) == null ? void 0 : _e[columnIndex])) {
      cell = this.domGrid[rowIndex - 1][columnIndex];
      (cell == null ? void 0 : cell.rowSpan) || Object.assign(cell, { rowSpan: 1 });
      cell.rowSpan = rowIndex - parseInt(cell.getAttribute("row-index") || "0") + 1;
    } else if (((_g = (_f = this.domGrid) == null ? void 0 : _f[rowIndex - 1]) == null ? void 0 : _g[columnIndex]) && ((_i = (_h = this.domGrid) == null ? void 0 : _h[rowIndex]) == null ? void 0 : _i[columnIndex - 1]) && this.domGrid[rowIndex][columnIndex - 1] === this.domGrid[rowIndex - 1][columnIndex])
      cell = this.domGrid[rowIndex][columnIndex - 1];
    else {
      cell = rowNode.createEl(cellTag, { cls });
      cell.setAttribute("row-index", rowIndex.toString());
      cell.setAttribute("col-index", columnIndex.toString());
      import_obsidian2.MarkdownRenderer.render(
        this.app,
        "\u200B " + (cellContent || "\u200B"),
        // Make sure markdown that requires to be at the start of a line is not rendered
        cell,
        "",
        this
      ).then(() => {
        cell.innerHTML = cell.children[0].innerHTML.replace(/^\u200B /g, "");
      });
      Object.assign(cell.style, cellStyle);
    }
    return this.domGrid[rowIndex][columnIndex] = cell;
  }
};

// src/markdownTableDetector.ts
var import_obsidian3 = require("obsidian");
var ConfirmModal = class extends import_obsidian3.Modal {
  constructor(app, message, onClose) {
    super(app);
    this.result = false;
    this.message = message;
    this.onClose = onClose;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h2", { text: "\u786E\u8BA4\u64CD\u4F5C" });
    contentEl.createEl("p", { text: this.message });
    const buttonContainer = contentEl.createDiv({ cls: "modal-button-container" });
    buttonContainer.createEl("button", { text: "\u53D6\u6D88" }).addEventListener("click", () => {
      this.result = false;
      this.close();
    });
    buttonContainer.createEl("button", { text: "\u786E\u8BA4", cls: "mod-cta" }).addEventListener("click", () => {
      this.result = true;
      this.close();
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
    this.onClose(this.result);
  }
};
var MarkdownTableDetector = class {
  // app
  getApp() {
    return this.plugin.app;
  }
  constructor(plugin) {
    this.plugin = plugin;
    console.log("MarkdownTableDetector initialized");
  }
  /**
   * 
   * @param message 
   * @returns 
   */
  async showConfirmDialog(message) {
    return new Promise((resolve) => {
      const modal = new ConfirmModal(this.getApp(), message, (result) => {
        resolve(result);
      });
      modal.open();
    });
  }
  /**
   * HTMLMarkdown
   * @param table HTML
   * @returns HTML
   */
  isHtmlFormattedTable(table) {
    try {
      if (table.hasAttribute("border") || table.hasAttribute("cellpadding") || table.hasAttribute("cellspacing") || table.hasAttribute("width") || table.hasAttribute("height") || table.hasAttribute("bgcolor")) {
        return true;
      }
      const style = table.getAttribute("style");
      if (style && (style.includes("border-collapse") || style.includes("text-align") || style.includes("font-family") || style.includes("background-color"))) {
        return true;
      }
      const cells = table.querySelectorAll("td, th");
      for (const cell of Array.from(cells).slice(0, 10)) {
        const html = cell.innerHTML || "";
        if (html.includes("<") && html.includes(">") && !html.match(/^<(em|strong|s|code|a|span)[^>]*>.*<\/(em|strong|s|code|a|span)>$/)) {
          return true;
        }
      }
      const rows = table.querySelectorAll("tr");
      if (rows.length > 1) {
        const secondRow = rows[1];
        const separatorCells = secondRow.querySelectorAll("td, th");
        let isSeparatorRow = true;
        for (const cell of Array.from(separatorCells)) {
          const text = cell.textContent || "";
          if (!text.match(/^:?-+:?$/)) {
            isSeparatorRow = false;
            break;
          }
        }
        if (!isSeparatorRow) {
          return true;
        }
      }
      return false;
    } catch (error) {
      console.error("\u68C0\u6D4BHTML\u8868\u683C\u65F6\u51FA\u9519:", error);
      return false;
    }
  }
  /**
   * 
   * @param table HTML
   */
  setupTableIndices(table) {
    try {
      const rows = table.querySelectorAll("tr");
      for (let rowIndex = 0; rowIndex < rows.length; rowIndex++) {
        const row = rows[rowIndex];
        const cells = row.querySelectorAll("td, th");
        for (let colIndex = 0; colIndex < cells.length; colIndex++) {
          const cell = cells[colIndex];
          cell.dataset.rowIndex = rowIndex.toString();
          cell.dataset.colIndex = colIndex.toString();
          cell.setAttribute("row-index", rowIndex.toString());
          cell.setAttribute("col-index", colIndex.toString());
          cell.classList.add("advanced-table-cell");
          if (cell.tagName.toLowerCase() === "th") {
            cell.classList.add("advanced-table-header");
          }
          if (!cell.innerHTML.trim()) {
            cell.innerHTML = "&nbsp;";
          }
        }
      }
    } catch (error) {
      console.error("\u8BBE\u7F6E\u8868\u683C\u7D22\u5F15\u65F6\u51FA\u9519:", error);
    }
  }
  /**
   * 
   * @param cell 
   * @param marker  ('^'  '<')
   * @returns 
   */
  isMergeMarker(cell, marker) {
    var _a;
    const content = ((_a = cell.textContent) == null ? void 0 : _a.trim()) || "";
    if (marker === "^") {
      return /^(\^+|\\\^|\s*\^+\s*)$/.test(content);
    } else if (marker === "<") {
      return /^(<+|\\<|\s*<+\s*)$/.test(content);
    }
    return false;
  }
  /**
   * 
   * @param cell 
   * @returns 
   */
  hasMeaningfulContent(cell) {
    var _a;
    const content = ((_a = cell.textContent) == null ? void 0 : _a.trim()) || "";
    return content !== "" && content !== "&nbsp;" && !/^(\^+|\\\^|\s*\^+\s*)$/.test(content) && !/^(<+|\\<|\s*<+\s*)$/.test(content);
  }
  /**
   * 
   * @param table HTML
   */
  async parseMergeCellMarkers(table) {
    var _a, _b, _c, _d, _e, _f, _g;
    if (!this.plugin.settings.enableCellMerging)
      return;
    try {
      const rows = table.querySelectorAll("tr");
      const mergeUp = [];
      const mergeLeft = [];
      for (let rowIndex = 0; rowIndex < rows.length; rowIndex++) {
        const row = rows[rowIndex];
        const cells = row.querySelectorAll("td, th");
        for (let colIndex = 0; colIndex < cells.length; colIndex++) {
          const cell = cells[colIndex];
          const content = ((_a = cell.textContent) == null ? void 0 : _a.trim()) || "";
          const upMatch = content.match(/^(\^+)$/);
          if (upMatch) {
            const count = upMatch[1].length;
            console.log(`\u53D1\u73B0\u5411\u4E0A\u5408\u5E76\u6807\u8BB0: \u884C=${rowIndex}, \u5217=${colIndex}, \u6807\u8BB0\u6570\u91CF=${count}, \u5185\u5BB9="${content}"`);
            mergeUp.push({ cell, count });
            continue;
          }
          const leftMatch = content.match(/^(<+)$/);
          if (leftMatch) {
            const count = leftMatch[1].length;
            console.log(`\u53D1\u73B0\u5411\u5DE6\u5408\u5E76\u6807\u8BB0: \u884C=${rowIndex}, \u5217=${colIndex}, \u6807\u8BB0\u6570\u91CF=${count}, \u5185\u5BB9="${content}"`);
            mergeLeft.push({ cell, count });
            continue;
          }
          if (content === "\\^" || content === " ^ " || content === " \\^ ") {
            console.log(`\u53D1\u73B0\u8F6C\u4E49\u5411\u4E0A\u5408\u5E76\u6807\u8BB0: \u884C=${rowIndex}, \u5217=${colIndex}, \u5185\u5BB9="${content}"`);
            mergeUp.push({ cell, count: 1 });
          } else if (content === "\\<" || content === " < " || content === " \\< ") {
            console.log(`\u53D1\u73B0\u8F6C\u4E49\u5411\u5DE6\u5408\u5E76\u6807\u8BB0: \u884C=${rowIndex}, \u5217=${colIndex}, \u5185\u5BB9="${content}"`);
            mergeLeft.push({ cell, count: 1 });
          }
        }
      }
      for (const { cell, count } of mergeUp) {
        const rowIndex = parseInt(cell.getAttribute("row-index") || cell.dataset.rowIndex || "0");
        const colIndex = parseInt(cell.getAttribute("col-index") || cell.dataset.colIndex || "0");
        console.log(`\u5904\u7406\u5411\u4E0A\u5408\u5E76: \u884C=${rowIndex}, \u5217=${colIndex}, \u5408\u5E76\u6570\u91CF=${count}`);
        if (rowIndex >= count) {
          const targetRowIndex = rowIndex - count;
          const targetRow = rows[targetRowIndex];
          if (targetRow) {
            const targetCells = targetRow.querySelectorAll("td, th");
            if (colIndex < targetCells.length) {
              const targetCell = targetCells[colIndex];
              if (this.hasMeaningfulContent(targetCell)) {
                const cellsToMerge = [];
                if (this.hasMeaningfulContent(cell)) {
                  cellsToMerge.push({
                    rowIndex,
                    colIndex,
                    content: ((_b = cell.textContent) == null ? void 0 : _b.trim()) || ""
                  });
                }
                for (let i = 1; i < count; i++) {
                  const midRowIndex = rowIndex - i;
                  if (midRowIndex > targetRowIndex) {
                    const midRow = rows[midRowIndex];
                    const midCells = midRow.querySelectorAll("td, th");
                    if (colIndex < midCells.length) {
                      const midCell = midCells[colIndex];
                      if (this.hasMeaningfulContent(midCell)) {
                        cellsToMerge.push({
                          rowIndex: midRowIndex,
                          colIndex,
                          content: ((_c = midCell.textContent) == null ? void 0 : _c.trim()) || ""
                        });
                      }
                    }
                  }
                }
                if (this.plugin.settings.confirmMergeNonEmpty && cellsToMerge.length > 0) {
                  const cellContents = cellsToMerge.map(
                    (c) => `[${c.rowIndex + 1},${c.colIndex + 1}]: "${c.content}"`
                  ).join("\n");
                  const confirmMerge = await this.showConfirmDialog(
                    `\u4EE5\u4E0B\u5355\u5143\u683C\u5305\u542B\u5185\u5BB9\u5C06\u88AB\u8986\u76D6:
${cellContents}

\u786E\u5B9A\u8981\u5408\u5E76\u8FD9\u4E9B\u5355\u5143\u683C\u5417\uFF1F`
                  );
                  if (!confirmMerge) {
                    console.log("\u7528\u6237\u53D6\u6D88\u4E86\u5355\u5143\u683C\u5408\u5E76");
                    continue;
                  }
                }
                let rowSpan = parseInt(targetCell.getAttribute("rowspan") || "1");
                rowSpan = rowSpan + count;
                console.log(`\u8BBE\u7F6Erowspan: \u76EE\u6807\u5355\u5143\u683C(${targetRowIndex},${colIndex}), rowspan=${rowSpan}`);
                targetCell.setAttribute("rowspan", rowSpan.toString());
                targetCell.rowSpan = rowSpan;
                targetCell.classList.add("obs-merged-cell");
                cell.style.display = "none";
              } else {
                console.warn("\u5411\u4E0A\u5408\u5E76\u5931\u8D25: \u76EE\u6807\u5355\u5143\u683C\u6CA1\u6709\u6709\u6548\u5185\u5BB9", targetCell);
              }
            }
          }
        }
      }
      for (const { cell, count } of mergeLeft) {
        const rowIndex = parseInt(cell.getAttribute("row-index") || cell.dataset.rowIndex || "0");
        const colIndex = parseInt(cell.getAttribute("col-index") || cell.dataset.colIndex || "0");
        console.log(`\u5904\u7406\u5411\u5DE6\u5408\u5E76: \u884C=${rowIndex}, \u5217=${colIndex}, \u5408\u5E76\u6570\u91CF=${count}`);
        if (colIndex >= count) {
          const targetColIndex = colIndex - count;
          const targetCell = (_d = rows[rowIndex]) == null ? void 0 : _d.querySelectorAll("td, th")[targetColIndex];
          if (targetCell) {
            if (this.hasMeaningfulContent(targetCell)) {
              const cellsToMerge = [];
              if (this.hasMeaningfulContent(cell)) {
                cellsToMerge.push({
                  rowIndex,
                  colIndex,
                  content: ((_e = cell.textContent) == null ? void 0 : _e.trim()) || ""
                });
              }
              for (let i = 1; i < count; i++) {
                const midColIndex = colIndex - i;
                if (midColIndex > targetColIndex) {
                  const midCell = (_f = rows[rowIndex]) == null ? void 0 : _f.querySelectorAll("td, th")[midColIndex];
                  if (midCell && this.hasMeaningfulContent(midCell)) {
                    cellsToMerge.push({
                      rowIndex,
                      colIndex: midColIndex,
                      content: ((_g = midCell.textContent) == null ? void 0 : _g.trim()) || ""
                    });
                  }
                }
              }
              if (this.plugin.settings.confirmMergeNonEmpty && cellsToMerge.length > 0) {
                const cellContents = cellsToMerge.map(
                  (c) => `[${c.rowIndex + 1},${c.colIndex + 1}]: "${c.content}"`
                ).join("\n");
                const confirmMerge = await this.showConfirmDialog(
                  `\u4EE5\u4E0B\u5355\u5143\u683C\u5305\u542B\u5185\u5BB9\u5C06\u88AB\u8986\u76D6:
${cellContents}

\u786E\u5B9A\u8981\u5408\u5E76\u8FD9\u4E9B\u5355\u5143\u683C\u5417\uFF1F`
                );
                if (!confirmMerge) {
                  console.log("\u7528\u6237\u53D6\u6D88\u4E86\u5355\u5143\u683C\u5408\u5E76");
                  continue;
                }
              }
              let colSpan = parseInt(targetCell.getAttribute("colspan") || "1");
              colSpan = colSpan + count;
              console.log(`\u8BBE\u7F6Ecolspan: \u76EE\u6807\u5355\u5143\u683C(${rowIndex},${targetColIndex}), colspan=${colSpan}`);
              targetCell.setAttribute("colspan", colSpan.toString());
              targetCell.colSpan = colSpan;
              targetCell.classList.add("obs-merged-cell");
              cell.style.display = "none";
            } else {
              console.warn("\u5411\u5DE6\u5408\u5E76\u5931\u8D25: \u76EE\u6807\u5355\u5143\u683C\u6CA1\u6709\u6709\u6548\u5185\u5BB9", targetCell);
            }
          }
        }
      }
      if (this.plugin.settings.autoCenterMergedCells) {
        const mergedCells = table.querySelectorAll("[rowspan], [colspan]");
        mergedCells.forEach((cell) => {
          const htmlCell = cell;
          if (parseInt(htmlCell.getAttribute("rowspan") || "1") > 1 || parseInt(htmlCell.getAttribute("colspan") || "1") > 1) {
            htmlCell.style.textAlign = "center";
            htmlCell.style.verticalAlign = "middle";
            htmlCell.classList.add("obs-merged-cell");
          }
        });
      }
    } catch (error) {
      console.error("\u89E3\u6790\u5355\u5143\u683C\u5408\u5E76\u6807\u8BB0\u65F6\u51FA\u9519:", error);
    }
  }
  /**
   * Markdown
   * @param table HTML
   */
  applyMergeCellsMarkers(table) {
    var _a;
    try {
      if (table.dataset.tableMergeProcessed === "true") {
        return;
      }
      const rows = table.querySelectorAll("tr");
      for (let rowIndex = 0; rowIndex < rows.length; rowIndex++) {
        const row = rows[rowIndex];
        const cells = row.querySelectorAll("td, th");
        for (let colIndex = 0; colIndex < cells.length; colIndex++) {
          const cell = cells[colIndex];
          const cellContent = ((_a = cell.textContent) == null ? void 0 : _a.trim()) || "";
          const leftMatch = cellContent.match(/^(<+|\\<|\s*<+\s*)$/);
          if (leftMatch && colIndex > 0) {
            let mergeCount = 1;
            if (cellContent.match(/^<+$/)) {
              mergeCount = cellContent.length;
            }
            console.log(`\u5E94\u7528\u5411\u5DE6\u5408\u5E76\u6807\u8BB0: \u884C=${rowIndex}, \u5217=${colIndex}, \u6807\u8BB0\u6570\u91CF=${mergeCount}, \u5185\u5BB9="${cellContent}"`);
            const targetColIndex = colIndex - mergeCount;
            if (targetColIndex >= 0) {
              const leftCell = cells[targetColIndex];
              const colSpan2 = mergeCount + 1;
              console.log(`\u8BBE\u7F6Ecolspan: \u76EE\u6807\u5355\u5143\u683C(${rowIndex},${targetColIndex}), colspan=${colSpan2}`);
              leftCell.colSpan = colSpan2;
              leftCell.setAttribute("colspan", colSpan2.toString());
              cell.style.display = "none";
              if (this.plugin.settings.autoCenterMergedCells) {
                leftCell.style.textAlign = "center";
                leftCell.style.verticalAlign = "middle";
              }
              leftCell.classList.add("obs-merged-cell");
            }
            continue;
          }
          const upMatch = cellContent.match(/^(\^+|\\\^|\s*\^+\s*)$/);
          if (upMatch && rowIndex > 0) {
            let mergeCount = 1;
            if (cellContent.match(/^\^+$/)) {
              mergeCount = cellContent.length;
            }
            console.log(`\u5E94\u7528\u5411\u4E0A\u5408\u5E76\u6807\u8BB0: \u884C=${rowIndex}, \u5217=${colIndex}, \u6807\u8BB0\u6570\u91CF=${mergeCount}, \u5185\u5BB9="${cellContent}"`);
            const targetRowIndex = rowIndex - mergeCount;
            if (targetRowIndex >= 0) {
              const aboveRow = rows[targetRowIndex];
              const aboveCells = aboveRow.querySelectorAll("td, th");
              if (colIndex < aboveCells.length) {
                const aboveCell = aboveCells[colIndex];
                const rowSpan2 = mergeCount + 1;
                console.log(`\u8BBE\u7F6Erowspan: \u76EE\u6807\u5355\u5143\u683C(${targetRowIndex},${colIndex}), rowspan=${rowSpan2}`);
                aboveCell.rowSpan = rowSpan2;
                aboveCell.setAttribute("rowspan", rowSpan2.toString());
                cell.style.display = "none";
                if (this.plugin.settings.autoCenterMergedCells) {
                  aboveCell.style.textAlign = "center";
                  aboveCell.style.verticalAlign = "middle";
                }
                aboveCell.classList.add("obs-merged-cell");
              }
            }
            continue;
          }
          const rowSpan = parseInt(cell.getAttribute("rowspan") || "1");
          const colSpan = parseInt(cell.getAttribute("colspan") || "1");
          if (rowSpan > 1) {
            for (let i = 1; i < rowSpan; i++) {
              if (rowIndex + i < rows.length) {
                const targetRow = rows[rowIndex + i];
                const targetCells = targetRow.querySelectorAll("td, th");
                if (colIndex < targetCells.length) {
                  const targetCell = targetCells[colIndex];
                  const markerText = "^".repeat(i);
                  console.log(`\u6DFB\u52A0\u5411\u4E0A\u5408\u5E76\u6807\u8BB0: \u4F4D\u7F6E(${rowIndex + i},${colIndex}), \u6807\u8BB0="${markerText}"`);
                  targetCell.textContent = markerText;
                  targetCell.classList.add("merge-marker");
                }
              }
            }
          }
          if (colSpan > 1) {
            for (let i = 1; i < colSpan; i++) {
              if (colIndex + i < cells.length) {
                const targetCell = cells[colIndex + i];
                const markerText = "<".repeat(i);
                console.log(`\u6DFB\u52A0\u5411\u5DE6\u5408\u5E76\u6807\u8BB0: \u4F4D\u7F6E(${rowIndex},${colIndex + i}), \u6807\u8BB0="${markerText}"`);
                targetCell.textContent = markerText;
                targetCell.classList.add("merge-marker");
              }
            }
          }
        }
      }
      table.dataset.tableMergeProcessed = "true";
      console.log(`\u8868\u683C\u5904\u7406\u5B8C\u6210\uFF0C\u5DF2\u6DFB\u52A0\u5408\u5E76\u6807\u8BB0`);
    } catch (error) {
      console.error("\u5E94\u7528\u5408\u5E76\u5355\u5143\u683C\u6807\u8BB0\u65F6\u51FA\u9519:", error);
    }
  }
  /**
   * 
   * @param table 
   * @param selectedCells 
   * @returns 
   */
  async mergeSelectedCells(table, selectedCells) {
    var _a;
    if (!selectedCells || selectedCells.length < 2) {
      new import_obsidian3.Notice("\u8BF7\u9009\u62E9\u81F3\u5C112\u4E2A\u5355\u5143\u683C\u8FDB\u884C\u5408\u5E76");
      return false;
    }
    try {
      let minRow = Number.MAX_SAFE_INTEGER;
      let maxRow = 0;
      let minCol = Number.MAX_SAFE_INTEGER;
      let maxCol = 0;
      for (const cell of selectedCells) {
        const rowIndex = parseInt(cell.getAttribute("row-index") || cell.dataset.rowIndex || "0");
        const colIndex = parseInt(cell.getAttribute("col-index") || cell.dataset.colIndex || "0");
        minRow = Math.min(minRow, rowIndex);
        maxRow = Math.max(maxRow, rowIndex);
        minCol = Math.min(minCol, colIndex);
        maxCol = Math.max(maxCol, colIndex);
      }
      const expectedCellCount = (maxRow - minRow + 1) * (maxCol - minCol + 1);
      if (expectedCellCount !== selectedCells.length) {
        new import_obsidian3.Notice("\u53EA\u80FD\u5408\u5E76\u5F62\u6210\u5B8C\u6574\u77E9\u5F62\u7684\u5355\u5143\u683C");
        return false;
      }
      const mainCell = table.querySelector(`[row-index="${minRow}"][col-index="${minCol}"]`);
      if (!mainCell) {
        new import_obsidian3.Notice("\u65E0\u6CD5\u627E\u5230\u4E3B\u5355\u5143\u683C");
        return false;
      }
      if (this.plugin.settings.confirmMergeNonEmpty) {
        const nonEmptyCells = [];
        for (const cell of selectedCells) {
          if (cell === mainCell)
            continue;
          if (this.hasMeaningfulContent(cell)) {
            const rowIndex = parseInt(cell.getAttribute("row-index") || cell.dataset.rowIndex || "0");
            const colIndex = parseInt(cell.getAttribute("col-index") || cell.dataset.colIndex || "0");
            nonEmptyCells.push({
              rowIndex,
              colIndex,
              content: ((_a = cell.textContent) == null ? void 0 : _a.trim()) || ""
            });
          }
        }
        if (nonEmptyCells.length > 0) {
          const cellContents = nonEmptyCells.map(
            (c) => `[${c.rowIndex + 1},${c.colIndex + 1}]: "${c.content}"`
          ).join("\n");
          const confirmMerge = await this.showConfirmDialog(
            `\u4EE5\u4E0B\u5355\u5143\u683C\u5305\u542B\u5185\u5BB9\u5C06\u88AB\u8986\u76D6:
${cellContents}

\u786E\u5B9A\u8981\u5408\u5E76\u8FD9\u4E9B\u5355\u5143\u683C\u5417\uFF1F`
          );
          if (!confirmMerge) {
            new import_obsidian3.Notice("\u5DF2\u53D6\u6D88\u5408\u5E76\u64CD\u4F5C");
            return false;
          }
        }
      }
      const rowSpanValue = maxRow - minRow + 1;
      const colSpanValue = maxCol - minCol + 1;
      mainCell.setAttribute("rowspan", rowSpanValue.toString());
      mainCell.setAttribute("colspan", colSpanValue.toString());
      mainCell.rowSpan = rowSpanValue;
      mainCell.colSpan = colSpanValue;
      mainCell.classList.add("obs-merged-cell");
      if (this.plugin.settings.autoCenterMergedCells) {
        mainCell.style.textAlign = "center";
        mainCell.style.verticalAlign = "middle";
      }
      for (const cell of selectedCells) {
        if (cell !== mainCell) {
          cell.style.display = "none";
        }
      }
      this.applyMergeCellsMarkersForArea(table, minRow, minCol, maxRow, maxCol);
      return true;
    } catch (error) {
      console.error("\u5408\u5E76\u9009\u4E2D\u5355\u5143\u683C\u65F6\u51FA\u9519:", error);
      return false;
    }
  }
  /**
   * 
   * @param table 
   * @param startRow 
   * @param startCol 
   * @param endRow 
   * @param endCol 
   */
  applyMergeCellsMarkersForArea(table, startRow, startCol, endRow, endCol) {
    try {
      const rows = table.querySelectorAll("tr");
      for (let rowIndex = startRow; rowIndex <= endRow; rowIndex++) {
        if (rowIndex < rows.length) {
          const row = rows[rowIndex];
          const cells = row.querySelectorAll("td, th");
          for (let colIndex = startCol; colIndex <= endCol; colIndex++) {
            if (colIndex < cells.length && !(rowIndex === startRow && colIndex === startCol)) {
              const cell = cells[colIndex];
              if (colIndex === startCol) {
                cell.textContent = "^";
                cell.classList.add("merge-marker");
              } else if (rowIndex === startRow) {
                cell.textContent = "<";
                cell.classList.add("merge-marker");
              } else {
                cell.textContent = Math.random() > 0.5 ? "^" : "<";
                cell.classList.add("merge-marker", "hidden-marker");
              }
            }
          }
        }
      }
    } catch (error) {
      console.error("\u5E94\u7528\u533A\u57DF\u5408\u5E76\u6807\u8BB0\u65F6\u51FA\u9519:", error);
    }
  }
};

// src/tableIdManager.ts
var import_obsidian4 = require("obsidian");
var _TableIdManager = class {
  constructor(plugin) {
    this.plugin = plugin;
    console.log("TableIdManager initialized");
  }
  // app
  getApp() {
    return this.plugin.app;
  }
  /**
   * 
   * @param table HTML
   * @param useFallback HTMLIDID
   * @returns IDnull
   */
  getTableIdentifier(table, useFallback = false) {
    try {
      if (_TableIdManager.isProcessingTableId)
        return null;
      _TableIdManager.isProcessingTableId = true;
      console.log("\u5F00\u59CB\u83B7\u53D6\u8868\u683CID");
      const currentDomId = table.getAttribute("data-table-id");
      if (currentDomId) {
        console.log(`\u8868\u683C\u5F53\u524DDOM\u5C5E\u6027ID: ${currentDomId}`);
      }
      const tableFeature = this.extractTableFeature(table);
      if (tableFeature) {
        console.log(`\u63D0\u53D6\u7684\u8868\u683C\u7279\u5F81:`, tableFeature);
      }
      let commentId = this.getTableIdFromComment(table);
      if (commentId) {
        console.log(`\u4ECEHTML\u6CE8\u91CA\u83B7\u53D6\u5230\u8868\u683CID: ${commentId}`);
        if (currentDomId && currentDomId !== commentId) {
          console.log(`\u8B66\u544A: DOM\u4E2D\u7684ID(${currentDomId})\u4E0EHTML\u6CE8\u91CA\u4E2D\u7684ID(${commentId})\u4E0D\u5339\u914D`);
          console.log(`\u6B63\u5728\u66F4\u65B0DOM\u5C5E\u6027\uFF0C\u4F7F\u7528HTML\u6CE8\u91CA\u4E2D\u7684ID: ${commentId}`);
          table.setAttribute("data-table-id", commentId);
        } else if (!currentDomId) {
          console.log(`\u8BBE\u7F6EDOM\u5C5E\u6027ID: ${commentId}`);
          table.setAttribute("data-table-id", commentId);
        }
        if (tableFeature) {
          table.setAttribute("data-table-feature", JSON.stringify(tableFeature));
        }
        _TableIdManager.isProcessingTableId = false;
        return commentId;
      }
      if (useFallback && currentDomId) {
        console.log(`\u672A\u5728HTML\u6CE8\u91CA\u4E2D\u627E\u5230\u8868\u683CID\uFF0C\u56DE\u9000\u4F7F\u7528DOM\u5C5E\u6027ID: ${currentDomId}`);
        if (tableFeature) {
          table.setAttribute("data-table-feature", JSON.stringify(tableFeature));
        }
        _TableIdManager.isProcessingTableId = false;
        return currentDomId;
      }
      console.log("\u672A\u5728HTML\u6CE8\u91CA\u4E2D\u627E\u5230\u8868\u683CID\uFF0C\u4E0D\u4F7F\u7528\u5176\u4ED6ID\u6765\u6E90");
      if (!useFallback && currentDomId) {
        console.log(`\u8B66\u544A: \u8868\u683CDOM\u4E2D\u6709ID(${currentDomId})\uFF0C\u4F46\u672A\u5728HTML\u6CE8\u91CA\u4E2D\u627E\u5230\u5BF9\u5E94ID`);
        console.log("\u6E05\u9664DOM\u4E2D\u7684ID\u5C5E\u6027\uFF0C\u4EE5\u907F\u514D\u4F7F\u7528\u8FC7\u65F6\u6216\u4E0D\u6B63\u786E\u7684ID");
        table.removeAttribute("data-table-id");
      }
      _TableIdManager.isProcessingTableId = false;
      return null;
    } catch (error) {
      console.error("\u83B7\u53D6\u8868\u683CID\u65F6\u51FA\u9519:", error);
      _TableIdManager.isProcessingTableId = false;
      return null;
    }
  }
  /**
   * ID
   * @param table HTML
   * @returns ID
   */
  getOrCreateTableId(table) {
    try {
      if (_TableIdManager.isCreatingTableId)
        return "";
      _TableIdManager.isCreatingTableId = true;
      let tableId = this.getTableIdentifier(table, true);
      if (!tableId) {
        console.log("\u672A\u627E\u5230\u8868\u683CID\uFF0C\u53EF\u4EE5\u4F7F\u7528confirmAndCreateTableId\u65B9\u6CD5\u521B\u5EFA\u65B0ID");
        new import_obsidian4.Notice('\u672A\u627E\u5230\u8868\u683CID\uFF0C\u8BF7\u4F7F\u7528\u8868\u683C\u5DE5\u5177\u680F\u4E2D\u7684"\u8BBE\u7F6E\u8868\u683CID"\u529F\u80FD\u521B\u5EFA\u65B0ID');
      }
      _TableIdManager.isCreatingTableId = false;
      return tableId || "";
    } catch (error) {
      console.error("\u83B7\u53D6\u8868\u683CID\u65F6\u51FA\u9519:", error);
      _TableIdManager.isCreatingTableId = false;
      return "";
    }
  }
  /**
   * ID
   * @param table HTML
   * @returns ID
   */
  confirmAndCreateTableId(table) {
    try {
      const existingId = this.getTableIdentifier(table, true);
      if (existingId) {
        console.log(`\u8868\u683C\u5DF2\u6709ID: ${existingId}\uFF0C\u4E0D\u9700\u8981\u521B\u5EFA\u65B0ID`);
        new import_obsidian4.Notice(`\u8868\u683C\u5DF2\u6709ID: ${existingId}`);
        return existingId;
      }
      const newId = this.generateTableId();
      console.log(`\u4E3A\u8868\u683C\u751F\u6210\u65B0ID: ${newId}`);
      this.addTableIdComment(table, newId);
      return newId;
    } catch (error) {
      console.error("\u786E\u8BA4\u5E76\u521B\u5EFA\u8868\u683CID\u65F6\u51FA\u9519:", error);
      return "";
    }
  }
  /**
   * HTMLID
   * @param table HTML
   * @returns IDnull
   */
  getTableIdFromComment(table) {
    var _a, _b;
    try {
      console.log("\u5F00\u59CB\u4ECEHTML\u6CE8\u91CA\u4E2D\u67E5\u627E\u8868\u683CID");
      console.log("\u8868\u683CDOM:", table.outerHTML.substring(0, 100) + "...");
      try {
        const activeFile = this.getApp().workspace.getActiveFile();
        if (activeFile) {
          console.log(`\u5C1D\u8BD5\u4ECE\u6587\u4EF6\u5185\u5BB9\u4E2D\u67E5\u627E\u8868\u683CID: ${activeFile.path}`);
          const tablePosition = this.getTablePositionInDOM(table);
          if (tablePosition) {
            console.log(`\u8868\u683C\u4F4D\u7F6E: \u7B2C${tablePosition.index}\u4E2A\u8868\u683C`);
            this.getApp().vault.read(activeFile).then((content) => {
              const tableInfos = this.extractTableIdsFromMarkdown(content);
              console.log(`\u4ECEMarkdown\u5185\u5BB9\u4E2D\u63D0\u53D6\u7684\u8868\u683CID:`, tableInfos);
              if (tableInfos.length > tablePosition.index) {
                const { id } = tableInfos[tablePosition.index];
                if (id) {
                  console.log(`\u4ECEMarkdown\u5185\u5BB9\u4E2D\u627E\u5230\u8868\u683CID: ${id}`);
                  table.setAttribute("data-table-id", id);
                  return id;
                }
              }
            }).catch((err) => {
              console.error("\u8BFB\u53D6\u6587\u4EF6\u5185\u5BB9\u65F6\u51FA\u9519:", err);
            });
          }
        }
      } catch (error) {
        console.error("\u4ECE\u6587\u4EF6\u5185\u5BB9\u67E5\u627E\u8868\u683CID\u65F6\u51FA\u9519:", error);
      }
      let node = table.previousSibling;
      let nodeCount = 0;
      console.log("\u5F00\u59CB\u904D\u5386\u524D\u7F6E\u8282\u70B9...");
      while (node && nodeCount < 30) {
        nodeCount++;
        const nodeType = node.nodeType;
        const nodeTypeStr = nodeType === Node.COMMENT_NODE ? "COMMENT" : nodeType === Node.TEXT_NODE ? "TEXT" : nodeType === Node.ELEMENT_NODE ? "ELEMENT" : "OTHER";
        console.log(`\u68C0\u67E5\u8282\u70B9 #${nodeCount}: \u7C7B\u578B=${nodeTypeStr}`);
        if (nodeType === Node.COMMENT_NODE) {
          const commentText = ((_a = node.textContent) == null ? void 0 : _a.trim()) || "";
          console.log(`\u53D1\u73B0\u6CE8\u91CA\u8282\u70B9: "${commentText}"`);
          const beginMatch = commentText.match(/table-begin:\s*([a-zA-Z0-9_\-:.]+)/i);
          if (beginMatch && beginMatch[1]) {
            const commentId = beginMatch[1];
            console.log(`\u4ECE\u8868\u683C\u5F00\u59CB\u6CE8\u91CA\u4E2D\u8BC6\u522B\u8868\u683CID: ${commentId}`);
            return commentId;
          }
          const idMatch = commentText.match(/table[-_]?id:?\s*([a-zA-Z0-9_\-:.]+)/i);
          if (idMatch && idMatch[1]) {
            const commentId = idMatch[1];
            console.log(`\u4ECEHTML\u6CE8\u91CA\u4E2D\u6210\u529F\u8BC6\u522B\u8868\u683CID: ${commentId}`);
            return commentId;
          }
          const altIdMatch = commentText.match(/id:?\s*([a-zA-Z0-9_\-:.]+)/i);
          if (altIdMatch && altIdMatch[1]) {
            const commentId = altIdMatch[1];
            console.log(`\u4ECE\u66FF\u4EE3\u683C\u5F0FHTML\u6CE8\u91CA\u4E2D\u8BC6\u522B\u8868\u683CID: ${commentId}`);
            return commentId;
          }
          const tblMatch = commentText.match(/(tbl|table):?\s*([a-zA-Z0-9_\-:.]+)/i);
          if (tblMatch && tblMatch[2]) {
            const commentId = tblMatch[2];
            console.log(`\u4ECEtbl/table\u683C\u5F0FHTML\u6CE8\u91CA\u4E2D\u8BC6\u522B\u8868\u683CID: ${commentId}`);
            return commentId;
          }
        } else if (nodeType === Node.TEXT_NODE) {
          const textContent = node.textContent || "";
          console.log(`\u6587\u672C\u8282\u70B9\u5185\u5BB9: "${textContent.substring(0, 30)}${textContent.length > 30 ? "..." : ""}"`);
          const htmlCommentMatch = textContent.match(/<!--\s*table[-_]?id:?\s*([a-zA-Z0-9_\-:.]+)\s*-->/i);
          if (htmlCommentMatch && htmlCommentMatch[1]) {
            const commentId = htmlCommentMatch[1];
            console.log(`\u4ECE\u6587\u672C\u8282\u70B9\u4E2D\u7684HTML\u6CE8\u91CA\u8BC6\u522B\u8868\u683CID: ${commentId}`);
            return commentId;
          }
          const altHtmlCommentMatch = textContent.match(/<!--\s*id:?\s*([a-zA-Z0-9_\-:.]+)\s*-->/i);
          if (altHtmlCommentMatch && altHtmlCommentMatch[1]) {
            const commentId = altHtmlCommentMatch[1];
            console.log(`\u4ECE\u6587\u672C\u8282\u70B9\u4E2D\u7684\u66FF\u4EE3HTML\u6CE8\u91CA\u8BC6\u522B\u8868\u683CID: ${commentId}`);
            return commentId;
          }
          const tblHtmlCommentMatch = textContent.match(/<!--\s*(tbl|table):?\s*([a-zA-Z0-9_\-:.]+)\s*-->/i);
          if (tblHtmlCommentMatch && tblHtmlCommentMatch[2]) {
            const commentId = tblHtmlCommentMatch[2];
            console.log(`\u4ECE\u6587\u672C\u8282\u70B9\u4E2D\u7684tbl/table HTML\u6CE8\u91CA\u8BC6\u522B\u8868\u683CID: ${commentId}`);
            return commentId;
          }
          if (textContent.trim() === "") {
            node = node.previousSibling;
            continue;
          }
        } else if (nodeType === Node.ELEMENT_NODE) {
          const tagName = node.tagName;
          console.log(`\u5143\u7D20\u8282\u70B9: <${tagName.toLowerCase()}>`);
          const elemDataId = node.getAttribute("data-id") || node.getAttribute("data-table-id");
          if (elemDataId) {
            console.log(`\u4ECE\u5143\u7D20\u5C5E\u6027\u4E2D\u627E\u5230ID: ${elemDataId}`);
            return elemDataId;
          }
          const elemContent = node.innerHTML || "";
          if (elemContent.includes("<!--") && elemContent.includes("-->")) {
            console.log(`\u5143\u7D20\u5185\u5BB9\u5305\u542BHTML\u6CE8\u91CA: "${elemContent.substring(0, 50)}${elemContent.length > 50 ? "..." : ""}"`);
            const htmlCommentMatch = elemContent.match(/<!--\s*table[-_]?id:?\s*([a-zA-Z0-9_\-:.]+)\s*-->/i);
            if (htmlCommentMatch && htmlCommentMatch[1]) {
              const commentId = htmlCommentMatch[1];
              console.log(`\u4ECE\u5143\u7D20\u5185\u5BB9\u4E2D\u7684HTML\u6CE8\u91CA\u8BC6\u522B\u8868\u683CID: ${commentId}`);
              return commentId;
            }
          }
          if (["BR", "HR", "P", "DIV", "SPAN"].includes(tagName)) {
            node = node.previousSibling;
            continue;
          }
          console.log(`\u9047\u5230\u5143\u7D20\u8282\u70B9 ${tagName}\uFF0C\u505C\u6B62\u67E5\u627E`);
          break;
        }
        node = node.previousSibling;
      }
      if (table.parentElement) {
        console.log("\u5C1D\u8BD5\u68C0\u67E5\u7236\u5143\u7D20\u53CA\u5176\u524D\u7F6E\u8282\u70B9...");
        const parentDataId = table.parentElement.getAttribute("data-id") || table.parentElement.getAttribute("data-table-id");
        if (parentDataId) {
          console.log(`\u4ECE\u7236\u5143\u7D20\u5C5E\u6027\u4E2D\u627E\u5230ID: ${parentDataId}`);
          return parentDataId;
        }
        if (table.parentElement.previousSibling) {
          let parentPrevNode = table.parentElement.previousSibling;
          if (parentPrevNode) {
            if (parentPrevNode.nodeType === Node.COMMENT_NODE) {
              const commentText = ((_b = parentPrevNode.textContent) == null ? void 0 : _b.trim()) || "";
              console.log(`\u53D1\u73B0\u7236\u5143\u7D20\u524D\u7684\u6CE8\u91CA\u8282\u70B9: "${commentText}"`);
              const idMatch = commentText.match(/table[-_]?id:?\s*([a-zA-Z0-9_\-:.]+)/i);
              if (idMatch && idMatch[1]) {
                const commentId = idMatch[1];
                console.log(`\u4ECE\u7236\u5143\u7D20\u524D\u7684HTML\u6CE8\u91CA\u4E2D\u8BC6\u522B\u8868\u683CID: ${commentId}`);
                return commentId;
              }
            } else if (parentPrevNode.nodeType === Node.TEXT_NODE) {
              const textContent = parentPrevNode.textContent || "";
              const htmlCommentMatch = textContent.match(/<!--\s*table[-_]?id:?\s*([a-zA-Z0-9_\-:.]+)\s*-->/i);
              if (htmlCommentMatch && htmlCommentMatch[1]) {
                const commentId = htmlCommentMatch[1];
                console.log(`\u4ECE\u7236\u5143\u7D20\u524D\u7684\u6587\u672C\u8282\u70B9\u4E2D\u8BC6\u522B\u8868\u683CID: ${commentId}`);
                return commentId;
              }
            }
          }
        }
        if (table.parentElement.parentElement) {
          const grandParentDataId = table.parentElement.parentElement.getAttribute("data-id") || table.parentElement.parentElement.getAttribute("data-table-id");
          if (grandParentDataId) {
            console.log(`\u4ECE\u7956\u7236\u5143\u7D20\u5C5E\u6027\u4E2D\u627E\u5230ID: ${grandParentDataId}`);
            return grandParentDataId;
          }
        }
      }
      console.log("\u672A\u5728HTML\u6CE8\u91CA\u4E2D\u627E\u5230\u8868\u683CID");
      return null;
    } catch (error) {
      console.error("\u4ECE\u6CE8\u91CA\u83B7\u53D6\u8868\u683CID\u65F6\u51FA\u9519:", error);
      return null;
    }
  }
  /**
   * ID
   * @param table HTML
   * @param id ID
   */
  addTableIdComment(table, id) {
    var _a, _b, _c, _d, _e, _f;
    try {
      const tableFeature = this.extractTableFeature(table);
      const featureJson = JSON.stringify(tableFeature);
      const useWrapperComments = this.plugin.settings.useTableWrapperComments;
      const previousNode = table.previousSibling;
      if (previousNode && previousNode.nodeType === Node.COMMENT_NODE) {
        const comment = previousNode.nodeValue || "";
        if (comment.includes("table-id:") || comment.includes("table-begin:")) {
          (_a = previousNode.parentNode) == null ? void 0 : _a.removeChild(previousNode);
        }
      }
      const nextNode = table.nextSibling;
      if (nextNode && nextNode.nodeType === Node.COMMENT_NODE) {
        const comment = nextNode.nodeValue || "";
        if (comment.includes("table-end:") || comment.includes("table-id-end:")) {
          (_b = nextNode.parentNode) == null ? void 0 : _b.removeChild(nextNode);
        }
      }
      if (useWrapperComments) {
        const beginCommentContent = `table-begin: ${id} feature: ${featureJson}`;
        const beginComment = document.createComment(` ${beginCommentContent} `);
        const endCommentContent = `table-end: ${id}`;
        const endComment = document.createComment(` ${endCommentContent} `);
        (_c = table.parentNode) == null ? void 0 : _c.insertBefore(beginComment, table);
        if (table.nextSibling) {
          (_d = table.parentNode) == null ? void 0 : _d.insertBefore(endComment, table.nextSibling);
        } else {
          (_e = table.parentNode) == null ? void 0 : _e.appendChild(endComment);
        }
        console.log(`\u5DF2\u4E3A\u8868\u683C\u6DFB\u52A0\u6CE8\u91CA\u5939: ${id} \u7279\u5F81:`, tableFeature);
      } else {
        const commentContent = `table-id: ${id} feature: ${featureJson}`;
        const comment = document.createComment(` ${commentContent} `);
        (_f = table.parentNode) == null ? void 0 : _f.insertBefore(comment, table);
        console.log(`\u5DF2\u4E3A\u8868\u683C\u6DFB\u52A0ID\u6CE8\u91CA: ${id} \u7279\u5F81:`, tableFeature);
      }
      table.setAttribute("data-table-id", id);
      table.setAttribute("data-table-feature", JSON.stringify(tableFeature));
      new import_obsidian4.Notice(`\u5DF2\u4E3A\u8868\u683C\u6DFB\u52A0ID: ${id}`);
    } catch (error) {
      console.error("\u6DFB\u52A0\u8868\u683CID\u6CE8\u91CA\u65F6\u51FA\u9519:", error);
    }
  }
  /**
   * 
   * @param table HTMLMarkdown
   * @returns 
   */
  extractTableFeature(table) {
    try {
      let rows = 0;
      let cols = 0;
      let headers = "";
      let firstRowContent = "";
      let lastRowContent = "";
      let mergePattern = "";
      let position = void 0;
      let fileInfo = void 0;
      const activeFile = this.getApp().workspace.getActiveFile();
      if (activeFile) {
        fileInfo = {
          path: activeFile.path,
          name: activeFile.basename
        };
      }
      if (typeof table === "string") {
        const lines = table.split("\n");
        const tableLines = lines.filter((line) => line.trim().startsWith("|"));
        rows = tableLines.length;
        if (rows > 0) {
          const cells = tableLines[0].split("|").filter((cell) => cell.trim() !== "");
          cols = cells.length;
          headers = cells.map((c) => c.trim()).join("-");
          firstRowContent = tableLines[0];
          lastRowContent = tableLines[rows - 1];
        }
        mergePattern = this.extractMergePattern(tableLines);
        const firstLineIndex = lines.findIndex((line) => line === tableLines[0]);
        if (firstLineIndex >= 0) {
          position = {
            startLine: firstLineIndex,
            endLine: firstLineIndex + rows - 1
          };
        }
      } else {
        const tableRows = table.querySelectorAll("tr");
        rows = tableRows.length;
        if (rows > 0) {
          const firstRowCells = tableRows[0].querySelectorAll("th, td");
          cols = firstRowCells.length;
          headers = Array.from(firstRowCells).map((cell) => {
            var _a;
            return ((_a = cell.textContent) == null ? void 0 : _a.trim()) || "";
          }).join("-");
          firstRowContent = tableRows[0].textContent || "";
          lastRowContent = tableRows[rows - 1].textContent || "";
        }
        mergePattern = this.extractMergePatterFromDOM(table);
        const positionData = table.getAttribute("data-table-position");
        if (positionData) {
          try {
            position = JSON.parse(positionData);
          } catch (e) {
            console.error("\u89E3\u6790\u8868\u683C\u4F4D\u7F6E\u6570\u636E\u65F6\u51FA\u9519:", e);
          }
        }
      }
      return {
        rows,
        cols,
        headers,
        firstRowContent,
        lastRowContent,
        mergePattern,
        position,
        fileInfo
      };
    } catch (error) {
      console.error("\u63D0\u53D6\u8868\u683C\u7279\u5F81\u65F6\u51FA\u9519:", error);
      return {
        rows: 0,
        cols: 0,
        headers: "",
        firstRowContent: "",
        lastRowContent: "",
        mergePattern: ""
      };
    }
  }
  /**
   * Markdown
   */
  extractMergePattern(lines) {
    let pattern = "";
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      const cells = line.split("|").filter((cell) => cell.trim() !== "");
      for (let j = 0; j < cells.length; j++) {
        const cell = cells[j].trim();
        if (cell === "^") {
          pattern += `^${i}-${j};`;
        } else if (cell === "<") {
          pattern += `<${i}-${j};`;
        }
      }
    }
    return pattern;
  }
  /**
   * DOM
   */
  extractMergePatterFromDOM(table) {
    let pattern = "";
    const rows = table.querySelectorAll("tr");
    for (let i = 0; i < rows.length; i++) {
      const cells = rows[i].querySelectorAll("th, td");
      for (let j = 0; j < cells.length; j++) {
        const cell = cells[j];
        const rowspan = cell.getAttribute("rowspan");
        const colspan = cell.getAttribute("colspan");
        if (rowspan && parseInt(rowspan) > 1) {
          pattern += `r${i}-${j}-${rowspan};`;
        }
        if (colspan && parseInt(colspan) > 1) {
          pattern += `c${i}-${j}-${colspan};`;
        }
      }
    }
    return pattern;
  }
  /**
   * 
   * @param feature1 
   * @param feature2 
   * @returns 0-1
   */
  calculateFeatureSimilarity(feature1, feature2) {
    var _a, _b;
    if (!feature1 || !feature2)
      return 0;
    let score = 0;
    let totalWeight = 0;
    const pathWeight = 5;
    if (((_a = feature1.fileInfo) == null ? void 0 : _a.path) && ((_b = feature2.fileInfo) == null ? void 0 : _b.path) && feature1.fileInfo.path === feature2.fileInfo.path) {
      score += pathWeight;
    }
    totalWeight += pathWeight;
    const rowWeight = 3;
    const colWeight = 3;
    if (feature1.rows === feature2.rows) {
      score += rowWeight;
    } else {
      const rowDiff = Math.abs(feature1.rows - feature2.rows);
      if (rowDiff <= 1)
        score += rowWeight * (1 - rowDiff / 2);
    }
    totalWeight += rowWeight;
    if (feature1.cols === feature2.cols) {
      score += colWeight;
    } else {
      const colDiff = Math.abs(feature1.cols - feature2.cols);
      if (colDiff <= 1)
        score += colWeight * (1 - colDiff / 2);
    }
    totalWeight += colWeight;
    const headerWeight = 4;
    if (feature1.headers && feature2.headers) {
      const headerSimilarity = this.calculateTextSimilarity(feature1.headers, feature2.headers);
      score += headerWeight * headerSimilarity;
    }
    totalWeight += headerWeight;
    const positionWeight = 2;
    if (feature1.position && feature2.position) {
      const startLineDiff = Math.abs(feature1.position.startLine - feature2.position.startLine);
      const positionSimilarity = Math.max(0, 1 - startLineDiff / 10);
      score += positionWeight * positionSimilarity;
    }
    totalWeight += positionWeight;
    const firstRowWeight = 2;
    if (feature1.firstRowContent && feature2.firstRowContent) {
      const firstRowSimilarity = this.calculateTextSimilarity(
        feature1.firstRowContent,
        feature2.firstRowContent
      );
      score += firstRowWeight * firstRowSimilarity;
    }
    totalWeight += firstRowWeight;
    const lastRowWeight = 2;
    if (feature1.lastRowContent && feature2.lastRowContent) {
      const lastRowSimilarity = this.calculateTextSimilarity(
        feature1.lastRowContent,
        feature2.lastRowContent
      );
      score += lastRowWeight * lastRowSimilarity;
    }
    totalWeight += lastRowWeight;
    const mergeWeight = 1;
    if (feature1.mergePattern && feature2.mergePattern) {
      const mergeSimilarity = this.calculateTextSimilarity(
        feature1.mergePattern,
        feature2.mergePattern
      );
      score += mergeWeight * mergeSimilarity;
    }
    totalWeight += mergeWeight;
    const similarity = totalWeight > 0 ? score / totalWeight : 0;
    console.log(`\u8868\u683C\u7279\u5F81\u76F8\u4F3C\u5EA6: ${similarity.toFixed(2)}`);
    return similarity;
  }
  /**
   * 
   * @param str1 
   * @param str2 
   * @returns 0-1
   */
  calculateTextSimilarity(str1, str2) {
    if (!str1 || !str2)
      return 0;
    if (str1 === str2)
      return 1;
    const maxLen = Math.max(str1.length, str2.length);
    if (maxLen === 0)
      return 1;
    let matches = 0;
    const minLen = Math.min(str1.length, str2.length);
    for (let i = 0; i < minLen; i++) {
      if (str1[i] === str2[i])
        matches++;
      else
        break;
    }
    for (let i = 1; i <= minLen - matches; i++) {
      if (str1[str1.length - i] === str2[str2.length - i])
        matches++;
      else
        break;
    }
    matches = Math.min(matches, minLen);
    return matches / maxLen;
  }
  /**
   * DOM
   * @param table 
   * @returns null
   */
  getTablePositionInDOM(table) {
    try {
      const allTables = Array.from(document.querySelectorAll("table"));
      const tableId = table.getAttribute("data-table-id");
      if (tableId) {
        for (let i = 0; i < allTables.length; i++) {
          const currentId = allTables[i].getAttribute("data-table-id");
          if (currentId === tableId) {
            console.log(`\u901A\u8FC7ID\u5339\u914D\u627E\u5230\u8868\u683C\u4F4D\u7F6E: \u7B2C${i}\u4E2A\u8868\u683C\uFF08ID: ${tableId}\uFF09`);
            return { index: i, id: tableId };
          }
        }
      }
      const tableFeature = this.extractTableFeature(table);
      if (tableFeature) {
        for (let i = 0; i < allTables.length; i++) {
          const currentFeature = this.extractTableFeature(allTables[i]);
          if (tableFeature.contentHash === currentFeature.contentHash && tableFeature.headers === currentFeature.headers && tableFeature.rows === currentFeature.rows && tableFeature.cols === currentFeature.cols) {
            console.log(`\u901A\u8FC7\u7279\u5F81\u7CBE\u786E\u5339\u914D\u627E\u5230\u8868\u683C\u4F4D\u7F6E: \u7B2C${i}\u4E2A\u8868\u683C`);
            return { index: i };
          }
        }
      }
      let bestMatchIndex = -1;
      let bestMatchScore = 0;
      let bestMatchId = "";
      for (let i = 0; i < allTables.length; i++) {
        const currentTable = allTables[i];
        const currentFeature = this.extractTableFeature(currentTable);
        const currentId = currentTable.getAttribute("data-table-id");
        const similarityScore = this.calculateFeatureSimilarity(tableFeature, currentFeature);
        if (similarityScore > bestMatchScore) {
          bestMatchScore = similarityScore;
          bestMatchIndex = i;
          bestMatchId = currentId || "";
        }
      }
      if (bestMatchIndex !== -1 && bestMatchScore > 0.7) {
        console.log(`\u901A\u8FC7\u7279\u5F81\u76F8\u4F3C\u5EA6\u5339\u914D\u627E\u5230\u8868\u683C\u4F4D\u7F6E: \u7B2C${bestMatchIndex}\u4E2A\u8868\u683C\uFF08\u76F8\u4F3C\u5EA6: ${bestMatchScore.toFixed(2)}\uFF09`);
        return { index: bestMatchIndex, id: bestMatchId };
      }
      const index = allTables.indexOf(table);
      if (index !== -1) {
        console.log(`\u8868\u683C\u5728DOM\u4E2D\u7684\u4F4D\u7F6E: \u7B2C${index}\u4E2A\u8868\u683C\uFF08\u5171${allTables.length}\u4E2A\uFF09`);
        return { index };
      }
      console.warn("\u65E0\u6CD5\u786E\u5B9A\u8868\u683C\u5728DOM\u4E2D\u7684\u4F4D\u7F6E");
      return null;
    } catch (error) {
      console.error("\u83B7\u53D6\u8868\u683C\u4F4D\u7F6E\u65F6\u51FA\u9519:", error);
      return null;
    }
  }
  /**
   * 
   * @param str 
   * @returns 
   */
  simpleHash(str) {
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
      const char = str.charCodeAt(i);
      hash = (hash << 5) - hash + char;
      hash = hash & hash;
    }
    return Math.abs(hash).toString(16).substring(0, 8);
  }
  /**
   * ID
   * @param table 
   * @param autoCreate IDconfirmAndCreateTableId
   * @returns ID
   */
  ensureTableHasId(table, autoCreate = false) {
    if (!table)
      return "";
    const tableId = this.getTableIdentifier(table, true);
    if (tableId) {
      if (!table.getAttribute("data-table-id")) {
        table.setAttribute("data-table-id", tableId);
      }
      return tableId;
    }
    if (autoCreate) {
      console.log("\u672A\u627E\u5230\u8868\u683CID\uFF0C\u81EA\u52A8\u521B\u5EFA\u65B0ID");
      return this.confirmAndCreateTableId(table);
    }
    console.log("\u672A\u627E\u5230\u8868\u683CID\uFF0C\u4E0D\u81EA\u52A8\u521B\u5EFAID");
    return "";
  }
  /**
   * ID
   * @returns ID
   */
  generateTableId() {
    try {
      const prefix = this.plugin.settings.idPrefix || "tbl";
      const date = new Date();
      const year = date.getFullYear();
      const month = String(date.getMonth() + 1).padStart(2, "0");
      const day = String(date.getDate()).padStart(2, "0");
      const activeFile = this.getApp().workspace.getActiveFile();
      let fileCode = "doc";
      if (activeFile) {
        const fileName = activeFile.basename;
        if (fileName && fileName.length >= 2) {
          fileCode = fileName.substring(0, 2).toLowerCase();
        }
      }
      const randomChars = "abcdefghijklmnopqrstuvwxyz";
      let randomStr = "";
      for (let i = 0; i < 6; i++) {
        randomStr += randomChars.charAt(Math.floor(Math.random() * randomChars.length));
      }
      const tableId = `${prefix}-${year}${month}${day}-${fileCode}${randomStr}`;
      console.log(`\u751F\u6210\u8868\u683CID: ${tableId}`);
      return tableId;
    } catch (error) {
      console.error("\u751F\u6210\u8868\u683CID\u65F6\u51FA\u9519:", error);
      const timestamp = new Date().getTime();
      const random = Math.floor(Math.random() * 1e4);
      return `${this.plugin.settings.idPrefix || "tbl"}-${timestamp}-${random}`;
    }
  }
  /**
   * MarkdownID
   * @param content Markdown
   * @returns ID
   */
  extractTableIdsFromMarkdown(content) {
    try {
      const result = [];
      const lines = content.split("\n");
      for (let i = 0; i < lines.length; i++) {
        const line = lines[i];
        let tableId = "";
        let tableFeature = {};
        const beginMatch = line.match(/<!--\s*table-begin:\s*([a-zA-Z0-9_\-:.]+)\s*(?:feature:\s*(\{.*\}))?\s*-->/);
        if (beginMatch) {
          tableId = beginMatch[1];
          if (beginMatch[2]) {
            try {
              tableFeature = JSON.parse(beginMatch[2]);
            } catch (e) {
              console.error("\u89E3\u6790\u8868\u683C\u7279\u5F81JSON\u65F6\u51FA\u9519:", e);
            }
          }
          let tableContent = "";
          let tableStartLine = -1;
          let tableEndLine = -1;
          for (let j = i + 1; j < lines.length; j++) {
            if (lines[j].trim().startsWith("|")) {
              tableStartLine = j;
              break;
            }
          }
          if (tableStartLine >= 0) {
            for (let j = tableStartLine; j < lines.length; j++) {
              if (!lines[j].trim().startsWith("|")) {
                tableEndLine = j - 1;
                break;
              }
              if (j === lines.length - 1) {
                tableEndLine = j;
              }
            }
            if (tableEndLine >= tableStartLine) {
              tableContent = lines.slice(tableStartLine, tableEndLine + 1).join("\n");
              const feature = this.extractTableFeature(tableContent);
              feature.position = {
                startLine: tableStartLine,
                endLine: tableEndLine
              };
              const activeFile = this.getApp().workspace.getActiveFile();
              if (activeFile) {
                feature.fileInfo = {
                  path: activeFile.path,
                  name: activeFile.basename
                };
              }
              const mergedFeature = { ...feature, ...tableFeature, id: tableId };
              result.push({
                id: tableId,
                feature: mergedFeature
              });
            }
          }
          continue;
        }
        const idMatch = line.match(/<!--\s*table-id:\s*([a-zA-Z0-9_\-:.]+)\s*(?:feature:\s*(\{.*\}))?\s*-->/);
        if (idMatch) {
          tableId = idMatch[1];
          if (idMatch[2]) {
            try {
              tableFeature = JSON.parse(idMatch[2]);
            } catch (e) {
              console.error("\u89E3\u6790\u8868\u683C\u7279\u5F81JSON\u65F6\u51FA\u9519:", e);
            }
          }
          let tableContent = "";
          let tableStartLine = -1;
          let tableEndLine = -1;
          for (let j = i + 1; j < lines.length; j++) {
            if (lines[j].trim().startsWith("|")) {
              tableStartLine = j;
              break;
            }
          }
          if (tableStartLine >= 0) {
            for (let j = tableStartLine; j < lines.length; j++) {
              if (!lines[j].trim().startsWith("|")) {
                tableEndLine = j - 1;
                break;
              }
              if (j === lines.length - 1) {
                tableEndLine = j;
              }
            }
            if (tableEndLine >= tableStartLine) {
              tableContent = lines.slice(tableStartLine, tableEndLine + 1).join("\n");
              const feature = this.extractTableFeature(tableContent);
              feature.position = {
                startLine: tableStartLine,
                endLine: tableEndLine
              };
              const activeFile = this.plugin.app.workspace.getActiveFile();
              if (activeFile) {
                feature.fileInfo = {
                  path: activeFile.path,
                  name: activeFile.basename
                };
              }
              const mergedFeature = { ...feature, ...tableFeature, id: tableId };
              result.push({
                id: tableId,
                feature: mergedFeature
              });
            }
          }
        }
      }
      return result;
    } catch (error) {
      console.error("\u4ECEMarkdown\u5185\u5BB9\u63D0\u53D6\u8868\u683CID\u65F6\u51FA\u9519:", error);
      return [];
    }
  }
};
var TableIdManager = _TableIdManager;
TableIdManager.isProcessingTableId = false;
TableIdManager.isCreatingTableId = false;

// src/tableToolbar.ts
var import_obsidian5 = require("obsidian");
var import_obsidian6 = require("obsidian");
var TableToolbar = class {
  constructor(plugin) {
    this.activeTable = null;
    this.selectedCells = [];
    this.isDragging = false;
    this.dragStartX = 0;
    this.dragStartY = 0;
    this.isCollapsed = false;
    this.initialPosition = { left: "50%", top: "10px" };
    this.editModeTableInfo = null;
    this.applyToEntireTable = false;
    // 
    this.savingInProgress = false;
    this.maxRetries = 3;
    this.plugin = plugin;
    console.log("TableToolbar initialized");
  }
  // app
  getApp() {
    return this.plugin.app;
  }
  /**
   * 
   * @param containerEl 
   */
  createToolbar(containerEl) {
    var _a, _b, _c;
    this.containerEl = containerEl;
    containerEl.style.position = "fixed";
    containerEl.style.zIndex = "1000";
    containerEl.style.left = "50%";
    containerEl.style.top = "10px";
    containerEl.style.transform = "translateX(-50%)";
    containerEl.style.display = "block";
    this.toolbar = containerEl.createEl("div", {
      cls: "advanced-table-toolbar"
    });
    this.toolbar.style.display = "flex";
    this.toolbar.style.flexDirection = "row";
    this.toolbar.style.gap = "5px";
    this.toolbar.style.padding = "5px";
    this.toolbar.style.margin = "5px 0";
    this.toolbar.style.borderRadius = "5px";
    this.toolbar.style.backgroundColor = "var(--background-secondary)";
    this.toolbar.style.boxShadow = "0 2px 8px rgba(0, 0, 0, 0.15)";
    this.toolbar.style.userSelect = "none";
    this.toolbar.style.position = "relative";
    this.dragHandle = this.toolbar.createEl("div", {
      cls: "advanced-table-toolbar-drag-handle"
    });
    this.dragHandle.style.cursor = "grab";
    this.dragHandle.style.padding = "0 5px";
    this.dragHandle.style.display = "flex";
    this.dragHandle.style.alignItems = "center";
    this.dragHandle.style.marginRight = "5px";
    this.dragHandle.style.height = "28px";
    this.dragHandle.style.borderRadius = "3px";
    this.dragHandle.addEventListener("mouseover", () => {
      this.dragHandle.style.backgroundColor = "var(--background-modifier-hover)";
    });
    this.dragHandle.addEventListener("mouseout", () => {
      this.dragHandle.style.backgroundColor = "transparent";
    });
    (0, import_obsidian5.setIcon)(this.dragHandle, "grip-vertical");
    this.toolbarContent = this.toolbar.createEl("div", {
      cls: "advanced-table-toolbar-content"
    });
    this.toolbarContent.style.display = "flex";
    this.toolbarContent.style.flexDirection = "row";
    this.toolbarContent.style.gap = "5px";
    this.toolbarContent.style.flexGrow = "1";
    this.createButtonGroup("\u5BF9\u9F50", [
      { id: "align-left", tooltip: "\u5DE6\u5BF9\u9F50", icon: "align-left" },
      { id: "align-center", tooltip: "\u5C45\u4E2D\u5BF9\u9F50", icon: "align-center" },
      { id: "align-right", tooltip: "\u53F3\u5BF9\u9F50", icon: "align-right" },
      { id: "align-top", tooltip: "\u9876\u90E8\u5BF9\u9F50", icon: "align-top" },
      { id: "align-middle", tooltip: "\u5782\u76F4\u5C45\u4E2D", icon: "align-middle" },
      { id: "align-bottom", tooltip: "\u5E95\u90E8\u5BF9\u9F50", icon: "align-bottom" },
      { id: "align-all", tooltip: "\u5168\u90E8\u5C45\u4E2D", icon: "align-all" }
    ]);
    this.createSeparator();
    this.createButtonGroup("\u5408\u5E76", [
      { id: "merge-cells", tooltip: "\u5408\u5E76\u9009\u4E2D\u5355\u5143\u683C", icon: "merge-cells" },
      { id: "merge-right", tooltip: "\u5411\u53F3\u5408\u5E76", icon: "merge-right" },
      { id: "merge-down", tooltip: "\u5411\u4E0B\u5408\u5E76", icon: "merge-down" },
      { id: "split", tooltip: "\u62C6\u5206\u5355\u5143\u683C", icon: "split" }
    ]);
    this.createSeparator();
    this.createButtonGroup("\u8868\u683C", [
      { id: "table-id", tooltip: "\u751F\u6210\u8868\u683CID", icon: "table-id" },
      { id: "table-row-add", tooltip: "\u6DFB\u52A0\u884C", icon: "table-row-add" },
      { id: "table-style", tooltip: "\u8868\u683C\u6837\u5F0F", icon: "table-style" }
    ]);
    this.collapseButton = this.toolbar.createEl("button", {
      cls: "advanced-table-toolbar-collapse-button",
      attr: { "aria-label": "\u6536\u8D77/\u5C55\u5F00\u5DE5\u5177\u680F", "title": "\u6536\u8D77\u5DE5\u5177\u680F" }
    });
    this.collapseButton.style.display = "flex";
    this.collapseButton.style.justifyContent = "center";
    this.collapseButton.style.alignItems = "center";
    this.collapseButton.style.width = "28px";
    this.collapseButton.style.height = "28px";
    this.collapseButton.style.padding = "3px";
    this.collapseButton.style.border = "none";
    this.collapseButton.style.borderRadius = "3px";
    this.collapseButton.style.backgroundColor = "transparent";
    this.collapseButton.style.cursor = "pointer";
    this.collapseButton.style.marginLeft = "5px";
    (0, import_obsidian5.setIcon)(this.collapseButton, "chevron-left");
    this.collapseButton.addEventListener("mouseover", () => {
      this.collapseButton.style.backgroundColor = "var(--background-modifier-hover)";
    });
    this.collapseButton.addEventListener("mouseout", () => {
      this.collapseButton.style.backgroundColor = "transparent";
    });
    this.collapseButton.addEventListener("click", () => {
      this.toggleCollapse();
    });
    this.setupDraggable();
    console.log("\u5DE5\u5177\u680F\u5DF2\u521B\u5EFA\uFF0C\u62D6\u62FD\u624B\u67C4\u72B6\u6001:", {
      dragHandleExists: !!this.dragHandle,
      dragHandleParent: (_a = this.dragHandle) == null ? void 0 : _a.parentElement,
      dragHandleDisplay: (_b = this.dragHandle) == null ? void 0 : _b.style.display,
      dragHandleIcon: (_c = this.dragHandle) == null ? void 0 : _c.innerHTML,
      toolbarChildren: Array.from(this.toolbar.children).map((child) => child.className)
    });
  }
  /**
   * 
   */
  setupDraggable() {
    const container = this.containerEl;
    this.dragHandle.addEventListener("mousedown", (e) => {
      if (e.button !== 0)
        return;
      this.isDragging = true;
      this.dragStartX = e.clientX;
      this.dragStartY = e.clientY;
      const rect = container.getBoundingClientRect();
      this.initialPosition = {
        left: container.style.left || "50%",
        top: container.style.top || "10px"
      };
      this.dragHandle.style.cursor = "grabbing";
      document.body.style.cursor = "grabbing";
      e.preventDefault();
      e.stopPropagation();
    });
    const mouseMoveHandler = (e) => {
      if (!this.isDragging)
        return;
      const deltaX = e.clientX - this.dragStartX;
      const deltaY = e.clientY - this.dragStartY;
      const rect = container.getBoundingClientRect();
      let newLeft;
      if (this.initialPosition.left.endsWith("%")) {
        const viewportWidth = document.documentElement.clientWidth;
        const initialLeftPx = parseFloat(this.initialPosition.left) / 100 * viewportWidth;
        newLeft = `${initialLeftPx + deltaX}px`;
      } else {
        const initialLeftPx = parseFloat(this.initialPosition.left);
        newLeft = `${initialLeftPx + deltaX}px`;
      }
      const newTop = `${parseFloat(this.initialPosition.top) + deltaY}px`;
      container.style.left = newLeft;
      container.style.top = newTop;
      container.style.transform = "none";
      e.preventDefault();
      e.stopPropagation();
    };
    const mouseUpHandler = (e) => {
      if (!this.isDragging)
        return;
      this.isDragging = false;
      this.dragHandle.style.cursor = "grab";
      document.body.style.cursor = "";
      e.stopPropagation();
    };
    document.addEventListener("mousemove", mouseMoveHandler);
    document.addEventListener("mouseup", mouseUpHandler);
    this.plugin.registerDomEvent(document, "mousemove", mouseMoveHandler);
    this.plugin.registerDomEvent(document, "mouseup", mouseUpHandler);
  }
  /**
   * /
   */
  toggleCollapse() {
    this.isCollapsed = !this.isCollapsed;
    if (this.isCollapsed) {
      this.toolbarContent.style.display = "none";
      (0, import_obsidian5.setIcon)(this.collapseButton, "chevron-right");
      this.toolbar.style.width = "auto";
      this.toolbar.classList.add("collapsed");
      this.containerEl.style.width = "auto";
      this.containerEl.style.height = "auto";
      this.collapseButton.setAttribute("title", "\u5C55\u5F00\u5DE5\u5177\u680F");
    } else {
      this.toolbarContent.style.display = "flex";
      (0, import_obsidian5.setIcon)(this.collapseButton, "chevron-left");
      this.toolbar.style.width = "";
      this.toolbar.classList.remove("collapsed");
      this.containerEl.style.width = "";
      this.containerEl.style.height = "";
      this.collapseButton.setAttribute("title", "\u6536\u8D77\u5DE5\u5177\u680F");
    }
  }
  /**
   * 
   * @param groupName 
   * @param buttons 
   */
  createButtonGroup(groupName, buttons) {
    const group = this.toolbarContent.createEl("div", {
      cls: "advanced-table-toolbar-group"
    });
    group.style.display = "flex";
    group.style.flexDirection = "row";
    group.style.alignItems = "center";
    const label = group.createEl("span", {
      text: groupName,
      cls: "advanced-table-toolbar-group-label"
    });
    label.style.fontSize = "12px";
    label.style.marginRight = "5px";
    label.style.opacity = "0.7";
    buttons.forEach((btn) => {
      const button = group.createEl("button", {
        cls: `advanced-table-toolbar-button ${btn.id}`,
        attr: { "aria-label": btn.tooltip }
      });
      button.style.display = "flex";
      button.style.justifyContent = "center";
      button.style.alignItems = "center";
      button.style.width = "28px";
      button.style.height = "28px";
      button.style.padding = "3px";
      button.style.border = "none";
      button.style.borderRadius = "3px";
      button.style.backgroundColor = "transparent";
      button.style.cursor = "pointer";
      (0, import_obsidian5.setIcon)(button, btn.icon);
      button.addEventListener("mouseover", () => {
        button.style.backgroundColor = "var(--background-modifier-hover)";
      });
      button.addEventListener("mouseout", () => {
        button.style.backgroundColor = "transparent";
      });
      button.addEventListener("click", () => {
        this.handleButtonClick(btn.id);
      });
      button.setAttribute("title", btn.tooltip);
    });
  }
  /**
   * 
   */
  createSeparator() {
    const separator = this.toolbarContent.createEl("div", {
      cls: "advanced-table-toolbar-separator"
    });
    separator.style.width = "1px";
    separator.style.height = "24px";
    separator.style.margin = "0 5px";
    separator.style.backgroundColor = "var(--background-modifier-border)";
  }
  /**
   * 
   * @param buttonId ID
   */
  handleButtonClick(buttonId) {
    try {
      console.log(`\u70B9\u51FB\u4E86\u6309\u94AE: ${buttonId}`);
      const isEditMode = this.isInEditMode();
      switch (buttonId) {
        case "align-left":
          this.applyAlignmentToSelectedCells("left");
          break;
        case "align-center":
          this.applyAlignmentToSelectedCells("center");
          break;
        case "align-right":
          this.applyAlignmentToSelectedCells("right");
          break;
        case "align-top":
          this.applyAlignmentToSelectedCells(void 0, "top");
          break;
        case "align-middle":
          this.applyAlignmentToSelectedCells(void 0, "middle");
          break;
        case "align-bottom":
          this.applyAlignmentToSelectedCells(void 0, "bottom");
          break;
        case "align-all":
          this.applyAlignmentToSelectedCells("center", "middle");
          break;
        case "merge-cells":
          if (isEditMode && this.plugin.settings.enableEditModeOperations) {
            new import_obsidian5.Notice("\u7F16\u8F91\u6A21\u5F0F\u4E0B\u6682\u4E0D\u652F\u6301\u591A\u9009\u5408\u5E76\uFF0C\u8BF7\u4F7F\u7528\u5411\u53F3\u6216\u5411\u4E0B\u5408\u5E76");
          } else {
            this.mergeCells();
          }
          break;
        case "merge-right":
          this.mergeRight();
          break;
        case "merge-down":
          this.mergeDown();
          break;
        case "split":
          if (isEditMode && this.plugin.settings.enableEditModeOperations) {
            this.plugin.markdownSourceEditor.splitMergedCells().then((success) => {
              if (success) {
                this.clearCellSelection();
              }
            }).catch((error) => {
              console.error("\u62C6\u5206\u5355\u5143\u683C\u65F6\u51FA\u9519:", error);
              new import_obsidian5.Notice(`\u62C6\u5206\u5355\u5143\u683C\u65F6\u51FA\u9519: ${error.message || "\u672A\u77E5\u9519\u8BEF"}`);
            });
          } else {
            this.splitCell();
          }
          break;
        case "table-id":
          this.generateTableId();
          break;
        case "table-row-add":
          if (isEditMode && this.plugin.settings.enableEditModeOperations) {
            new import_obsidian5.Notice("\u7F16\u8F91\u6A21\u5F0F\u4E0B\u6682\u4E0D\u652F\u6301\u901A\u8FC7\u5DE5\u5177\u680F\u6DFB\u52A0\u884C\uFF0C\u8BF7\u76F4\u63A5\u7F16\u8F91Markdown\u6E90\u7801");
          } else {
            this.showRowAddMenu();
          }
          break;
        case "table-style":
          if (isEditMode && this.plugin.settings.enableEditModeOperations) {
            new import_obsidian5.Notice("\u7F16\u8F91\u6A21\u5F0F\u4E0B\u6682\u4E0D\u652F\u6301\u6837\u5F0F\u8BBE\u7F6E");
          } else {
            this.showStyleMenu();
          }
          break;
        default:
          console.log(`\u672A\u5904\u7406\u7684\u6309\u94AEID: ${buttonId}`);
      }
    } catch (error) {
      console.error(`\u5904\u7406\u6309\u94AE\u70B9\u51FB\u65F6\u51FA\u9519: ${buttonId}`, error);
    }
  }
  /**
   * 
   */
  logDebugInfo() {
    const allTables = document.querySelectorAll("table").length;
    const selectedTableElements = document.querySelectorAll('table[data-table-selected="true"]').length;
    console.log("\u5F53\u524D\u72B6\u6001:", {
      activeTable: this.activeTable,
      allTables,
      selectedCells: this.selectedCells,
      selectedTableElements,
      toolbarContainer: this.containerEl
    });
  }
  /**
   * 
   * @param horizontalAlign 
   * @param verticalAlign 
   */
  applyAlignmentToSelectedCells(horizontalAlign, verticalAlign) {
    try {
      console.log("\u5E94\u7528\u5BF9\u9F50:", { horizontalAlign, verticalAlign });
      if (this.savingInProgress) {
        new import_obsidian5.Notice("\u6B63\u5728\u4FDD\u5B58\u4E0A\u4E00\u6B21\u7684\u6837\u5F0F\u66F4\u6539\uFF0C\u8BF7\u7A0D\u5019\u518D\u8BD5");
        return;
      }
      this.savingInProgress = true;
      this.applyAlignmentStylesOnly(horizontalAlign, verticalAlign);
      if (!this.activeTable || this.selectedCells.length === 0 && !this.applyToEntireTable) {
        console.warn("\u6CA1\u6709\u9009\u4E2D\u5355\u5143\u683C\u6216\u6D3B\u52A8\u8868\u683C");
        this.savingInProgress = false;
        return;
      }
      this.showSavingStatus();
      this.plugin.readTableIdFromMarkdown(this.activeTable).then((tableId) => {
        console.log(`\u4ECEMarkdown\u6587\u4EF6\u4E2D\u83B7\u53D6\u8868\u683CID: ${tableId}`);
        if (!tableId) {
          console.warn("\u672A\u627E\u5230HTML\u6CE8\u91CA\u4E2D\u5B9A\u4E49\u7684\u8868\u683CID\uFF0C\u5C06\u53EA\u5E94\u7528\u6837\u5F0F\u4F46\u4E0D\u4FDD\u5B58\u6570\u636E");
          new import_obsidian5.Notice("\u672A\u627E\u5230\u8868\u683CID\uFF0C\u6837\u5F0F\u5DF2\u5E94\u7528\u4F46\u672A\u4FDD\u5B58\u5230\u6570\u636E\u6587\u4EF6");
          this.hideSavingStatus();
          this.savingInProgress = false;
          return;
        }
        if (this.activeTable) {
          const activeTable = this.activeTable;
          const activeFile = this.getApp().workspace.getActiveFile();
          if (!activeFile) {
            console.warn("\u65E0\u6CD5\u83B7\u53D6\u5F53\u524D\u6587\u4EF6\u8DEF\u5F84");
            this.hideSavingStatus();
            this.savingInProgress = false;
            return;
          }
          const selectedCellPositions = this.getSelectedCellPositions();
          console.log("\u9009\u4E2D\u5355\u5143\u683C\u4F4D\u7F6E:", selectedCellPositions);
          this.plugin.loadData().then((existingData) => {
            var _a;
            if (!existingData.tables) {
              existingData.tables = {};
            }
            let tableData = existingData.tables[tableId];
            if (!tableData) {
              console.log(`\u521B\u5EFA\u65B0\u7684\u8868\u683C\u6570\u636E: ${tableId}`);
              const rows = activeTable.querySelectorAll("tr");
              const rowCount = rows.length;
              let colCount = 0;
              if (rowCount > 0) {
                const firstRow = rows[0];
                colCount = firstRow.querySelectorAll("td, th").length;
              }
              tableData = {
                id: tableId,
                locations: [
                  {
                    path: activeFile.path,
                    isActive: true
                  }
                ],
                structure: {
                  rowCount,
                  colCount,
                  hasHeaders: rows.length > 0 && rows[0].querySelectorAll("th").length > 0
                },
                styling: {
                  rowHeights: Array(rowCount).fill("auto"),
                  colWidths: Array(colCount).fill("auto"),
                  alignment: Array(colCount).fill("left"),
                  cellStyles: []
                  // 
                }
              };
              existingData.tables[tableId] = tableData;
              console.log(`\u5DF2\u521B\u5EFA\u65B0\u7684\u8868\u683C\u6570\u636E\u8BB0\u5F55: ${tableId}`, tableData);
            } else {
              console.log(`\u627E\u5230\u73B0\u6709\u8868\u683C\u6570\u636E: ${tableId}`, tableData);
              if (!tableData.structure) {
                const rows = activeTable.querySelectorAll("tr");
                const rowCount = rows.length;
                let colCount = 0;
                if (rowCount > 0) {
                  const firstRow = rows[0];
                  colCount = firstRow.querySelectorAll("td, th").length;
                }
                tableData.structure = {
                  rowCount,
                  colCount,
                  hasHeaders: rows.length > 0 && rows[0].querySelectorAll("th").length > 0
                };
              }
              if (!tableData.styling) {
                tableData.styling = {
                  rowHeights: Array(tableData.structure.rowCount).fill("auto"),
                  colWidths: Array(tableData.structure.colCount).fill("auto"),
                  alignment: Array(tableData.structure.colCount).fill("left"),
                  cellStyles: []
                  // 
                };
              }
              if (!tableData.styling.cellStyles) {
                tableData.styling.cellStyles = [];
              }
              if (!tableData.locations) {
                tableData.locations = [{
                  path: activeFile.path,
                  isActive: true
                }];
              } else {
                const filePathExists = tableData.locations.some((loc) => loc.path === activeFile.path);
                if (!filePathExists) {
                  tableData.locations.push({
                    path: activeFile.path,
                    isActive: true
                  });
                }
              }
            }
            if (this.selectedCells.length === 0 || this.applyToEntireTable) {
              if (horizontalAlign) {
                tableData.styling = tableData.styling || {};
                tableData.styling.alignment = tableData.styling.alignment || [];
                const colCount = ((_a = tableData.structure) == null ? void 0 : _a.colCount) || 0;
                for (let i = 0; i < colCount; i++) {
                  tableData.styling.alignment[i] = horizontalAlign;
                }
                console.log(`\u66F4\u65B0\u8868\u683C\u5BF9\u9F50\u6570\u636E: ${tableId}`, tableData.styling.alignment);
              }
            } else {
              selectedCellPositions.forEach((pos) => {
                const existingStyleIndex = tableData.styling.cellStyles.findIndex(
                  (style) => style.row === pos.row && style.col === pos.col
                );
                if (existingStyleIndex !== -1) {
                  if (horizontalAlign) {
                    tableData.styling.cellStyles[existingStyleIndex].textAlign = horizontalAlign;
                  }
                  if (verticalAlign) {
                    tableData.styling.cellStyles[existingStyleIndex].verticalAlign = verticalAlign;
                  }
                } else {
                  const newStyle = { row: pos.row, col: pos.col };
                  if (horizontalAlign) {
                    newStyle.textAlign = horizontalAlign;
                  }
                  if (verticalAlign) {
                    newStyle.verticalAlign = verticalAlign;
                  }
                  tableData.styling.cellStyles.push(newStyle);
                }
              });
              console.log(`\u66F4\u65B0\u5355\u5143\u683C\u6837\u5F0F\u6570\u636E: ${tableId}`, tableData.styling.cellStyles);
            }
            this.saveWithRetry(existingData, tableId, horizontalAlign, verticalAlign, 0);
          }).catch((err) => {
            console.error("\u4FDD\u5B58\u8868\u683C\u6570\u636E\u65F6\u51FA\u9519:", err);
            new import_obsidian5.Notice(`\u4FDD\u5B58\u8868\u683C\u6570\u636E\u5931\u8D25: ${err.message || "\u672A\u77E5\u9519\u8BEF"}`);
            this.hideSavingStatus();
            this.savingInProgress = false;
          });
        } else {
          console.warn("\u4FDD\u5B58\u6570\u636E\u65F6\u8868\u683C\u4E0D\u518D\u5B58\u5728");
          this.hideSavingStatus();
          this.savingInProgress = false;
        }
      }).catch((error) => {
        console.error("\u83B7\u53D6\u8868\u683CID\u65F6\u51FA\u9519:", error);
        new import_obsidian5.Notice(`\u83B7\u53D6\u8868\u683CID\u5931\u8D25: ${error.message || "\u672A\u77E5\u9519\u8BEF"}`);
        this.hideSavingStatus();
        this.savingInProgress = false;
      });
      console.log("\u5BF9\u9F50\u5E94\u7528\u5B8C\u6210");
    } catch (error) {
      console.error("\u5E94\u7528\u5BF9\u9F50\u5931\u8D25:", error);
      new import_obsidian5.Notice(`\u5E94\u7528\u5BF9\u9F50\u5931\u8D25: ${error.message || "\u672A\u77E5\u9519\u8BEF"}`);
      this.hideSavingStatus();
      this.savingInProgress = false;
    }
  }
  /**
   * 
   * @param existingData 
   * @param tableId ID
   * @param horizontalAlign 
   * @param verticalAlign 
   * @param retryCount 
   */
  saveWithRetry(existingData, tableId, horizontalAlign, verticalAlign, retryCount = 0) {
    try {
      this.plugin.saveData(existingData).then(() => {
        console.log(`\u5DF2\u4FDD\u5B58\u8868\u683C\u6570\u636E: ${tableId}`);
        setTimeout(() => {
          this.verifyStylesSaved(tableId, horizontalAlign, verticalAlign).then((verified) => {
            if (verified) {
              new import_obsidian5.Notice(`\u5DF2\u5C06${horizontalAlign || ""}${horizontalAlign && verticalAlign ? "\u548C" : ""}${verticalAlign || ""}\u5BF9\u9F50\u5E94\u7528\u5230${this.selectedCells.length > 0 ? "\u9009\u4E2D\u5355\u5143\u683C" : "\u6574\u4E2A\u8868\u683C"}\u5E76\u4FDD\u5B58\u5230\u6570\u636E\u6587\u4EF6`);
            } else {
              if (retryCount < this.maxRetries) {
                console.warn(`\u4FDD\u5B58\u9A8C\u8BC1\u5931\u8D25\uFF0C\u6B63\u5728\u91CD\u8BD5 (${retryCount + 1}/${this.maxRetries})...`);
                this.saveWithRetry(existingData, tableId, horizontalAlign, verticalAlign, retryCount + 1);
                return;
              } else {
                console.error(`\u4FDD\u5B58\u9A8C\u8BC1\u5931\u8D25\uFF0C\u5DF2\u8FBE\u5230\u6700\u5927\u91CD\u8BD5\u6B21\u6570 (${this.maxRetries})`);
                new import_obsidian5.Notice(`\u6837\u5F0F\u53EF\u80FD\u672A\u6210\u529F\u4FDD\u5B58\uFF0C\u8BF7\u518D\u6B21\u5C1D\u8BD5\u5E94\u7528\u6837\u5F0F`);
              }
            }
            this.hideSavingStatus();
            this.savingInProgress = false;
          }).catch((error) => {
            console.error("\u9A8C\u8BC1\u4FDD\u5B58\u65F6\u51FA\u9519:", error);
            if (retryCount < this.maxRetries) {
              console.warn(`\u9A8C\u8BC1\u51FA\u9519\uFF0C\u6B63\u5728\u91CD\u8BD5 (${retryCount + 1}/${this.maxRetries})...`);
              this.saveWithRetry(existingData, tableId, horizontalAlign, verticalAlign, retryCount + 1);
              return;
            } else {
              console.error(`\u9A8C\u8BC1\u51FA\u9519\uFF0C\u5DF2\u8FBE\u5230\u6700\u5927\u91CD\u8BD5\u6B21\u6570 (${this.maxRetries})`);
              new import_obsidian5.Notice(`\u6837\u5F0F\u53EF\u80FD\u672A\u6210\u529F\u4FDD\u5B58\uFF0C\u8BF7\u518D\u6B21\u5C1D\u8BD5\u5E94\u7528\u6837\u5F0F`);
              this.hideSavingStatus();
              this.savingInProgress = false;
            }
          });
        }, 300);
      }).catch((error) => {
        console.error("\u4FDD\u5B58\u6570\u636E\u65F6\u51FA\u9519:", error);
        if (retryCount < this.maxRetries) {
          console.warn(`\u4FDD\u5B58\u51FA\u9519\uFF0C\u6B63\u5728\u91CD\u8BD5 (${retryCount + 1}/${this.maxRetries})...`);
          this.saveWithRetry(existingData, tableId, horizontalAlign, verticalAlign, retryCount + 1);
        } else {
          console.error(`\u4FDD\u5B58\u51FA\u9519\uFF0C\u5DF2\u8FBE\u5230\u6700\u5927\u91CD\u8BD5\u6B21\u6570 (${this.maxRetries})`);
          new import_obsidian5.Notice(`\u4FDD\u5B58\u8868\u683C\u6570\u636E\u5931\u8D25: ${error.message || "\u672A\u77E5\u9519\u8BEF"}`);
          this.hideSavingStatus();
          this.savingInProgress = false;
        }
      });
    } catch (error) {
      console.error("\u4FDD\u5B58\u91CD\u8BD5\u65F6\u51FA\u9519:", error);
      if (retryCount < this.maxRetries) {
        console.warn(`\u51FA\u9519\uFF0C\u6B63\u5728\u91CD\u8BD5 (${retryCount + 1}/${this.maxRetries})...`);
        setTimeout(() => {
          this.saveWithRetry(existingData, tableId, horizontalAlign, verticalAlign, retryCount + 1);
        }, 500);
      } else {
        console.error(`\u51FA\u9519\uFF0C\u5DF2\u8FBE\u5230\u6700\u5927\u91CD\u8BD5\u6B21\u6570 (${this.maxRetries})`);
        new import_obsidian5.Notice(`\u4FDD\u5B58\u8868\u683C\u6570\u636E\u5931\u8D25: ${error.message || "\u672A\u77E5\u9519\u8BEF"}`);
        this.hideSavingStatus();
        this.savingInProgress = false;
      }
    }
  }
  /**
   * 
   * @param tableId ID
   * @param horizontalAlign 
   * @param verticalAlign 
   * @returns 
   */
  async verifyStylesSaved(tableId, horizontalAlign, verticalAlign) {
    var _a;
    try {
      const latestData = await this.plugin.loadData();
      if (!latestData || !latestData.tables || !latestData.tables[tableId]) {
        console.warn(`\u9A8C\u8BC1\u5931\u8D25\uFF1A\u672A\u627E\u5230\u8868\u683C\u6570\u636E ${tableId}`);
        return false;
      }
      const tableData = latestData.tables[tableId];
      if (this.selectedCells.length === 0 || this.applyToEntireTable) {
        if (horizontalAlign) {
          const colCount = ((_a = tableData.structure) == null ? void 0 : _a.colCount) || 0;
          for (let i = 0; i < colCount; i++) {
            if (tableData.styling.alignment[i] !== horizontalAlign) {
              console.warn(`\u9A8C\u8BC1\u5931\u8D25\uFF1A\u5217 ${i} \u7684\u5BF9\u9F50\u65B9\u5F0F\u4E0D\u5339\u914D\uFF0C\u671F\u671B ${horizontalAlign}\uFF0C\u5B9E\u9645 ${tableData.styling.alignment[i]}`);
              return false;
            }
          }
        }
        return true;
      } else {
        const selectedCellPositions = this.getSelectedCellPositions();
        for (const pos of selectedCellPositions) {
          const cellStyle = tableData.styling.cellStyles.find(
            (style) => style.row === pos.row && style.col === pos.col
          );
          if (!cellStyle) {
            console.warn(`\u9A8C\u8BC1\u5931\u8D25\uFF1A\u672A\u627E\u5230\u5355\u5143\u683C (${pos.row}, ${pos.col}) \u7684\u6837\u5F0F`);
            return false;
          }
          if (horizontalAlign && cellStyle.textAlign !== horizontalAlign) {
            console.warn(`\u9A8C\u8BC1\u5931\u8D25\uFF1A\u5355\u5143\u683C (${pos.row}, ${pos.col}) \u7684\u6C34\u5E73\u5BF9\u9F50\u65B9\u5F0F\u4E0D\u5339\u914D\uFF0C\u671F\u671B ${horizontalAlign}\uFF0C\u5B9E\u9645 ${cellStyle.textAlign}`);
            return false;
          }
          if (verticalAlign && cellStyle.verticalAlign !== verticalAlign) {
            console.warn(`\u9A8C\u8BC1\u5931\u8D25\uFF1A\u5355\u5143\u683C (${pos.row}, ${pos.col}) \u7684\u5782\u76F4\u5BF9\u9F50\u65B9\u5F0F\u4E0D\u5339\u914D\uFF0C\u671F\u671B ${verticalAlign}\uFF0C\u5B9E\u9645 ${cellStyle.verticalAlign}`);
            return false;
          }
        }
        return true;
      }
    } catch (error) {
      console.error("\u9A8C\u8BC1\u6837\u5F0F\u4FDD\u5B58\u65F6\u51FA\u9519:", error);
      throw error;
    }
  }
  /**
   * 
   */
  showSavingStatus() {
    let statusIndicator = document.querySelector(".advanced-table-saving-indicator");
    if (!statusIndicator) {
      statusIndicator = document.createElement("div");
      statusIndicator.className = "advanced-table-saving-indicator";
      statusIndicator.style.position = "fixed";
      statusIndicator.style.bottom = "20px";
      statusIndicator.style.right = "20px";
      statusIndicator.style.padding = "8px 12px";
      statusIndicator.style.backgroundColor = "var(--background-secondary)";
      statusIndicator.style.color = "var(--text-normal)";
      statusIndicator.style.borderRadius = "4px";
      statusIndicator.style.boxShadow = "0 2px 8px rgba(0, 0, 0, 0.15)";
      statusIndicator.style.zIndex = "1000";
      statusIndicator.style.fontSize = "14px";
      statusIndicator.style.display = "flex";
      statusIndicator.style.alignItems = "center";
      statusIndicator.style.gap = "8px";
      const spinner = document.createElement("div");
      spinner.className = "advanced-table-spinner";
      spinner.style.width = "16px";
      spinner.style.height = "16px";
      spinner.style.border = "2px solid var(--background-modifier-border)";
      spinner.style.borderTop = "2px solid var(--interactive-accent)";
      spinner.style.borderRadius = "50%";
      spinner.style.animation = "advanced-table-spin 1s linear infinite";
      const style = document.createElement("style");
      style.textContent = `
                @keyframes advanced-table-spin {
                    0% { transform: rotate(0deg); }
                    100% { transform: rotate(360deg); }
                }
            `;
      document.head.appendChild(style);
      statusIndicator.appendChild(spinner);
      statusIndicator.appendChild(document.createTextNode("\u6B63\u5728\u4FDD\u5B58\u8868\u683C\u6837\u5F0F..."));
      document.body.appendChild(statusIndicator);
    } else {
      statusIndicator.style.display = "flex";
    }
  }
  /**
   * 
   */
  hideSavingStatus() {
    const statusIndicator = document.querySelector(".advanced-table-saving-indicator");
    if (statusIndicator) {
      statusIndicator.style.display = "none";
    }
  }
  /**
   * 
   * @returns 
   */
  getSelectedCellPositions() {
    const positions = [];
    if (!this.activeTable || this.selectedCells.length === 0) {
      return positions;
    }
    this.selectedCells.forEach((cell) => {
      const row = cell.closest("tr");
      if (!row)
        return;
      const rowIndex = Array.from(this.activeTable.querySelectorAll("tr")).indexOf(row);
      if (rowIndex === -1)
        return;
      const colIndex = Array.from(row.querySelectorAll("td, th")).indexOf(cell);
      if (colIndex === -1)
        return;
      positions.push({ row: rowIndex, col: colIndex });
    });
    return positions;
  }
  /**
   * 
   * @param horizontalAlign 
   * @param verticalAlign 
   */
  applyAlignmentStylesOnly(horizontalAlign, verticalAlign) {
    if (this.selectedCells.length === 0 && this.activeTable) {
      const cells = this.activeTable.querySelectorAll("td, th");
      cells.forEach((cell) => {
        const cellEl = cell;
        if (horizontalAlign) {
          cellEl.style.textAlign = horizontalAlign;
        }
        if (verticalAlign) {
          cellEl.style.verticalAlign = verticalAlign;
        }
      });
      new import_obsidian5.Notice(`\u5DF2\u5C06${horizontalAlign || ""}${horizontalAlign && verticalAlign ? "\u548C" : ""}${verticalAlign || ""}\u5BF9\u9F50\u5E94\u7528\u5230\u6574\u4E2A\u8868\u683C`);
    } else {
      this.selectedCells.forEach((cell) => {
        if (horizontalAlign) {
          cell.style.textAlign = horizontalAlign;
        }
        if (verticalAlign) {
          cell.style.verticalAlign = verticalAlign;
        }
      });
      new import_obsidian5.Notice(`\u5DF2\u5C06${horizontalAlign || ""}${horizontalAlign && verticalAlign ? "\u548C" : ""}${verticalAlign || ""}\u5BF9\u9F50\u5E94\u7528\u5230\u9009\u4E2D\u5355\u5143\u683C`);
    }
  }
  /**
   * 
   */
  async mergeCells() {
    var _a;
    try {
      console.log("\u5C1D\u8BD5\u5408\u5E76\u9009\u4E2D\u7684\u5355\u5143\u683C");
      const activeView = this.getApp().workspace.getActiveViewOfType(import_obsidian6.MarkdownView);
      if (!activeView) {
        new import_obsidian5.Notice("\u65E0\u6CD5\u83B7\u53D6\u5F53\u524D\u89C6\u56FE");
        return;
      }
      const isEditMode = activeView.getMode() === "source";
      console.log(`\u5F53\u524D\u6A21\u5F0F: ${isEditMode ? "\u7F16\u8F91\u6A21\u5F0F" : "\u9884\u89C8\u6A21\u5F0F"}`);
      if (isEditMode && this.plugin.settings.enableEditModeOperations) {
        console.log("\u5728\u7F16\u8F91\u6A21\u5F0F\u4E0B\u4F7F\u7528 MarkdownSourceEditor \u5408\u5E76\u5355\u5143\u683C");
        const success = await this.plugin.markdownSourceEditor.mergeCells("right");
        if (success) {
          this.clearCellSelection();
          console.log("\u5408\u5E76\u5355\u5143\u683C\u6210\u529F");
        } else {
          console.log("\u5408\u5E76\u5355\u5143\u683C\u5931\u8D25");
        }
      } else {
        if (this.selectedCells.length < 2) {
          new import_obsidian5.Notice("\u8BF7\u9009\u62E9\u81F3\u5C112\u4E2A\u5355\u5143\u683C\u8FDB\u884C\u5408\u5E76");
          return;
        }
        const boundary = this.getSelectedCellsBoundary();
        if (!boundary) {
          new import_obsidian5.Notice("\u65E0\u6CD5\u786E\u5B9A\u9009\u4E2D\u5355\u5143\u683C\u7684\u8FB9\u754C");
          return;
        }
        const { minRow, maxRow, minCol, maxCol } = boundary;
        const expectedCellCount = (maxRow - minRow + 1) * (maxCol - minCol + 1);
        if (expectedCellCount !== this.selectedCells.length) {
          new import_obsidian5.Notice("\u53EA\u80FD\u5408\u5E76\u5F62\u6210\u5B8C\u6574\u77E9\u5F62\u7684\u5355\u5143\u683C");
          return;
        }
        const mainCell = (_a = this.activeTable) == null ? void 0 : _a.querySelector(`[row-index="${minRow}"][col-index="${minCol}"]`);
        if (!mainCell) {
          new import_obsidian5.Notice("\u65E0\u6CD5\u627E\u5230\u4E3B\u5355\u5143\u683C");
          return;
        }
        if (this.plugin.settings.confirmMergeNonEmpty) {
          const nonEmptyCells = this.selectedCells.filter((cell) => {
            var _a2;
            if (cell === mainCell)
              return false;
            const content = ((_a2 = cell.textContent) == null ? void 0 : _a2.trim()) || "";
            return content !== "" && content !== "<" && content !== "^";
          });
          if (nonEmptyCells.length > 0) {
            const cellContents = nonEmptyCells.map((cell) => {
              var _a2;
              return `"${((_a2 = cell.textContent) == null ? void 0 : _a2.trim()) || "(\u7A7A)"}"`;
            }).join(", ");
            const confirmMerge = await this.showConfirmDialog(
              `\u8981\u5408\u5E76\u7684\u5355\u5143\u683C\u5305\u542B\u5185\u5BB9${cellContents}\uFF0C\u786E\u5B9A\u8981\u5408\u5E76\u5417\uFF1F`
            );
            if (!confirmMerge)
              return;
          }
        }
        const rowSpanValue = maxRow - minRow + 1;
        const colSpanValue = maxCol - minCol + 1;
        if (rowSpanValue > 1) {
          mainCell.setAttribute("rowspan", rowSpanValue.toString());
        }
        if (colSpanValue > 1) {
          mainCell.setAttribute("colspan", colSpanValue.toString());
        }
        for (const cell of this.selectedCells) {
          if (cell === mainCell)
            continue;
          const rowIndex = parseInt(cell.getAttribute("row-index") || "0");
          const colIndex = parseInt(cell.getAttribute("col-index") || "0");
          if (rowIndex === minRow) {
            const markerCount = colIndex - minCol;
            cell.textContent = "<".repeat(markerCount);
            cell.setAttribute("data-merged", "true");
            cell.setAttribute("data-merge-direction", "left");
            cell.setAttribute("data-merge-count", markerCount.toString());
          } else if (colIndex === minCol) {
            const markerCount = rowIndex - minRow;
            cell.textContent = "^".repeat(markerCount);
            cell.setAttribute("data-merged", "true");
            cell.setAttribute("data-merge-direction", "up");
            cell.setAttribute("data-merge-count", markerCount.toString());
          } else {
            if (rowIndex > minRow && colIndex > minCol) {
              const markerCount = colIndex - minCol;
              cell.textContent = "<".repeat(markerCount);
              cell.setAttribute("data-merged", "true");
              cell.setAttribute("data-merge-direction", "left");
              cell.setAttribute("data-merge-count", markerCount.toString());
            }
          }
          cell.style.display = "none";
        }
        this.applyMergedCellStyles(mainCell, this.selectedCells.filter((cell) => cell !== mainCell));
        new import_obsidian5.Notice(`\u5DF2\u6210\u529F\u5408\u5E76${this.selectedCells.length}\u4E2A\u5355\u5143\u683C`);
        console.log("\u9884\u89C8\u6A21\u5F0F\u4E0B\u5408\u5E76\u5355\u5143\u683C\u6210\u529F");
        this.clearCellSelection();
      }
    } catch (error) {
      console.error("\u5408\u5E76\u5355\u5143\u683C\u65F6\u51FA\u9519:", error);
      new import_obsidian5.Notice(`\u5408\u5E76\u5355\u5143\u683C\u5931\u8D25: ${error.message || "\u672A\u77E5\u9519\u8BEF"}`);
    }
  }
  /**
   * 
   */
  async mergeRight() {
    var _a, _b;
    try {
      console.log("\u5C1D\u8BD5\u5411\u53F3\u5408\u5E76\u5355\u5143\u683C");
      const activeView = this.getApp().workspace.getActiveViewOfType(import_obsidian6.MarkdownView);
      if (!activeView) {
        new import_obsidian5.Notice("\u65E0\u6CD5\u83B7\u53D6\u5F53\u524D\u89C6\u56FE");
        return;
      }
      const isEditMode = activeView.getMode() === "source";
      console.log(`\u5F53\u524D\u6A21\u5F0F: ${isEditMode ? "\u7F16\u8F91\u6A21\u5F0F" : "\u9884\u89C8\u6A21\u5F0F"}`);
      if (isEditMode && this.plugin.settings.enableEditModeOperations) {
        console.log("\u5728\u7F16\u8F91\u6A21\u5F0F\u4E0B\u4F7F\u7528 MarkdownSourceEditor \u5408\u5E76\u5355\u5143\u683C");
        const success = await this.plugin.markdownSourceEditor.mergeCells("right");
        if (success) {
          this.clearCellSelection();
          console.log("\u5408\u5E76\u5355\u5143\u683C\u6210\u529F");
        } else {
          console.log("\u5408\u5E76\u5355\u5143\u683C\u5931\u8D25");
        }
      } else {
        if (this.selectedCells.length === 0) {
          new import_obsidian5.Notice("\u8BF7\u5148\u9009\u62E9\u8981\u5408\u5E76\u7684\u5355\u5143\u683C");
          return;
        }
        if (this.selectedCells.length > 1) {
          const rowIndices = /* @__PURE__ */ new Set();
          for (const cell2 of this.selectedCells) {
            const rowIndex2 = parseInt(cell2.getAttribute("row-index") || "0");
            rowIndices.add(rowIndex2);
          }
          if (rowIndices.size !== 1) {
            new import_obsidian5.Notice("\u5411\u53F3\u5408\u5E76\u9700\u8981\u9009\u62E9\u540C\u4E00\u884C\u7684\u5355\u5143\u683C");
            return;
          }
          const cellsWithIndices = this.selectedCells.map((cell2) => {
            return {
              cell: cell2,
              colIndex: parseInt(cell2.getAttribute("col-index") || "0")
            };
          }).sort((a, b) => a.colIndex - b.colIndex);
          for (let i = 1; i < cellsWithIndices.length; i++) {
            if (cellsWithIndices[i].colIndex !== cellsWithIndices[i - 1].colIndex + 1) {
              new import_obsidian5.Notice("\u9700\u8981\u9009\u62E9\u8FDE\u7EED\u7684\u5355\u5143\u683C\u8FDB\u884C\u5408\u5E76");
              return;
            }
          }
          const mainCell = cellsWithIndices[0].cell;
          const mergeCount = cellsWithIndices.length - 1;
          if (this.plugin.settings.confirmMergeNonEmpty) {
            const nonEmptyCells = cellsWithIndices.slice(1).filter((item) => {
              var _a2;
              const content = ((_a2 = item.cell.textContent) == null ? void 0 : _a2.trim()) || "";
              return content !== "" && content !== "<" && content !== "^";
            });
            if (nonEmptyCells.length > 0) {
              const cellContents = nonEmptyCells.map((item) => {
                var _a2;
                return `"${((_a2 = item.cell.textContent) == null ? void 0 : _a2.trim()) || "(\u7A7A)"}"`;
              }).join(", ");
              const confirmMerge = await this.showConfirmDialog(
                `\u8981\u5408\u5E76\u7684\u5355\u5143\u683C\u5305\u542B\u5185\u5BB9${cellContents}\uFF0C\u786E\u5B9A\u8981\u5408\u5E76\u5417\uFF1F`
              );
              if (!confirmMerge)
                return;
            }
          }
          for (let i = 1; i < cellsWithIndices.length; i++) {
            const cell2 = cellsWithIndices[i].cell;
            cell2.textContent = "<".repeat(i);
            cell2.setAttribute("data-merged", "true");
            cell2.setAttribute("data-merge-direction", "left");
            cell2.setAttribute("data-merge-count", i.toString());
          }
          this.applyMergedCellStyles(mainCell, cellsWithIndices.slice(1).map((item) => item.cell));
          new import_obsidian5.Notice(`\u5DF2\u5411\u53F3\u5408\u5E76${mergeCount}\u4E2A\u5355\u5143\u683C`);
          console.log(`\u9884\u89C8\u6A21\u5F0F\u4E0B\u5411\u53F3\u5408\u5E76${mergeCount}\u4E2A\u5355\u5143\u683C\u6210\u529F`);
          this.clearCellSelection();
          return;
        }
        const cell = this.selectedCells[0];
        if (!cell) {
          console.log("\u672A\u627E\u5230\u9009\u4E2D\u7684\u5355\u5143\u683C");
          return;
        }
        const rowIndex = parseInt(cell.getAttribute("row-index") || "0");
        const colIndex = parseInt(cell.getAttribute("col-index") || "0");
        console.log(`\u9009\u4E2D\u5355\u5143\u683C\u4F4D\u7F6E: \u884C=${rowIndex}, \u5217=${colIndex}`);
        const rightCell = (_a = this.activeTable) == null ? void 0 : _a.querySelector(`[row-index="${rowIndex}"][col-index="${colIndex + 1}"]`);
        if (!rightCell) {
          new import_obsidian5.Notice("\u53F3\u4FA7\u6CA1\u6709\u5355\u5143\u683C\u53EF\u5408\u5E76");
          return;
        }
        const rightContent = (_b = rightCell.textContent) == null ? void 0 : _b.trim();
        if (this.plugin.settings.confirmMergeNonEmpty && rightContent && rightContent !== "<" && rightContent !== "^") {
          const confirmed = await this.showConfirmDialog(
            `\u8981\u5408\u5E76\u7684\u5355\u5143\u683C\u5305\u542B\u5185\u5BB9"${rightContent}"\uFF0C\u786E\u5B9A\u8981\u5408\u5E76\u5417\uFF1F`
          );
          if (!confirmed)
            return;
        }
        rightCell.textContent = "<";
        rightCell.setAttribute("data-merged", "true");
        rightCell.setAttribute("data-merge-direction", "left");
        this.applyMergedCellStyles(cell, [rightCell]);
        new import_obsidian5.Notice("\u5DF2\u5411\u53F3\u5408\u5E76\u5355\u5143\u683C");
        console.log("\u9884\u89C8\u6A21\u5F0F\u4E0B\u5411\u53F3\u5408\u5E76\u5355\u5143\u683C\u6210\u529F");
      }
    } catch (error) {
      console.error("\u5411\u53F3\u5408\u5E76\u5355\u5143\u683C\u65F6\u51FA\u9519:", error);
      new import_obsidian5.Notice(`\u5411\u53F3\u5408\u5E76\u5355\u5143\u683C\u5931\u8D25: ${error.message || "\u672A\u77E5\u9519\u8BEF"}`);
    }
  }
  /**
   * 
   */
  async mergeDown() {
    var _a, _b;
    try {
      console.log("\u5C1D\u8BD5\u5411\u4E0B\u5408\u5E76\u5355\u5143\u683C");
      const activeView = this.getApp().workspace.getActiveViewOfType(import_obsidian6.MarkdownView);
      if (!activeView) {
        new import_obsidian5.Notice("\u65E0\u6CD5\u83B7\u53D6\u5F53\u524D\u89C6\u56FE");
        return;
      }
      const isEditMode = activeView.getMode() === "source";
      console.log(`\u5F53\u524D\u6A21\u5F0F: ${isEditMode ? "\u7F16\u8F91\u6A21\u5F0F" : "\u9884\u89C8\u6A21\u5F0F"}`);
      if (isEditMode && this.plugin.settings.enableEditModeOperations) {
        console.log("\u5728\u7F16\u8F91\u6A21\u5F0F\u4E0B\u4F7F\u7528 MarkdownSourceEditor \u5408\u5E76\u5355\u5143\u683C");
        const success = await this.plugin.markdownSourceEditor.mergeCells("down");
        if (success) {
          this.clearCellSelection();
          console.log("\u5411\u4E0B\u5408\u5E76\u5355\u5143\u683C\u6210\u529F");
        } else {
          console.log("\u5411\u4E0B\u5408\u5E76\u5355\u5143\u683C\u5931\u8D25");
        }
      } else {
        if (this.selectedCells.length === 0) {
          new import_obsidian5.Notice("\u8BF7\u5148\u9009\u62E9\u8981\u5408\u5E76\u7684\u5355\u5143\u683C");
          return;
        }
        if (this.selectedCells.length > 1) {
          const colIndices = /* @__PURE__ */ new Set();
          for (const cell2 of this.selectedCells) {
            const colIndex2 = parseInt(cell2.getAttribute("col-index") || "0");
            colIndices.add(colIndex2);
          }
          if (colIndices.size !== 1) {
            new import_obsidian5.Notice("\u5411\u4E0B\u5408\u5E76\u9700\u8981\u9009\u62E9\u540C\u4E00\u5217\u7684\u5355\u5143\u683C");
            return;
          }
          const cellsWithIndices = this.selectedCells.map((cell2) => {
            return {
              cell: cell2,
              rowIndex: parseInt(cell2.getAttribute("row-index") || "0")
            };
          }).sort((a, b) => a.rowIndex - b.rowIndex);
          for (let i = 1; i < cellsWithIndices.length; i++) {
            if (cellsWithIndices[i].rowIndex !== cellsWithIndices[i - 1].rowIndex + 1) {
              new import_obsidian5.Notice("\u9700\u8981\u9009\u62E9\u8FDE\u7EED\u7684\u5355\u5143\u683C\u8FDB\u884C\u5408\u5E76");
              return;
            }
          }
          const mainCell = cellsWithIndices[0].cell;
          const mergeCount = cellsWithIndices.length - 1;
          if (this.plugin.settings.confirmMergeNonEmpty) {
            const nonEmptyCells = cellsWithIndices.slice(1).filter((item) => {
              var _a2;
              const content = ((_a2 = item.cell.textContent) == null ? void 0 : _a2.trim()) || "";
              return content !== "" && content !== "<" && content !== "^";
            });
            if (nonEmptyCells.length > 0) {
              const cellContents = nonEmptyCells.map((item) => {
                var _a2;
                return `"${((_a2 = item.cell.textContent) == null ? void 0 : _a2.trim()) || "(\u7A7A)"}"`;
              }).join(", ");
              const confirmMerge = await this.showConfirmDialog(
                `\u8981\u5408\u5E76\u7684\u5355\u5143\u683C\u5305\u542B\u5185\u5BB9${cellContents}\uFF0C\u786E\u5B9A\u8981\u5408\u5E76\u5417\uFF1F`
              );
              if (!confirmMerge)
                return;
            }
          }
          for (let i = 1; i < cellsWithIndices.length; i++) {
            const cell2 = cellsWithIndices[i].cell;
            cell2.textContent = "^".repeat(i);
            cell2.setAttribute("data-merged", "true");
            cell2.setAttribute("data-merge-direction", "up");
            cell2.setAttribute("data-merge-count", i.toString());
          }
          this.applyMergedCellStyles(mainCell, cellsWithIndices.slice(1).map((item) => item.cell));
          new import_obsidian5.Notice(`\u5DF2\u5411\u4E0B\u5408\u5E76${mergeCount}\u4E2A\u5355\u5143\u683C`);
          console.log(`\u9884\u89C8\u6A21\u5F0F\u4E0B\u5411\u4E0B\u5408\u5E76${mergeCount}\u4E2A\u5355\u5143\u683C\u6210\u529F`);
          this.clearCellSelection();
          return;
        }
        const cell = this.selectedCells[0];
        if (!cell) {
          console.log("\u672A\u627E\u5230\u9009\u4E2D\u7684\u5355\u5143\u683C");
          return;
        }
        const rowIndex = parseInt(cell.getAttribute("row-index") || "0");
        const colIndex = parseInt(cell.getAttribute("col-index") || "0");
        console.log(`\u9009\u4E2D\u5355\u5143\u683C\u4F4D\u7F6E: \u884C=${rowIndex}, \u5217=${colIndex}`);
        const belowCell = (_a = this.activeTable) == null ? void 0 : _a.querySelector(`[row-index="${rowIndex + 1}"][col-index="${colIndex}"]`);
        if (!belowCell) {
          new import_obsidian5.Notice("\u4E0B\u65B9\u6CA1\u6709\u5355\u5143\u683C\u53EF\u5408\u5E76");
          return;
        }
        const belowContent = (_b = belowCell.textContent) == null ? void 0 : _b.trim();
        if (this.plugin.settings.confirmMergeNonEmpty && belowContent && belowContent !== "<" && belowContent !== "^") {
          const confirmed = await this.showConfirmDialog(
            `\u8981\u5408\u5E76\u7684\u5355\u5143\u683C\u5305\u542B\u5185\u5BB9"${belowContent}"\uFF0C\u786E\u5B9A\u8981\u5408\u5E76\u5417\uFF1F`
          );
          if (!confirmed)
            return;
        }
        belowCell.textContent = "^";
        belowCell.setAttribute("data-merged", "true");
        belowCell.setAttribute("data-merge-direction", "up");
        this.applyMergedCellStyles(cell, [belowCell]);
        new import_obsidian5.Notice("\u5DF2\u5411\u4E0B\u5408\u5E76\u5355\u5143\u683C");
        console.log("\u9884\u89C8\u6A21\u5F0F\u4E0B\u5411\u4E0B\u5408\u5E76\u5355\u5143\u683C\u6210\u529F");
      }
    } catch (error) {
      console.error("\u5411\u4E0B\u5408\u5E76\u5355\u5143\u683C\u65F6\u51FA\u9519:", error);
      new import_obsidian5.Notice(`\u5411\u4E0B\u5408\u5E76\u5355\u5143\u683C\u5931\u8D25: ${error.message || "\u672A\u77E5\u9519\u8BEF"}`);
    }
  }
  /**
   * 
   */
  splitCell() {
    try {
      if (this.selectedCells.length !== 1) {
        console.log("\u9700\u8981\u9009\u62E9\u4E00\u4E2A\u5355\u5143\u683C\u8FDB\u884C\u62C6\u5206");
        new import_obsidian5.Notice("\u8BF7\u9009\u62E9\u4E00\u4E2A\u5355\u5143\u683C\u8FDB\u884C\u62C6\u5206");
        return;
      }
      console.log("\u5F00\u59CB\u62C6\u5206\u5355\u5143\u683C");
      const cell = this.selectedCells[0];
      const rowIndex = parseInt(cell.getAttribute("row-index") || "0");
      const colIndex = parseInt(cell.getAttribute("col-index") || "0");
      const colSpan = cell.getAttribute("colspan");
      const rowSpan = cell.getAttribute("rowspan");
      const table = cell.closest("table");
      let hasMergeMarkers = false;
      if (table) {
        const rightCell = table.querySelector(`[row-index="${rowIndex}"][col-index="${colIndex + 1}"]`);
        if (rightCell && rightCell.textContent) {
          const rightContent = rightCell.textContent.trim();
          if (rightContent === "<" || rightContent === "^") {
            hasMergeMarkers = true;
            rightCell.textContent = "";
            console.log("\u5DF2\u6E05\u9664\u53F3\u4FA7\u5355\u5143\u683C\u7684\u5408\u5E76\u6807\u8BB0");
          }
        }
        const belowCell = table.querySelector(`[row-index="${rowIndex + 1}"][col-index="${colIndex}"]`);
        if (belowCell && belowCell.textContent) {
          const belowContent = belowCell.textContent.trim();
          if (belowContent === "<" || belowContent === "^") {
            hasMergeMarkers = true;
            belowCell.textContent = "";
            console.log("\u5DF2\u6E05\u9664\u4E0B\u65B9\u5355\u5143\u683C\u7684\u5408\u5E76\u6807\u8BB0");
          }
        }
        for (let i = colIndex + 1; i < colIndex + 10; i++) {
          const nextCell = table.querySelector(`[row-index="${rowIndex}"][col-index="${i}"]`);
          if (nextCell && nextCell.textContent && nextCell.textContent.trim() === "<") {
            nextCell.textContent = "";
            hasMergeMarkers = true;
            console.log(`\u5DF2\u6E05\u9664\u4F4D\u7F6E (${rowIndex}, ${i}) \u7684\u6C34\u5E73\u5408\u5E76\u6807\u8BB0`);
          } else {
            break;
          }
        }
        for (let i = rowIndex + 1; i < rowIndex + 10; i++) {
          const nextCell = table.querySelector(`[row-index="${i}"][col-index="${colIndex}"]`);
          if (nextCell && nextCell.textContent && nextCell.textContent.trim() === "^") {
            nextCell.textContent = "";
            hasMergeMarkers = true;
            console.log(`\u5DF2\u6E05\u9664\u4F4D\u7F6E (${i}, ${colIndex}) \u7684\u5782\u76F4\u5408\u5E76\u6807\u8BB0`);
          } else {
            break;
          }
        }
      }
      if (!colSpan && !rowSpan && !hasMergeMarkers) {
        console.log("\u9009\u4E2D\u7684\u5355\u5143\u683C\u6CA1\u6709\u5408\u5E76\u5C5E\u6027\uFF0C\u65E0\u9700\u62C6\u5206");
        new import_obsidian5.Notice("\u9009\u4E2D\u7684\u5355\u5143\u683C\u6CA1\u6709\u5408\u5E76\u5C5E\u6027\uFF0C\u65E0\u9700\u62C6\u5206");
        return;
      }
      if (colSpan) {
        cell.removeAttribute("colspan");
      }
      if (rowSpan) {
        cell.removeAttribute("rowspan");
      }
      if (table) {
        const hiddenCells = table.querySelectorAll('td[style*="display: none"], th[style*="display: none"]');
        hiddenCells.forEach((hiddenCell) => {
          hiddenCell.style.display = "";
        });
      }
      new import_obsidian5.Notice("\u5DF2\u62C6\u5206\u5355\u5143\u683C");
      console.log("\u5355\u5143\u683C\u62C6\u5206\u5B8C\u6210");
      this.clearCellSelection();
    } catch (error) {
      console.error("\u62C6\u5206\u5355\u5143\u683C\u5931\u8D25:", error);
      new import_obsidian5.Notice(`\u62C6\u5206\u5355\u5143\u683C\u5931\u8D25: ${error.message || "\u672A\u77E5\u9519\u8BEF"}`);
    }
  }
  /**
   * ID
   */
  generateTableId() {
    try {
      const activeView = this.getApp().workspace.getActiveViewOfType(import_obsidian6.MarkdownView);
      if (!activeView) {
        new import_obsidian5.Notice("\u65E0\u6CD5\u83B7\u53D6\u5F53\u524D\u89C6\u56FE");
        return;
      }
      const isEditMode = activeView.getMode() === "source";
      if (isEditMode && this.plugin.settings.enableEditModeOperations) {
        this.showConfirmDialog("\u662F\u5426\u4E3A\u5F53\u524D\u8868\u683C\u521B\u5EFAID\uFF1F\u521B\u5EFA\u540E\u5C06\u5728\u8868\u683C\u524D\u6DFB\u52A0HTML\u6CE8\u91CA\u3002").then((confirmed) => {
          if (!confirmed) {
            return;
          }
          const editor = activeView.editor;
          const tableInfo = this.plugin.markdownSourceEditor.locateTableInMarkdown(editor);
          if (tableInfo) {
            if (tableInfo.tableId) {
              new import_obsidian5.Notice(`\u8868\u683C\u5DF2\u6709ID: ${tableInfo.tableId}`);
              return;
            }
            const newId = this.generateUniqueTableId();
            const tableStartLine = tableInfo.startLine;
            const currentPos = editor.getCursor();
            editor.replaceRange(`<!-- table-id: ${newId} -->
`, { line: tableStartLine, ch: 0 });
            editor.setCursor(currentPos);
            new import_obsidian5.Notice(`\u5DF2\u4E3A\u8868\u683C\u6DFB\u52A0ID: ${newId}`);
            console.log("\u5DF2\u4E3A\u8868\u683C\u6DFB\u52A0ID:", newId);
          } else {
            new import_obsidian5.Notice("\u672A\u627E\u5230\u8868\u683C\uFF0C\u8BF7\u786E\u4FDD\u5149\u6807\u5728\u8868\u683C\u5185");
          }
        });
      } else {
        if (!this.activeTable) {
          new import_obsidian5.Notice("\u8BF7\u5148\u9009\u62E9\u4E00\u4E2A\u8868\u683C");
          return;
        }
        this.showConfirmDialog("\u662F\u5426\u4E3A\u5F53\u524D\u8868\u683C\u521B\u5EFAID\uFF1F").then((confirmed) => {
          if (!confirmed) {
            return;
          }
          const tableId = this.activeTable ? this.plugin.tableIdManager.confirmAndCreateTableId(this.activeTable) : "";
          if (tableId) {
            const activeView2 = this.getApp().workspace.getActiveViewOfType(import_obsidian6.MarkdownView);
            if (activeView2) {
              activeView2.previewMode.rerender(true);
            }
            console.log("\u5DF2\u4E3A\u8868\u683C\u6DFB\u52A0ID:", tableId);
          } else {
            console.error("\u521B\u5EFA\u8868\u683CID\u5931\u8D25");
            new import_obsidian5.Notice("\u521B\u5EFA\u8868\u683CID\u5931\u8D25\uFF0C\u8BF7\u624B\u52A8\u6DFB\u52A0");
          }
        });
      }
    } catch (error) {
      console.error("\u751F\u6210\u8868\u683CID\u65F6\u51FA\u9519:", error);
      new import_obsidian5.Notice(`\u751F\u6210\u8868\u683CID\u65F6\u51FA\u9519: ${error.message || "\u672A\u77E5\u9519\u8BEF"}`);
    }
  }
  /**
   * ID
   * @returns  tbl-YYYYMMDD-xxxxxxxx ID
   */
  generateUniqueTableId() {
    const now = new Date();
    const year = now.getFullYear();
    const month = String(now.getMonth() + 1).padStart(2, "0");
    const day = String(now.getDate()).padStart(2, "0");
    const dateStr = `${year}${month}${day}`;
    const randomChars = "abcdefghijklmnopqrstuvwxyz0123456789";
    let randomStr = "";
    for (let i = 0; i < 8; i++) {
      randomStr += randomChars.charAt(Math.floor(Math.random() * randomChars.length));
    }
    return `tbl-${dateStr}-${randomStr}`;
  }
  /**
   * ID
   * @param editor 
   * @returns IDnull
   */
  checkExistingTableId(editor) {
    const content = editor.getValue();
    const lines = content.split("\n");
    let tableStartLine = -1;
    for (let i = 0; i < lines.length; i++) {
      if (lines[i].trim().startsWith("|") && lines[i].includes("|")) {
        if (i + 1 < lines.length && lines[i + 1].trim().match(/^\|[-:\s|]*\|$/)) {
          tableStartLine = i;
          break;
        }
      }
    }
    if (tableStartLine === -1) {
      return null;
    }
    let idCommentLine = tableStartLine - 1;
    while (idCommentLine >= 0 && (lines[idCommentLine].trim() === "" || lines[idCommentLine].trim().startsWith("<!--"))) {
      const line = lines[idCommentLine].trim();
      if (line.includes("table-id:")) {
        const match = line.match(/table-id:\s*([^\s>]+)/);
        return match ? match[1] : null;
      }
      idCommentLine--;
    }
    return null;
  }
  /**
   * 
   * @param tableId ID
   * @param tableElement 
   * @param filePath 
   */
  extractAndStoreTableInfo(tableId, tableElement, filePath) {
    try {
      const rows = tableElement.querySelectorAll("tr");
      const rowCount = rows.length;
      let colCount = 0;
      let hasHeaders = false;
      if (rowCount > 0) {
        const firstRow = rows[0];
        const headerCells = firstRow.querySelectorAll("th");
        hasHeaders = headerCells.length > 0;
        for (const row of Array.from(rows)) {
          const cellCount = row.querySelectorAll("td, th").length;
          colCount = Math.max(colCount, cellCount);
        }
      }
      const mergeInfo = this.extractMergeInfo(tableElement);
      console.log(`\u63D0\u53D6\u8868\u683C\u5408\u5E76\u4FE1\u606F:`, mergeInfo);
      const tableInfo = {
        id: tableId,
        locations: [
          {
            path: filePath,
            isActive: true
          }
        ],
        structure: {
          rowCount,
          colCount,
          hasHeaders
        },
        styling: {
          rowHeights: Array(rowCount).fill("auto"),
          colWidths: Array(colCount).fill("auto"),
          alignment: Array(colCount).fill("left"),
          cellStyles: []
          // cellStyles
        }
      };
      console.log(`\u4FDD\u5B58\u8868\u683C\u4FE1\u606F: ID=${tableId}, \u884C\u6570=${rowCount}, \u5217\u6570=${colCount}, \u8868\u5934=${hasHeaders}`);
      this.plugin.saveTableData(tableInfo);
    } catch (error) {
      console.error("\u63D0\u53D6\u8868\u683C\u4FE1\u606F\u65F6\u51FA\u9519:", error);
    }
  }
  /**
   * 
   * @param tableElement 
   * @returns 
   */
  extractMergeInfo(tableElement) {
    var _a;
    const mergeInfo = {
      horizontal: [],
      vertical: []
    };
    const rows = tableElement.querySelectorAll("tr");
    for (let rowIndex = 0; rowIndex < rows.length; rowIndex++) {
      const row = rows[rowIndex];
      const cells = row.querySelectorAll("td, th");
      for (let colIndex = 0; colIndex < cells.length; colIndex++) {
        const cell = cells[colIndex];
        const content = ((_a = cell.textContent) == null ? void 0 : _a.trim()) || "";
        const leftMatch = content.match(/^(<+)$/);
        if (leftMatch) {
          const count = leftMatch[1].length;
          mergeInfo.horizontal.push({
            row: rowIndex,
            col: colIndex,
            count,
            content
          });
        }
        const upMatch = content.match(/^(\^+)$/);
        if (upMatch) {
          const count = upMatch[1].length;
          mergeInfo.vertical.push({
            row: rowIndex,
            col: colIndex,
            count,
            content
          });
        }
        const colspan = parseInt(cell.getAttribute("colspan") || "1");
        const rowspan = parseInt(cell.getAttribute("rowspan") || "1");
        if (colspan > 1 || rowspan > 1) {
          console.log(`\u53D1\u73B0\u5408\u5E76\u5355\u5143\u683C: \u4F4D\u7F6E(${rowIndex},${colIndex}), colspan=${colspan}, rowspan=${rowspan}`);
        }
      }
    }
    return mergeInfo;
  }
  /**
   * 
   */
  showRowAddMenu() {
    try {
      if (!this.activeTable) {
        console.log("\u65E0\u6D3B\u52A8\u8868\u683C\uFF0C\u65E0\u6CD5\u6DFB\u52A0\u884C");
        new import_obsidian5.Notice("\u8BF7\u5148\u9009\u62E9\u4E00\u4E2A\u8868\u683C");
        return;
      }
      console.log("\u663E\u793A\u6DFB\u52A0\u884C\u83DC\u5355");
      const menu = new import_obsidian5.Menu();
      menu.addItem(
        (item) => item.setTitle("\u5728\u4E0A\u65B9\u6DFB\u52A0\u884C").setIcon("arrow-up").onClick(() => this.addRow("above"))
      );
      menu.addItem(
        (item) => item.setTitle("\u5728\u4E0B\u65B9\u6DFB\u52A0\u884C").setIcon("arrow-down").onClick(() => this.addRow("below"))
      );
      const toolbarEl = this.toolbar;
      if (toolbarEl) {
        const rect = toolbarEl.getBoundingClientRect();
        menu.showAtPosition({ x: rect.left, y: rect.bottom });
      } else {
        menu.showAtMouseEvent(event);
      }
    } catch (error) {
      console.error("\u663E\u793A\u6DFB\u52A0\u884C\u83DC\u5355\u5931\u8D25:", error);
      new import_obsidian5.Notice(`\u663E\u793A\u6DFB\u52A0\u884C\u83DC\u5355\u5931\u8D25: ${error.message || "\u672A\u77E5\u9519\u8BEF"}`);
    }
  }
  /**
   * 
   * @param position above  below
   */
  addRow(position) {
    var _a, _b;
    try {
      if (!this.activeTable) {
        console.log("\u65E0\u6D3B\u52A8\u8868\u683C\uFF0C\u65E0\u6CD5\u6DFB\u52A0\u884C");
        new import_obsidian5.Notice("\u8BF7\u5148\u9009\u62E9\u4E00\u4E2A\u8868\u683C");
        return;
      }
      console.log("\u5F00\u59CB\u6DFB\u52A0\u884C:", position);
      let targetRow = null;
      if (this.selectedCells.length > 0) {
        targetRow = this.selectedCells[0].closest("tr");
      } else {
        targetRow = this.activeTable.querySelector("tr");
      }
      if (!targetRow) {
        console.error("\u65E0\u6CD5\u627E\u5230\u76EE\u6807\u884C");
        new import_obsidian5.Notice("\u65E0\u6CD5\u627E\u5230\u76EE\u6807\u884C");
        return;
      }
      const cellCount = targetRow.querySelectorAll("td, th").length;
      const newRow = document.createElement("tr");
      for (let i = 0; i < cellCount; i++) {
        const cell = document.createElement("td");
        cell.textContent = "";
        newRow.appendChild(cell);
      }
      if (position === "above") {
        (_a = targetRow.parentNode) == null ? void 0 : _a.insertBefore(newRow, targetRow);
      } else {
        (_b = targetRow.parentNode) == null ? void 0 : _b.insertBefore(newRow, targetRow.nextSibling);
      }
      new import_obsidian5.Notice(`\u5DF2\u5728${position === "above" ? "\u4E0A\u65B9" : "\u4E0B\u65B9"}\u6DFB\u52A0\u884C`);
      console.log("\u6DFB\u52A0\u884C\u5B8C\u6210:", position);
    } catch (error) {
      console.error("\u6DFB\u52A0\u884C\u5931\u8D25:", error);
      new import_obsidian5.Notice(`\u6DFB\u52A0\u884C\u5931\u8D25: ${error.message || "\u672A\u77E5\u9519\u8BEF"}`);
    }
  }
  /**
   * 
   */
  updateRowIndices() {
    if (!this.activeTable)
      return;
    const rows = this.activeTable.querySelectorAll("tr");
    rows.forEach((row, rowIndex) => {
      const cells = row.querySelectorAll("td, th");
      cells.forEach((cell, colIndex) => {
        cell.setAttribute("row-index", rowIndex.toString());
        cell.setAttribute("col-index", colIndex.toString());
      });
    });
  }
  /**
   * 
   */
  showStyleMenu() {
    const menu = new import_obsidian5.Menu();
    menu.addItem(
      (item) => item.setTitle("\u8BBE\u7F6E\u8868\u683C\u6837\u5F0F").setIcon("brush").onClick(() => {
        new import_obsidian5.Notice("\u6837\u5F0F\u8BBE\u7F6E\u529F\u80FD\u6B63\u5728\u5F00\u53D1\u4E2D");
      })
    );
    menu.addItem(
      (item) => item.setTitle("\u8BBE\u7F6E\u6761\u7EB9\u6837\u5F0F").setIcon("lines").onClick(() => this.applyStripedStyle())
    );
    menu.addItem(
      (item) => item.setTitle("\u8BBE\u7F6E\u8FB9\u6846\u6837\u5F0F").setIcon("box").onClick(() => this.applyBorderedStyle())
    );
    const button = this.toolbar.querySelector(".table-style");
    const rect = button.getBoundingClientRect();
    menu.showAtPosition({ x: rect.left, y: rect.bottom });
  }
  /**
   * 
   */
  applyStripedStyle() {
    if (!this.activeTable) {
      new import_obsidian5.Notice("\u8BF7\u5148\u9009\u62E9\u4E00\u4E2A\u8868\u683C");
      return;
    }
    const rows = this.activeTable.querySelectorAll("tr");
    rows.forEach((row, index) => {
      if (index > 0 && index % 2 === 1) {
        const cells = row.querySelectorAll("td");
        cells.forEach((cell) => {
          cell.style.backgroundColor = "var(--background-secondary)";
        });
      }
    });
    new import_obsidian5.Notice("\u5DF2\u5E94\u7528\u6761\u7EB9\u6837\u5F0F");
  }
  /**
   * 
   */
  applyBorderedStyle() {
    if (!this.activeTable) {
      new import_obsidian5.Notice("\u8BF7\u5148\u9009\u62E9\u4E00\u4E2A\u8868\u683C");
      return;
    }
    this.activeTable.style.borderCollapse = "collapse";
    const cells = this.activeTable.querySelectorAll("td, th");
    cells.forEach((cell) => {
      cell.style.border = "1px solid var(--background-modifier-border)";
      cell.style.padding = "4px 8px";
    });
    new import_obsidian5.Notice("\u5DF2\u5E94\u7528\u8FB9\u6846\u6837\u5F0F");
  }
  /**
   * 
   * @param table HTML
   */
  setActiveTable(table) {
    var _a, _b;
    try {
      console.log("\u8BBE\u7F6E\u6D3B\u52A8\u8868\u683C");
      console.log("\u8868\u683CDOM\u7ED3\u6784:", table.outerHTML.substring(0, 200) + "...");
      const tableId = this.plugin.tableIdManager.getTableIdentifier(table);
      console.log(`\u8868\u683CID\u68C0\u67E5\u7ED3\u679C: ${tableId || "\u672A\u627E\u5230"}`);
      let prevNode = table.previousSibling;
      let nodeCount = 0;
      console.log("\u8868\u683C\u524D\u7F6E\u8282\u70B9\u68C0\u67E5:");
      while (prevNode && nodeCount < 5) {
        nodeCount++;
        const nodeType = prevNode.nodeType;
        const nodeTypeStr = nodeType === Node.COMMENT_NODE ? "COMMENT" : nodeType === Node.TEXT_NODE ? "TEXT" : nodeType === Node.ELEMENT_NODE ? "ELEMENT" : "OTHER";
        if (nodeType === Node.COMMENT_NODE) {
          console.log(`  \u524D\u7F6E\u8282\u70B9#${nodeCount}: \u7C7B\u578B=${nodeTypeStr}, \u5185\u5BB9="${((_a = prevNode.textContent) == null ? void 0 : _a.trim()) || ""}"`);
        } else if (nodeType === Node.TEXT_NODE) {
          const text = ((_b = prevNode.textContent) == null ? void 0 : _b.trim()) || "";
          console.log(`  \u524D\u7F6E\u8282\u70B9#${nodeCount}: \u7C7B\u578B=${nodeTypeStr}, \u5185\u5BB9="${text.substring(0, 20)}${text.length > 20 ? "..." : ""}"`);
        } else if (nodeType === Node.ELEMENT_NODE) {
          console.log(`  \u524D\u7F6E\u8282\u70B9#${nodeCount}: \u7C7B\u578B=${nodeTypeStr}, \u6807\u7B7E=<${prevNode.tagName.toLowerCase()}>`);
        }
        prevNode = prevNode.previousSibling;
      }
      this.activeTable = table;
      this.plugin.removeAllTableHighlights();
      this.plugin.highlightSelectedTable(table);
      this.setupCellSelection();
      console.log("\u6D3B\u52A8\u8868\u683C\u8BBE\u7F6E\u5B8C\u6210");
    } catch (error) {
      console.error("\u8BBE\u7F6E\u6D3B\u52A8\u8868\u683C\u65F6\u51FA\u9519:", error);
    }
  }
  /**
   * 
   * @param tableInfo 
   */
  setActiveEditModeTable(tableInfo) {
    try {
      if (this.activeTable) {
        this.clearCellSelection();
        this.activeTable.dataset.tableSelected = "false";
        this.activeTable.style.outline = "";
        this.activeTable.style.outlineOffset = "";
        this.activeTable = null;
      }
      this.editModeTableInfo = tableInfo;
      console.log("\u7F16\u8F91\u6A21\u5F0F\u4E0B\u9009\u62E9\u4E86\u8868\u683C:", tableInfo);
    } catch (error) {
      console.error("\u8BBE\u7F6E\u7F16\u8F91\u6A21\u5F0F\u6D3B\u52A8\u8868\u683C\u65F6\u51FA\u9519:", error);
    }
  }
  /**
   * 
   * @returns 
   */
  isInEditMode() {
    const activeView = this.getApp().workspace.getActiveViewOfType(import_obsidian6.MarkdownView);
    return activeView ? activeView.getMode() === "source" : false;
  }
  /**
   * 
   */
  setupCellSelection() {
    if (!this.activeTable)
      return;
    const cells = this.activeTable.querySelectorAll("td, th");
    cells.forEach((cell) => {
      const cellEl = cell;
      cellEl.onclick = (event2) => this.handleCellClick(cellEl, event2);
    });
  }
  /**
   * 
   * @param cell 
   * @param event 
   */
  handleCellClick(cell, event2) {
    event2.stopPropagation();
    if (!event2.ctrlKey && !event2.metaKey) {
      this.clearCellSelection();
    }
    const index = this.selectedCells.indexOf(cell);
    if (index === -1) {
      this.selectedCells.push(cell);
      cell.classList.add("selected-cell");
      cell.style.backgroundColor = "var(--text-selection)";
      const position = this.selectedCells.length > 1 ? "\u591A\u9009\u6A21\u5F0F" : "\u5DF2\u9009\u62E9\u5355\u5143\u683C";
      new import_obsidian5.Notice(`${position} (${this.selectedCells.length})`, 1e3);
    } else {
      this.selectedCells.splice(index, 1);
      cell.classList.remove("selected-cell");
      cell.style.backgroundColor = "";
      if (this.selectedCells.length > 0) {
        new import_obsidian5.Notice(`\u5DF2\u9009\u62E9 ${this.selectedCells.length} \u4E2A\u5355\u5143\u683C`, 1e3);
      }
    }
    console.log("\u5DF2\u9009\u62E9\u5355\u5143\u683C:", this.selectedCells.length);
  }
  /**
   * 
   */
  clearCellSelection() {
    this.selectedCells.forEach((cell) => {
      cell.classList.remove("selected-cell");
      cell.style.backgroundColor = "";
    });
    this.selectedCells = [];
  }
  /**
   * 
   * @param message 
   * @returns 
   */
  async showConfirmDialog(message) {
    return new Promise((resolve) => {
      const notice = new import_obsidian5.Notice(message, 0);
      const buttonContainer = document.createElement("div");
      buttonContainer.style.display = "flex";
      buttonContainer.style.justifyContent = "space-between";
      buttonContainer.style.marginTop = "10px";
      const cancelButton = document.createElement("button");
      cancelButton.textContent = "\u53D6\u6D88";
      cancelButton.onclick = () => {
        notice.hide();
        resolve(false);
      };
      const confirmButton = document.createElement("button");
      confirmButton.textContent = "\u786E\u5B9A";
      confirmButton.style.marginLeft = "10px";
      confirmButton.onclick = () => {
        notice.hide();
        resolve(true);
      };
      buttonContainer.appendChild(cancelButton);
      buttonContainer.appendChild(confirmButton);
      notice.noticeEl.appendChild(buttonContainer);
    });
  }
  /**
   * 
   * @param mainCell 
   * @param mergedCells 
   */
  applyMergedCellStyles(mainCell, mergedCells) {
    mainCell.classList.add("obs-merged-cell-main");
    if (this.plugin.settings.autoCenterMergedCells) {
      mainCell.style.textAlign = "center";
      mainCell.style.verticalAlign = "middle";
    }
    for (const cell of mergedCells) {
      cell.style.display = "none";
    }
    mainCell.setAttribute("data-merged-main", "true");
  }
  /**
   * 
   */
  clearSelection() {
    try {
      this.clearCellSelection();
      if (this.activeTable) {
        this.activeTable.dataset.tableSelected = "false";
        this.activeTable.style.outline = "";
        this.activeTable.style.outlineOffset = "";
        this.activeTable = null;
      }
      this.editModeTableInfo = null;
      console.log("\u5DF2\u6E05\u9664\u8868\u683C\u9009\u62E9");
    } catch (error) {
      console.error("\u6E05\u9664\u8868\u683C\u9009\u62E9\u65F6\u51FA\u9519:", error);
    }
  }
  /**
   * 
   * @returns  {minRow, maxRow, minCol, maxCol}
   */
  getSelectedCellsBoundary() {
    if (!this.selectedCells || this.selectedCells.length === 0) {
      return null;
    }
    let minRow = Number.MAX_SAFE_INTEGER;
    let maxRow = 0;
    let minCol = Number.MAX_SAFE_INTEGER;
    let maxCol = 0;
    for (const cell of this.selectedCells) {
      const rowIndex = parseInt(cell.getAttribute("row-index") || "0");
      const colIndex = parseInt(cell.getAttribute("col-index") || "0");
      minRow = Math.min(minRow, rowIndex);
      maxRow = Math.max(maxRow, rowIndex);
      minCol = Math.min(minCol, colIndex);
      maxCol = Math.max(maxCol, colIndex);
    }
    return { minRow, maxRow, minCol, maxCol };
  }
};

// src/markdownSourceEditor.ts
var import_obsidian7 = require("obsidian");
var MarkdownSourceEditor = class {
  // app
  getApp() {
    return this.plugin.app;
  }
  constructor(plugin) {
    this.plugin = plugin;
    console.log("MarkdownSourceEditor initialized");
  }
  /**
   * 
   * @returns null
   */
  getActiveEditor() {
    const activeView = this.getApp().workspace.getActiveViewOfType(import_obsidian7.MarkdownView);
    if (activeView && activeView.editor) {
      return activeView.editor;
    }
    return null;
  }
  /**
   * Markdown
   * @param editor 
   * @returns null
   */
  locateTableInMarkdown(editor) {
    try {
      const content = editor.getValue();
      const cursor = editor.getCursor();
      const lines = content.split("\n");
      const cursorLine = lines[cursor.line];
      const isInTableRow = cursorLine && cursorLine.trim().startsWith("|") && cursorLine.trim().endsWith("|");
      if (!isInTableRow)
        return null;
      let startLine = cursor.line;
      while (startLine > 0 && lines[startLine - 1].trim().startsWith("|")) {
        startLine--;
      }
      let endLine = cursor.line;
      while (endLine < lines.length - 1 && lines[endLine + 1].trim().startsWith("|")) {
        endLine++;
      }
      if (!this.isValidTable(lines.slice(startLine, endLine + 1))) {
        return null;
      }
      const tableId = this.findTableIdAbove(editor, startLine);
      return {
        startLine,
        endLine,
        content: lines.slice(startLine, endLine + 1).join("\n"),
        tableId
      };
    } catch (error) {
      console.error("\u5B9A\u4F4DMarkdown\u8868\u683C\u65F6\u51FA\u9519:", error);
      return null;
    }
  }
  /**
   * ID
   * @param editor 
   * @param tableLine 
   * @returns IDundefined
   */
  findTableIdAbove(editor, tableLine) {
    console.log(`\u67E5\u627E\u8868\u683CID: \u8868\u683C\u8D77\u59CB\u884C=${tableLine}`);
    const maxLinesToCheck = 10;
    let currentLine = tableLine - 1;
    const minLine = Math.max(0, tableLine - maxLinesToCheck);
    while (currentLine >= minLine) {
      const line = editor.getLine(currentLine);
      if (!line)
        break;
      console.log(`\u68C0\u67E5\u884C ${currentLine}: "${line}"`);
      const standardIdMatch = line.match(/<!--\s*table-id:\s*([a-zA-Z0-9_\-:.]+)\s*-->/i);
      if (standardIdMatch && standardIdMatch[1]) {
        const id = standardIdMatch[1];
        console.log(`\u5728\u884C ${currentLine} \u627E\u5230\u6807\u51C6\u683C\u5F0F\u8868\u683CID: ${id}`);
        return id;
      }
      const noHyphenIdMatch = line.match(/<!--\s*tableid:\s*([a-zA-Z0-9_\-:.]+)\s*-->/i);
      if (noHyphenIdMatch && noHyphenIdMatch[1]) {
        const id = noHyphenIdMatch[1];
        console.log(`\u5728\u884C ${currentLine} \u627E\u5230\u65E0\u8FDE\u5B57\u7B26\u683C\u5F0F\u8868\u683CID: ${id}`);
        return id;
      }
      const simpleIdMatch = line.match(/<!--\s*id:\s*([a-zA-Z0-9_\-:.]+)\s*-->/i);
      if (simpleIdMatch && simpleIdMatch[1]) {
        const id = simpleIdMatch[1];
        console.log(`\u5728\u884C ${currentLine} \u627E\u5230\u7B80\u5316\u683C\u5F0F\u8868\u683CID: ${id}`);
        return id;
      }
      const tableNameIdMatch = line.match(/<!--\s*(table|tbl):\s*([a-zA-Z0-9_\-:.]+)\s*-->/i);
      if (tableNameIdMatch && tableNameIdMatch[2]) {
        const id = tableNameIdMatch[2];
        console.log(`\u5728\u884C ${currentLine} \u627E\u5230\u8868\u683C\u540D\u79F0\u683C\u5F0FID: ${id}`);
        return id;
      }
      const noSpaceIdMatch = line.match(/<!--table-id:([a-zA-Z0-9_\-:.]+)-->/i);
      if (noSpaceIdMatch && noSpaceIdMatch[1]) {
        const id = noSpaceIdMatch[1];
        console.log(`\u5728\u884C ${currentLine} \u627E\u5230\u65E0\u7A7A\u683C\u683C\u5F0F\u8868\u683CID: ${id}`);
        return id;
      }
      if (line.trim() !== "" && !line.trim().startsWith("<!--") && !line.trim().startsWith("//")) {
        console.log(`\u5728\u884C ${currentLine} \u9047\u5230\u975E\u7A7A\u975E\u6CE8\u91CA\u884C\uFF0C\u505C\u6B62\u641C\u7D22`);
        break;
      }
      currentLine--;
    }
    console.log("\u672A\u627E\u5230\u8868\u683CID");
    return void 0;
  }
  /**
   * Markdown
   * @param lines 
   * @returns 
   */
  isValidTable(lines) {
    if (lines.length < 2)
      return false;
    const firstLine = lines[0].trim();
    if (!firstLine.startsWith("|") || !firstLine.endsWith("|"))
      return false;
    const secondLine = lines[1].trim();
    if (!secondLine.startsWith("|") || !secondLine.endsWith("|"))
      return false;
    const separatorCells = secondLine.split("|").slice(1, -1);
    for (const cell of separatorCells) {
      const trimmedCell = cell.trim();
      if (!trimmedCell.match(/^:?-+:?$/)) {
        return false;
      }
    }
    for (let i = 2; i < lines.length; i++) {
      const line = lines[i].trim();
      if (!line.startsWith("|") || !line.endsWith("|")) {
        return false;
      }
    }
    return true;
  }
  /**
   * MarkdownID
   * @returns IDnull
   */
  async addTableIdToMarkdown() {
    try {
      const editor = this.getActiveEditor();
      if (!editor) {
        new import_obsidian7.Notice("\u672A\u627E\u5230\u6D3B\u52A8\u7F16\u8F91\u5668");
        return null;
      }
      const tableInfo = this.locateTableInMarkdown(editor);
      if (!tableInfo) {
        new import_obsidian7.Notice("\u672A\u627E\u5230\u8868\u683C\uFF0C\u8BF7\u5C06\u5149\u6807\u653E\u5728\u8868\u683C\u5185");
        return null;
      }
      const tableId = this.checkExistingTableId(editor, tableInfo.startLine);
      if (tableId) {
        new import_obsidian7.Notice(`\u8868\u683C\u5DF2\u6709ID: ${tableId}`);
        return tableId;
      }
      const newTableId = this.generateUniqueTableId();
      console.log(`\u4E3A\u8868\u683C\u6DFB\u52A0\u65B0ID: ${newTableId}, \u8868\u683C\u8D77\u59CB\u884C: ${tableInfo.startLine}`);
      let insertPosition = { line: tableInfo.startLine, ch: 0 };
      let insertContent = `<!-- table-id: ${newTableId} -->
`;
      if (tableInfo.startLine > 0) {
        const prevLine = editor.getLine(tableInfo.startLine - 1);
        if (prevLine && prevLine.trim() !== "") {
          insertContent = `
<!-- table-id: ${newTableId} -->
`;
        }
      }
      editor.replaceRange(insertContent, insertPosition);
      this.saveTableInfo(newTableId, tableInfo);
      console.log(`\u5DF2\u4E3A\u8868\u683C\u6DFB\u52A0ID: ${newTableId}`);
      new import_obsidian7.Notice(`\u5DF2\u4E3A\u8868\u683C\u6DFB\u52A0ID: ${newTableId}`);
      return newTableId;
    } catch (error) {
      console.error("\u6DFB\u52A0\u8868\u683CID\u65F6\u51FA\u9519:", error);
      return null;
    }
  }
  /**
   * 
   * @param tableId ID
   * @param tableInfo 
   */
  saveTableInfo(tableId, tableInfo) {
    try {
      const activeView = this.getApp().workspace.getActiveViewOfType(import_obsidian7.MarkdownView);
      if (!activeView || !activeView.file)
        return;
      const filePath = activeView.file.path;
      const { rows, hasHeader } = this.parseTableStructure(tableInfo.content);
      const tableData = {
        id: tableId,
        locations: [
          {
            path: filePath,
            isActive: true
          }
        ],
        structure: {
          rowCount: rows.length,
          colCount: rows.length > 0 ? rows[0].length : 0,
          hasHeaders: hasHeader
        },
        styling: {
          rowHeights: Array(rows.length).fill("auto"),
          colWidths: rows.length > 0 ? Array(rows[0].length).fill("auto") : [],
          alignment: rows.length > 0 ? Array(rows[0].length).fill("left") : []
        }
      };
      this.plugin.saveTableData(tableData);
    } catch (error) {
      console.error("\u4FDD\u5B58\u8868\u683C\u4FE1\u606F\u65F6\u51FA\u9519:", error);
    }
  }
  /**
   * ID
   * @param editor 
   * @param tableLine 
   * @returns IDnull
   */
  checkExistingTableId(editor, tableLine) {
    if (tableLine <= 0)
      return null;
    console.log(`\u68C0\u67E5\u8868\u683C\u662F\u5426\u5DF2\u6709ID: \u8868\u683C\u8D77\u59CB\u884C=${tableLine}`);
    const maxLinesToCheck = 10;
    let currentLine = tableLine - 1;
    const minLine = Math.max(0, tableLine - maxLinesToCheck);
    while (currentLine >= minLine) {
      const line = editor.getLine(currentLine);
      if (!line)
        break;
      console.log(`\u68C0\u67E5\u884C ${currentLine}: "${line}"`);
      const standardIdMatch = line.match(/<!--\s*table-id:\s*([a-zA-Z0-9_\-:.]+)\s*-->/i);
      if (standardIdMatch && standardIdMatch[1]) {
        const id = standardIdMatch[1];
        console.log(`\u5728\u884C ${currentLine} \u627E\u5230\u6807\u51C6\u683C\u5F0F\u8868\u683CID: ${id}`);
        return id;
      }
      const noHyphenIdMatch = line.match(/<!--\s*tableid:\s*([a-zA-Z0-9_\-:.]+)\s*-->/i);
      if (noHyphenIdMatch && noHyphenIdMatch[1]) {
        const id = noHyphenIdMatch[1];
        console.log(`\u5728\u884C ${currentLine} \u627E\u5230\u65E0\u8FDE\u5B57\u7B26\u683C\u5F0F\u8868\u683CID: ${id}`);
        return id;
      }
      const simpleIdMatch = line.match(/<!--\s*id:\s*([a-zA-Z0-9_\-:.]+)\s*-->/i);
      if (simpleIdMatch && simpleIdMatch[1]) {
        const id = simpleIdMatch[1];
        console.log(`\u5728\u884C ${currentLine} \u627E\u5230\u7B80\u5316\u683C\u5F0F\u8868\u683CID: ${id}`);
        return id;
      }
      const tableNameIdMatch = line.match(/<!--\s*(table|tbl):\s*([a-zA-Z0-9_\-:.]+)\s*-->/i);
      if (tableNameIdMatch && tableNameIdMatch[2]) {
        const id = tableNameIdMatch[2];
        console.log(`\u5728\u884C ${currentLine} \u627E\u5230\u8868\u683C\u540D\u79F0\u683C\u5F0FID: ${id}`);
        return id;
      }
      const noSpaceIdMatch = line.match(/<!--table-id:([a-zA-Z0-9_\-:.]+)-->/i);
      if (noSpaceIdMatch && noSpaceIdMatch[1]) {
        const id = noSpaceIdMatch[1];
        console.log(`\u5728\u884C ${currentLine} \u627E\u5230\u65E0\u7A7A\u683C\u683C\u5F0F\u8868\u683CID: ${id}`);
        return id;
      }
      if (line.trim() !== "" && !line.trim().startsWith("<!--") && !line.trim().startsWith("//")) {
        console.log(`\u5728\u884C ${currentLine} \u9047\u5230\u975E\u7A7A\u975E\u6CE8\u91CA\u884C\uFF0C\u505C\u6B62\u641C\u7D22`);
        break;
      }
      currentLine--;
    }
    console.log("\u672A\u627E\u5230\u8868\u683CID");
    return null;
  }
  /**
   * ID
   * @returns ID
   */
  generateUniqueTableId() {
    const prefix = this.plugin.settings.idPrefix || "tbl";
    const timestamp = new Date().toISOString().slice(0, 10).replace(/-/g, "");
    const randomId = Math.random().toString(36).substring(2, 8);
    return `${prefix}-${timestamp}-${randomId}`;
  }
  /**
   * 
   * @param tableContent 
   * @returns 
   */
  parseTableStructure(tableContent) {
    const lines = tableContent.split("\n");
    const rows = [];
    let hasHeader = false;
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i].trim();
      if (!line.startsWith("|"))
        continue;
      if (line.includes("-") && i === 1) {
        hasHeader = true;
        continue;
      }
      const cells = line.split("|").filter((cell, index, array) => index > 0 && index < array.length - 1).map((cell) => cell.trim());
      rows.push(cells);
    }
    return { rows, hasHeader };
  }
  /**
   * 
   * @param tableRows 
   * @param rowIndex 
   * @param colIndex 
   * @returns 
   */
  getCellContent(tableRows, rowIndex, colIndex) {
    if (rowIndex >= 0 && rowIndex < tableRows.length && colIndex >= 0 && colIndex < tableRows[rowIndex].length) {
      return tableRows[rowIndex][colIndex];
    }
    return "";
  }
  /**
   * 
   * @param editor 
   * @param tableInfo 
   * @param rowIndex 
   * @param colIndex 
   * @param content 
   */
  setCellContent(editor, tableInfo, rowIndex, colIndex, content) {
    try {
      const lineIndex = tableInfo.startLine + rowIndex;
      if (lineIndex > tableInfo.endLine)
        return;
      const line = editor.getLine(lineIndex);
      if (!line)
        return;
      const cells = line.split("|");
      if (colIndex + 1 >= cells.length - 1)
        return;
      cells[colIndex + 1] = ` ${content} `;
      editor.replaceRange(
        cells.join("|"),
        { line: lineIndex, ch: 0 },
        { line: lineIndex, ch: line.length }
      );
    } catch (error) {
      console.error("\u8BBE\u7F6E\u5355\u5143\u683C\u5185\u5BB9\u65F6\u51FA\u9519:", error);
    }
  }
  /**
   * 
   * @param direction  ('right'  'down')
   */
  async mergeCells(direction) {
    try {
      console.log(`\u5C1D\u8BD5${direction === "right" ? "\u5411\u53F3" : "\u5411\u4E0B"}\u5408\u5E76\u5355\u5143\u683C`);
      const editor = this.getActiveEditor();
      if (!editor) {
        console.log("\u672A\u627E\u5230\u6D3B\u52A8\u7F16\u8F91\u5668");
        new import_obsidian7.Notice("\u672A\u627E\u5230\u6D3B\u52A8\u7F16\u8F91\u5668");
        return false;
      }
      const cellPosition = this.getCellPosition(editor);
      if (!cellPosition) {
        console.log("\u672A\u627E\u5230\u8868\u683C\u6216\u65E0\u6CD5\u786E\u5B9A\u5355\u5143\u683C\u4F4D\u7F6E");
        new import_obsidian7.Notice("\u672A\u627E\u5230\u8868\u683C\u6216\u65E0\u6CD5\u786E\u5B9A\u5355\u5143\u683C\u4F4D\u7F6E\uFF0C\u8BF7\u5C06\u5149\u6807\u653E\u5728\u8868\u683C\u5185");
        return false;
      }
      const { tableInfo, rowIndex, colIndex } = cellPosition;
      console.log(`\u51C6\u5907${direction === "right" ? "\u5411\u53F3" : "\u5411\u4E0B"}\u5408\u5E76\u5355\u5143\u683C: \u884C=${rowIndex}, \u5217=${colIndex}`);
      let result = false;
      if (direction === "right") {
        result = await this.mergeCellsRight(editor, tableInfo, rowIndex, colIndex);
      } else if (direction === "down") {
        result = await this.mergeCellsDown(editor, tableInfo, rowIndex, colIndex);
      }
      if (result) {
        console.log(`${direction === "right" ? "\u5411\u53F3" : "\u5411\u4E0B"}\u5408\u5E76\u5355\u5143\u683C\u6210\u529F`);
      } else {
        console.log(`${direction === "right" ? "\u5411\u53F3" : "\u5411\u4E0B"}\u5408\u5E76\u5355\u5143\u683C\u5931\u8D25`);
      }
      return result;
    } catch (error) {
      console.error(`\u5408\u5E76\u5355\u5143\u683C\u65F6\u51FA\u9519(${direction}):`, error);
      new import_obsidian7.Notice(`\u5408\u5E76\u5355\u5143\u683C\u5931\u8D25: ${error.message || "\u672A\u77E5\u9519\u8BEF"}`);
      return false;
    }
  }
  /**
   * 
   * @param line 
   * @param cursorCh 
   * @returns -1
   */
  getCursorColumnIndex(line, cursorCh) {
    try {
      if (!line.trim().startsWith("|") || !line.trim().endsWith("|")) {
        console.log("\u884C\u4E0D\u662F\u6709\u6548\u7684\u8868\u683C\u884C:", line);
        return -1;
      }
      const cells = line.split("|");
      if (cells[0].trim() === "")
        cells.shift();
      if (cells[cells.length - 1].trim() === "")
        cells.pop();
      let currentPos = line.indexOf("|");
      for (let i = 0; i < cells.length; i++) {
        const cellWidth = cells[i].length + 1;
        const nextPos = currentPos + cellWidth;
        console.log(`\u68C0\u67E5\u5355\u5143\u683C ${i}: \u8303\u56F4=${currentPos}-${nextPos}, \u5185\u5BB9="${cells[i]}"`);
        if (cursorCh > currentPos && cursorCh <= nextPos) {
          console.log(`\u5149\u6807\u5728\u5355\u5143\u683C ${i} \u5185: \u4F4D\u7F6E=${cursorCh}`);
          return i;
        }
        currentPos = nextPos;
      }
      console.log(`\u672A\u627E\u5230\u5149\u6807\u6240\u5728\u5355\u5143\u683C: cursorCh=${cursorCh}, line="${line}"`);
      return -1;
    } catch (error) {
      console.error("\u83B7\u53D6\u5149\u6807\u6240\u5728\u5217\u7D22\u5F15\u65F6\u51FA\u9519:", error);
      return -1;
    }
  }
  /**
   * 
   * @param editor 
   * @returns null
   */
  getCellPosition(editor) {
    try {
      const tableInfo = this.locateTableInMarkdown(editor);
      if (!tableInfo) {
        console.log("\u672A\u627E\u5230\u8868\u683C");
        return null;
      }
      const cursor = editor.getCursor();
      const rowIndex = cursor.line - tableInfo.startLine;
      if (rowIndex < 0 || rowIndex > tableInfo.endLine - tableInfo.startLine) {
        console.log(`\u884C\u7D22\u5F15\u8D85\u51FA\u8303\u56F4: rowIndex=${rowIndex}, tableRange=${tableInfo.startLine}-${tableInfo.endLine}`);
        return null;
      }
      const line = editor.getLine(cursor.line);
      if (!line) {
        console.log("\u65E0\u6CD5\u83B7\u53D6\u884C\u5185\u5BB9");
        return null;
      }
      if (!line.trim().startsWith("|") || !line.trim().endsWith("|")) {
        console.log("\u5F53\u524D\u884C\u4E0D\u662F\u6709\u6548\u7684\u8868\u683C\u884C");
        return null;
      }
      const colIndex = this.getCursorColumnIndex(line, cursor.ch);
      if (colIndex === -1) {
        console.log("\u65E0\u6CD5\u786E\u5B9A\u5149\u6807\u6240\u5728\u5217");
        return null;
      }
      console.log(`\u6210\u529F\u83B7\u53D6\u5355\u5143\u683C\u4F4D\u7F6E: \u884C=${rowIndex}, \u5217=${colIndex}, \u8868\u683C\u8303\u56F4=${tableInfo.startLine}-${tableInfo.endLine}`);
      return {
        tableInfo,
        rowIndex,
        colIndex
      };
    } catch (error) {
      console.error("\u83B7\u53D6\u5355\u5143\u683C\u4F4D\u7F6E\u4FE1\u606F\u65F6\u51FA\u9519:", error);
      return null;
    }
  }
  /**
   * 
   * @param editor 
   * @param tableInfo 
   * @param rowIndex 
   * @param colIndex 
   * @param mergeCount 0
   * @returns 
   */
  async mergeCellsRight(editor, tableInfo, rowIndex, colIndex, mergeCount = 0) {
    try {
      const lineIndex = tableInfo.startLine + rowIndex;
      const line = editor.getLine(lineIndex);
      if (!line) {
        console.log(`\u65E0\u6CD5\u83B7\u53D6\u884C\u5185\u5BB9: lineIndex=${lineIndex}`);
        return false;
      }
      console.log(`\u5C1D\u8BD5\u5411\u53F3\u5408\u5E76\u5355\u5143\u683C: \u884C=${lineIndex}, \u5217=${colIndex}, \u5DF2\u5408\u5E76=${mergeCount}, \u884C\u5185\u5BB9="${line}"`);
      const cells = line.split("|");
      if (colIndex + 2 >= cells.length) {
        console.log(`\u5217\u7D22\u5F15\u8D85\u51FA\u8303\u56F4: colIndex=${colIndex}, cells.length=${cells.length}`);
        new import_obsidian7.Notice("\u53F3\u4FA7\u6CA1\u6709\u5355\u5143\u683C\u53EF\u5408\u5E76");
        return false;
      }
      const mainContent = cells[colIndex + 1].trim();
      const targetContent = cells[colIndex + 2].trim();
      console.log(`\u4E3B\u5355\u5143\u683C\u5185\u5BB9="${mainContent}", \u76EE\u6807\u5355\u5143\u683C\u5185\u5BB9="${targetContent}"`);
      const isMergeMarker = /^(<+|\^+|\\<|\\^|\s*<+\s*|\s*\^+\s*)$/.test(targetContent);
      console.log(`\u76EE\u6807\u5355\u5143\u683C\u662F\u5426\u4E3A\u5408\u5E76\u6807\u8BB0: ${isMergeMarker}`);
      let mergeAction = "replace";
      if (targetContent && !isMergeMarker) {
        if (this.plugin.settings.confirmMergeNonEmpty) {
          mergeAction = await this.showMergeCellOptionsDialog(mainContent, targetContent);
          console.log(`\u7528\u6237\u9009\u62E9\u7684\u5408\u5E76\u64CD\u4F5C: ${mergeAction}`);
          if (mergeAction === "cancel") {
            console.log("\u7528\u6237\u53D6\u6D88\u4E86\u5408\u5E76\u64CD\u4F5C");
            return false;
          }
        }
      }
      if (mergeAction === "merge" && mainContent && targetContent && !isMergeMarker) {
        cells[colIndex + 1] = ` ${mainContent} ${targetContent} `;
        console.log(`\u5408\u5E76\u5185\u5BB9: \u65B0\u4E3B\u5355\u5143\u683C\u5185\u5BB9="${cells[colIndex + 1]}"`);
      }
      const mergeDistance = mergeCount + 1;
      const mergeMarker = "<".repeat(mergeDistance);
      console.log(`\u751F\u6210\u5408\u5E76\u6807\u8BB0: \u8DDD\u79BB=${mergeDistance}, \u6807\u8BB0="${mergeMarker}"`);
      cells[colIndex + 2] = ` ${mergeMarker} `;
      const newLine = cells.join("|");
      console.log(`\u65B0\u884C\u5185\u5BB9="${newLine}"`);
      editor.replaceRange(
        newLine,
        { line: lineIndex, ch: 0 },
        { line: lineIndex, ch: line.length }
      );
      if (colIndex + 3 < cells.length) {
        const nextCellContent = cells[colIndex + 3].trim();
        console.log(`\u68C0\u67E5\u4E0B\u4E00\u4E2A\u5355\u5143\u683C\u662F\u5426\u4E3A\u5408\u5E76\u6807\u8BB0: \u5185\u5BB9="${nextCellContent}"`);
        if (/^(<+|\^+|\\<|\\^|\s*<+\s*|\s*\^+\s*)$/.test(nextCellContent)) {
          console.log("\u68C0\u6D4B\u5230\u53F3\u4FA7\u6709\u8FDE\u7EED\u5408\u5E76\u5355\u5143\u683C\uFF0C\u7EE7\u7EED\u5408\u5E76");
          await this.mergeCellsRight(editor, tableInfo, rowIndex, colIndex + 1, mergeDistance);
        }
      }
      new import_obsidian7.Notice("\u5DF2\u5411\u53F3\u5408\u5E76\u5355\u5143\u683C");
      return true;
    } catch (error) {
      console.error("\u5411\u53F3\u5408\u5E76\u5355\u5143\u683C\u65F6\u51FA\u9519:", error);
      new import_obsidian7.Notice(`\u5411\u53F3\u5408\u5E76\u5355\u5143\u683C\u5931\u8D25: ${error.message || "\u672A\u77E5\u9519\u8BEF"}`);
      return false;
    }
  }
  /**
   * 
   * @param editor 
   * @param tableInfo 
   * @param rowIndex 
   * @param colIndex 
   * @param mergeCount 0
   * @returns 
   */
  async mergeCellsDown(editor, tableInfo, rowIndex, colIndex, mergeCount = 0) {
    try {
      const currentLineIndex = tableInfo.startLine + rowIndex;
      const nextLineIndex = currentLineIndex + 1;
      if (nextLineIndex > tableInfo.endLine) {
        console.log(`\u4E0B\u4E00\u884C\u8D85\u51FA\u8868\u683C\u8303\u56F4: nextLineIndex=${nextLineIndex}, tableEndLine=${tableInfo.endLine}`);
        new import_obsidian7.Notice("\u4E0B\u65B9\u6CA1\u6709\u5355\u5143\u683C\u53EF\u5408\u5E76");
        return false;
      }
      const currentLine = editor.getLine(currentLineIndex);
      const nextLine = editor.getLine(nextLineIndex);
      if (!currentLine || !nextLine) {
        console.log(`\u65E0\u6CD5\u83B7\u53D6\u884C\u5185\u5BB9: currentLine=${!!currentLine}, nextLine=${!!nextLine}`);
        return false;
      }
      console.log(`\u5C1D\u8BD5\u5411\u4E0B\u5408\u5E76\u5355\u5143\u683C: \u5F53\u524D\u884C=${currentLineIndex}, \u4E0B\u4E00\u884C=${nextLineIndex}, \u5217=${colIndex}, \u5DF2\u5408\u5E76=${mergeCount}`);
      console.log(`\u5F53\u524D\u884C\u5185\u5BB9="${currentLine}"`);
      console.log(`\u4E0B\u4E00\u884C\u5185\u5BB9="${nextLine}"`);
      const currentCells = currentLine.split("|");
      const nextCells = nextLine.split("|");
      if (colIndex + 1 >= currentCells.length || colIndex + 1 >= nextCells.length) {
        console.log(`\u5217\u7D22\u5F15\u8D85\u51FA\u8303\u56F4: colIndex=${colIndex}, currentCells.length=${currentCells.length}, nextCells.length=${nextCells.length}`);
        new import_obsidian7.Notice("\u65E0\u6CD5\u5408\u5E76\u5355\u5143\u683C\uFF0C\u5217\u7D22\u5F15\u8D85\u51FA\u8303\u56F4");
        return false;
      }
      const mainContent = currentCells[colIndex + 1].trim();
      const targetContent = nextCells[colIndex + 1].trim();
      console.log(`\u4E3B\u5355\u5143\u683C\u5185\u5BB9="${mainContent}", \u76EE\u6807\u5355\u5143\u683C\u5185\u5BB9="${targetContent}"`);
      const isMergeMarker = /^(<+|\^+|\\<|\\^|\s*<+\s*|\s*\^+\s*)$/.test(targetContent);
      console.log(`\u76EE\u6807\u5355\u5143\u683C\u662F\u5426\u4E3A\u5408\u5E76\u6807\u8BB0: ${isMergeMarker}`);
      let mergeAction = "replace";
      if (targetContent && !isMergeMarker) {
        if (this.plugin.settings.confirmMergeNonEmpty) {
          mergeAction = await this.showMergeCellOptionsDialog(mainContent, targetContent);
          console.log(`\u7528\u6237\u9009\u62E9\u7684\u5408\u5E76\u64CD\u4F5C: ${mergeAction}`);
          if (mergeAction === "cancel") {
            console.log("\u7528\u6237\u53D6\u6D88\u4E86\u5408\u5E76\u64CD\u4F5C");
            return false;
          }
        }
      }
      if (mergeAction === "merge" && mainContent && targetContent && !isMergeMarker) {
        currentCells[colIndex + 1] = ` ${mainContent} ${targetContent} `;
        console.log(`\u5408\u5E76\u5185\u5BB9: \u65B0\u4E3B\u5355\u5143\u683C\u5185\u5BB9="${currentCells[colIndex + 1]}"`);
        editor.replaceRange(
          currentCells.join("|"),
          { line: currentLineIndex, ch: 0 },
          { line: currentLineIndex, ch: currentLine.length }
        );
      }
      const mergeDistance = mergeCount + 1;
      const mergeMarker = "^".repeat(mergeDistance);
      console.log(`\u751F\u6210\u5408\u5E76\u6807\u8BB0: \u8DDD\u79BB=${mergeDistance}, \u6807\u8BB0="${mergeMarker}"`);
      nextCells[colIndex + 1] = ` ${mergeMarker} `;
      const newNextLine = nextCells.join("|");
      console.log(`\u65B0\u4E0B\u4E00\u884C\u5185\u5BB9="${newNextLine}"`);
      editor.replaceRange(
        newNextLine,
        { line: nextLineIndex, ch: 0 },
        { line: nextLineIndex, ch: nextLine.length }
      );
      if (nextLineIndex + 1 <= tableInfo.endLine) {
        const nextNextLine = editor.getLine(nextLineIndex + 1);
        if (nextNextLine) {
          const nextNextCells = nextNextLine.split("|");
          if (colIndex + 1 < nextNextCells.length) {
            const nextNextCellContent = nextNextCells[colIndex + 1].trim();
            console.log(`\u68C0\u67E5\u4E0B\u4E00\u884C\u5355\u5143\u683C\u662F\u5426\u4E3A\u5408\u5E76\u6807\u8BB0: \u5185\u5BB9="${nextNextCellContent}"`);
            if (/^(<+|\^+|\\<|\\^|\s*<+\s*|\s*\^+\s*)$/.test(nextNextCellContent)) {
              console.log("\u68C0\u6D4B\u5230\u4E0B\u65B9\u6709\u8FDE\u7EED\u5408\u5E76\u5355\u5143\u683C\uFF0C\u7EE7\u7EED\u5408\u5E76");
              await this.mergeCellsDown(editor, tableInfo, rowIndex + 1, colIndex, mergeDistance);
            }
          }
        }
      }
      new import_obsidian7.Notice("\u5DF2\u5411\u4E0B\u5408\u5E76\u5355\u5143\u683C");
      return true;
    } catch (error) {
      console.error("\u5411\u4E0B\u5408\u5E76\u5355\u5143\u683C\u65F6\u51FA\u9519:", error);
      new import_obsidian7.Notice(`\u5411\u4E0B\u5408\u5E76\u5355\u5143\u683C\u5931\u8D25: ${error.message || "\u672A\u77E5\u9519\u8BEF"}`);
      return false;
    }
  }
  /**
   * 
   * @param message 
   * @returns 
   */
  async showConfirmDialog(message) {
    return new Promise((resolve) => {
      const notice = new import_obsidian7.Notice(message, 0);
      const buttonContainer = document.createElement("div");
      buttonContainer.style.display = "flex";
      buttonContainer.style.justifyContent = "space-between";
      buttonContainer.style.marginTop = "10px";
      const cancelButton = document.createElement("button");
      cancelButton.textContent = "\u53D6\u6D88";
      cancelButton.onclick = () => {
        notice.hide();
        resolve(false);
      };
      const confirmButton = document.createElement("button");
      confirmButton.textContent = "\u786E\u5B9A";
      confirmButton.style.marginLeft = "10px";
      confirmButton.onclick = () => {
        notice.hide();
        resolve(true);
      };
      buttonContainer.appendChild(cancelButton);
      buttonContainer.appendChild(confirmButton);
      notice.noticeEl.appendChild(buttonContainer);
    });
  }
  /**
   * 
   * @param mainContent 
   * @param targetContent 
   * @returns 'merge'=, 'replace'=, 'cancel'=
   */
  async showMergeCellOptionsDialog(mainContent, targetContent) {
    return new Promise((resolve) => {
      const notice = new import_obsidian7.Notice("\u5408\u5E76\u5355\u5143\u683C\u9009\u9879", 0);
      const contentContainer = document.createElement("div");
      contentContainer.style.marginBottom = "10px";
      contentContainer.innerHTML = `
                <p>\u76EE\u6807\u5355\u5143\u683C\u5305\u542B\u5185\u5BB9\uFF1A"${targetContent}"</p>
                <p>\u8BF7\u9009\u62E9\u5408\u5E76\u65B9\u5F0F\uFF1A</p>
            `;
      const buttonContainer = document.createElement("div");
      buttonContainer.style.display = "flex";
      buttonContainer.style.flexDirection = "column";
      buttonContainer.style.gap = "5px";
      const mergeButton = document.createElement("button");
      mergeButton.textContent = "\u5408\u5E76\u5E76\u4FDD\u7559\u5185\u5BB9";
      mergeButton.onclick = () => {
        notice.hide();
        resolve("merge");
      };
      const replaceButton = document.createElement("button");
      replaceButton.textContent = "\u4EC5\u4F7F\u7528\u5408\u5E76\u6807\u8BB0";
      replaceButton.onclick = () => {
        notice.hide();
        resolve("replace");
      };
      const cancelButton = document.createElement("button");
      cancelButton.textContent = "\u53D6\u6D88";
      cancelButton.onclick = () => {
        notice.hide();
        resolve("cancel");
      };
      buttonContainer.appendChild(mergeButton);
      buttonContainer.appendChild(replaceButton);
      buttonContainer.appendChild(cancelButton);
      notice.noticeEl.appendChild(contentContainer);
      notice.noticeEl.appendChild(buttonContainer);
    });
  }
  /**
   * 
   * @returns 
   */
  async detectAndFixMergeMarkers() {
    try {
      const editor = this.getActiveEditor();
      if (!editor) {
        new import_obsidian7.Notice("\u672A\u627E\u5230\u6D3B\u52A8\u7F16\u8F91\u5668");
        return false;
      }
      const tableInfo = this.locateTableInMarkdown(editor);
      if (!tableInfo) {
        new import_obsidian7.Notice("\u672A\u627E\u5230\u8868\u683C\uFF0C\u8BF7\u5C06\u5149\u6807\u653E\u5728\u8868\u683C\u5185");
        return false;
      }
      let hasFixedMarkers = false;
      for (let i = tableInfo.startLine; i <= tableInfo.endLine; i++) {
        const line = editor.getLine(i);
        if (!line)
          continue;
        const cells = line.split("|");
        let hasChanges = false;
        for (let j = 1; j < cells.length - 1; j++) {
          const cell = cells[j];
          const trimmedCell = cell.trim();
          if (trimmedCell === "\\<" || trimmedCell === "<") {
            cells[j] = " < ";
            hasChanges = true;
          } else if (trimmedCell === "\\^" || trimmedCell === "^") {
            cells[j] = " ^ ";
            hasChanges = true;
          }
        }
        if (hasChanges) {
          const updatedLine = cells.join("|");
          editor.replaceRange(
            updatedLine,
            { line: i, ch: 0 },
            { line: i, ch: line.length }
          );
          hasFixedMarkers = true;
        }
      }
      if (hasFixedMarkers) {
        new import_obsidian7.Notice("\u5DF2\u7EDF\u4E00\u8868\u683C\u5408\u5E76\u6807\u8BB0\u683C\u5F0F");
      } else {
        new import_obsidian7.Notice("\u672A\u53D1\u73B0\u9700\u8981\u4FEE\u590D\u7684\u5408\u5E76\u6807\u8BB0");
      }
      return hasFixedMarkers;
    } catch (error) {
      console.error("\u68C0\u6D4B\u548C\u4FEE\u590D\u8868\u683C\u5408\u5E76\u6807\u8BB0\u65F6\u51FA\u9519:", error);
      return false;
    }
  }
  /**
   * 
   * @returns 
   */
  async splitMergedCells() {
    try {
      const editor = this.getActiveEditor();
      if (!editor) {
        new import_obsidian7.Notice("\u672A\u627E\u5230\u6D3B\u52A8\u7F16\u8F91\u5668");
        return false;
      }
      const cellPosition = this.getCellPosition(editor);
      if (!cellPosition) {
        new import_obsidian7.Notice("\u672A\u627E\u5230\u8868\u683C\u6216\u65E0\u6CD5\u786E\u5B9A\u5355\u5143\u683C\u4F4D\u7F6E\uFF0C\u8BF7\u5C06\u5149\u6807\u653E\u5728\u8868\u683C\u5185");
        return false;
      }
      const { tableInfo, rowIndex, colIndex } = cellPosition;
      const lineIndex = tableInfo.startLine + rowIndex;
      console.log(`\u5C1D\u8BD5\u62C6\u5206\u5355\u5143\u683C: \u884C=${rowIndex}, \u5217=${colIndex}, \u8868\u683C\u8303\u56F4=${tableInfo.startLine}-${tableInfo.endLine}`);
      const line = editor.getLine(lineIndex);
      if (!line)
        return false;
      let hasSplitCells = false;
      if (colIndex + 1 < line.split("|").length - 1) {
        const cells = line.split("|");
        const rightCell = cells[colIndex + 2];
        const rightCellTrimmed = rightCell.trim();
        console.log(`\u53F3\u4FA7\u5355\u5143\u683C\u5185\u5BB9: "${rightCellTrimmed}"`);
        if (/^(<+|\^+|\\<|\\^|\s*<+\s*|\s*\^+\s*)$/.test(rightCellTrimmed)) {
          cells[colIndex + 2] = "  ";
          editor.replaceRange(
            cells.join("|"),
            { line: lineIndex, ch: 0 },
            { line: lineIndex, ch: line.length }
          );
          console.log("\u5DF2\u62C6\u5206\u53F3\u4FA7\u5408\u5E76\u5355\u5143\u683C");
          hasSplitCells = true;
        }
      }
      if (lineIndex < tableInfo.endLine) {
        const belowLine = editor.getLine(lineIndex + 1);
        if (belowLine) {
          const belowCells = belowLine.split("|");
          if (colIndex + 1 < belowCells.length) {
            const belowCell = belowCells[colIndex + 1];
            const belowCellTrimmed = belowCell.trim();
            console.log(`\u4E0B\u65B9\u5355\u5143\u683C\u5185\u5BB9: "${belowCellTrimmed}"`);
            if (/^(<+|\^+|\\<|\\^|\s*<+\s*|\s*\^+\s*)$/.test(belowCellTrimmed)) {
              belowCells[colIndex + 1] = "  ";
              editor.replaceRange(
                belowCells.join("|"),
                { line: lineIndex + 1, ch: 0 },
                { line: lineIndex + 1, ch: belowLine.length }
              );
              console.log("\u5DF2\u62C6\u5206\u4E0B\u65B9\u5408\u5E76\u5355\u5143\u683C");
              hasSplitCells = true;
            }
          }
        }
      }
      const recursiveSplit = await this.recursiveSplitMergedCells(editor, tableInfo, rowIndex, colIndex);
      if (recursiveSplit) {
        hasSplitCells = true;
      }
      if (hasSplitCells) {
        new import_obsidian7.Notice("\u5DF2\u6210\u529F\u62C6\u5206\u5408\u5E76\u5355\u5143\u683C");
        return true;
      } else {
        new import_obsidian7.Notice("\u672A\u627E\u5230\u53EF\u62C6\u5206\u7684\u5408\u5E76\u5355\u5143\u683C\uFF0C\u8BF7\u786E\u4FDD\u5149\u6807\u4F4D\u4E8E\u5408\u5E76\u5355\u5143\u683C\u5185");
        return false;
      }
    } catch (error) {
      console.error("\u62C6\u5206\u5408\u5E76\u5355\u5143\u683C\u65F6\u51FA\u9519:", error);
      new import_obsidian7.Notice(`\u62C6\u5206\u5408\u5E76\u5355\u5143\u683C\u5931\u8D25: ${error.message || "\u672A\u77E5\u9519\u8BEF"}`);
      return false;
    }
  }
  /**
   * 
   * 
   * @param editor 
   * @param tableInfo 
   * @param rowIndex 
   * @param colIndex 
   * @returns 
   */
  async recursiveSplitMergedCells(editor, tableInfo, rowIndex, colIndex) {
    let hasSplitCells = false;
    const maxSearchDepth = 10;
    for (let col = colIndex + 1; col < colIndex + maxSearchDepth; col++) {
      const lineIndex = tableInfo.startLine + rowIndex;
      const line = editor.getLine(lineIndex);
      if (!line)
        break;
      const cells = line.split("|");
      if (col + 1 >= cells.length)
        break;
      const cellContent = cells[col + 1].trim();
      if (/^(<+|\^+|\\<|\\^|\s*<+\s*|\s*\^+\s*)$/.test(cellContent)) {
        cells[col + 1] = "  ";
        editor.replaceRange(
          cells.join("|"),
          { line: lineIndex, ch: 0 },
          { line: lineIndex, ch: line.length }
        );
        hasSplitCells = true;
        console.log(`\u5DF2\u62C6\u5206\u4F4D\u4E8E (${rowIndex}, ${col}) \u7684\u6C34\u5E73\u5408\u5E76\u5355\u5143\u683C`);
      } else {
        break;
      }
    }
    for (let row = rowIndex + 1; row < rowIndex + maxSearchDepth && row + tableInfo.startLine <= tableInfo.endLine; row++) {
      const lineIndex = tableInfo.startLine + row;
      const line = editor.getLine(lineIndex);
      if (!line)
        break;
      const cells = line.split("|");
      if (colIndex + 1 >= cells.length)
        break;
      const cellContent = cells[colIndex + 1].trim();
      if (/^(<+|\^+|\\<|\\^|\s*<+\s*|\s*\^+\s*)$/.test(cellContent)) {
        cells[colIndex + 1] = "  ";
        editor.replaceRange(
          cells.join("|"),
          { line: lineIndex, ch: 0 },
          { line: lineIndex, ch: line.length }
        );
        hasSplitCells = true;
        console.log(`\u5DF2\u62C6\u5206\u4F4D\u4E8E (${row}, ${colIndex}) \u7684\u5782\u76F4\u5408\u5E76\u5355\u5143\u683C`);
      } else {
        break;
      }
    }
    return hasSplitCells;
  }
  /**
   * ID
   * @returns IDnull
   */
  async getCurrentTableId() {
    try {
      const editor = this.getActiveEditor();
      if (!editor) {
        console.warn("\u672A\u627E\u5230\u6D3B\u52A8\u7F16\u8F91\u5668");
        return null;
      }
      const tableInfo = this.locateTableInMarkdown(editor);
      if (!tableInfo) {
        console.warn("\u672A\u627E\u5230\u8868\u683C\uFF0C\u8BF7\u5C06\u5149\u6807\u653E\u5728\u8868\u683C\u5185");
        return null;
      }
      let tableId = tableInfo.tableId;
      if (!tableId) {
        console.log("\u5728tableInfo\u4E2D\u672A\u627E\u5230ID\uFF0C\u5C1D\u8BD5\u4F7F\u7528checkExistingTableId\u67E5\u627E");
        tableId = this.checkExistingTableId(editor, tableInfo.startLine) || void 0;
      }
      if (tableId) {
        console.log(`\u627E\u5230\u8868\u683CID: ${tableId}`);
        return tableId;
      }
      console.warn("\u672A\u627E\u5230\u8868\u683CID");
      return null;
    } catch (error) {
      console.error("\u83B7\u53D6\u5F53\u524D\u8868\u683CID\u65F6\u51FA\u9519:", error);
      return null;
    }
  }
};

// src/icons.ts
var import_obsidian8 = require("obsidian");
function loadIcons() {
  (0, import_obsidian8.addIcon)("align-left", `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100" width="100" height="100">
        <rect x="15" y="15" width="70" height="70" fill="none" stroke="currentColor" stroke-width="2" stroke-opacity="0.3"/>
        <path d="M25,30 L75,30 M25,50 L60,50 M25,70 L70,70" stroke="currentColor" stroke-width="3"/>
    </svg>`);
  (0, import_obsidian8.addIcon)("align-center", `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100" width="100" height="100">
        <rect x="15" y="15" width="70" height="70" fill="none" stroke="currentColor" stroke-width="2" stroke-opacity="0.3"/>
        <path d="M25,30 L75,30 M35,50 L65,50 M30,70 L70,70" stroke="currentColor" stroke-width="3"/>
    </svg>`);
  (0, import_obsidian8.addIcon)("align-right", `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100" width="100" height="100">
        <rect x="15" y="15" width="70" height="70" fill="none" stroke="currentColor" stroke-width="2" stroke-opacity="0.3"/>
        <path d="M25,30 L75,30 M40,50 L75,50 M30,70 L75,70" stroke="currentColor" stroke-width="3"/>
    </svg>`);
  (0, import_obsidian8.addIcon)("align-top", `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100" width="100" height="100">
        <rect x="15" y="15" width="70" height="70" fill="none" stroke="currentColor" stroke-width="2" stroke-opacity="0.3"/>
        <path d="M30,25 L30,75 M50,25 L50,60 M70,25 L70,70" stroke="currentColor" stroke-width="3"/>
    </svg>`);
  (0, import_obsidian8.addIcon)("align-middle", `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100" width="100" height="100">
        <rect x="15" y="15" width="70" height="70" fill="none" stroke="currentColor" stroke-width="2" stroke-opacity="0.3"/>
        <path d="M30,25 L30,75 M50,35 L50,65 M70,30 L70,70" stroke="currentColor" stroke-width="3"/>
    </svg>`);
  (0, import_obsidian8.addIcon)("align-bottom", `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100" width="100" height="100">
        <rect x="15" y="15" width="70" height="70" fill="none" stroke="currentColor" stroke-width="2" stroke-opacity="0.3"/>
        <path d="M30,25 L30,75 M50,40 L50,75 M70,30 L70,75" stroke="currentColor" stroke-width="3"/>
    </svg>`);
  (0, import_obsidian8.addIcon)("align-all", `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100" width="100" height="100">
        <rect x="20" y="20" width="60" height="60" fill="none" stroke="currentColor" stroke-width="3"/>
        <circle cx="50" cy="50" r="15" fill="none" stroke="currentColor" stroke-width="3"/>
    </svg>`);
  (0, import_obsidian8.addIcon)("merge-cells", `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100" width="100" height="100">
        <rect x="10" y="10" width="30" height="30" fill="none" stroke="currentColor" stroke-width="3"/>
        <rect x="60" y="10" width="30" height="30" fill="none" stroke="currentColor" stroke-width="3"/>
        <rect x="10" y="60" width="30" height="30" fill="none" stroke="currentColor" stroke-width="3"/>
        <rect x="60" y="60" width="30" height="30" fill="none" stroke="currentColor" stroke-width="3"/>
        <path d="M50,45 L50,55 M45,50 L55,50" stroke="currentColor" stroke-width="3"/>
    </svg>`);
  (0, import_obsidian8.addIcon)("merge-right", `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100" width="100" height="100">
        <rect x="15" y="30" width="30" height="40" fill="none" stroke="currentColor" stroke-width="3"/>
        <rect x="55" y="30" width="30" height="40" fill="none" stroke="currentColor" stroke-width="3"/>
        <path d="M45,50 L55,50 M50,45 L55,50 L50,55" stroke="currentColor" stroke-width="3"/>
    </svg>`);
  (0, import_obsidian8.addIcon)("merge-down", `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100" width="100" height="100">
        <rect x="30" y="15" width="40" height="30" fill="none" stroke="currentColor" stroke-width="3"/>
        <rect x="30" y="55" width="40" height="30" fill="none" stroke="currentColor" stroke-width="3"/>
        <path d="M50,45 L50,55 M45,50 L50,55 L55,50" stroke="currentColor" stroke-width="3"/>
    </svg>`);
  (0, import_obsidian8.addIcon)("split", `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100" width="100" height="100">
        <rect x="20" y="20" width="60" height="60" fill="none" stroke="currentColor" stroke-width="3"/>
        <path d="M50,20 L50,80 M20,50 L80,50" stroke="currentColor" stroke-width="3"/>
    </svg>`);
  (0, import_obsidian8.addIcon)("table-id", `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100" width="100" height="100">
        <rect x="20" y="30" width="60" height="50" fill="none" stroke="currentColor" stroke-width="3"/>
        <path d="M20,30 L80,30" stroke="currentColor" stroke-width="5"/>
        <rect x="35" y="15" width="30" height="15" fill="none" stroke="currentColor" stroke-width="2"/>
        <path d="M45,45 L45,65 M55,45 L55,65 M45,55 L55,55" stroke="currentColor" stroke-width="2"/>
    </svg>`);
  (0, import_obsidian8.addIcon)("table-row-add", `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100" width="100" height="100">
        <rect x="20" y="20" width="60" height="60" fill="none" stroke="currentColor" stroke-width="3"/>
        <path d="M20,50 L80,50" stroke="currentColor" stroke-width="3"/>
        <circle cx="85" cy="50" r="10" fill="none" stroke="currentColor" stroke-width="2"/>
        <path d="M85,45 L85,55 M80,50 L90,50" stroke="currentColor" stroke-width="2"/>
    </svg>`);
  (0, import_obsidian8.addIcon)("table-style", `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100" width="100" height="100">
        <rect x="20" y="20" width="60" height="60" fill="none" stroke="currentColor" stroke-width="3"/>
        <path d="M20,40 L80,40 M20,60 L80,60 M40,20 L40,80 M60,20 L60,80" stroke="currentColor" stroke-width="2"/>
        <path d="M65,25 L75,35 M65,35 L75,25" stroke="currentColor" stroke-width="2"/>
        <path d="M25,45 L35,55 M35,45 L25,55" stroke="currentColor" stroke-width="2"/>
        <circle cx="50" cy="50" r="5" fill="currentColor"/>
    </svg>`);
  (0, import_obsidian8.addIcon)("table-toolbar-toggle", `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100" width="100" height="100">
        <rect x="15" y="15" width="70" height="70" fill="none" stroke="currentColor" stroke-width="3"/>
        <path d="M15,35 L85,35 M15,65 L85,65" stroke="currentColor" stroke-width="2"/>
        <path d="M35,15 L35,85 M65,15 L65,85" stroke="currentColor" stroke-width="2"/>
        <rect x="40" y="5" width="20" height="10" fill="currentColor"/>
        <rect x="40" y="85" width="20" height="10" fill="currentColor"/>
        <rect x="5" y="40" width="10" height="20" fill="currentColor"/>
        <rect x="85" y="40" width="10" height="20" fill="currentColor"/>
    </svg>`);
  (0, import_obsidian8.addIcon)("table-edit-mode", `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100" width="100" height="100">
        <rect x="15" y="25" width="70" height="50" fill="none" stroke="currentColor" stroke-width="3"/>
        <path d="M15,45 L85,45" stroke="currentColor" stroke-width="2"/>
        <path d="M35,25 L35,75" stroke="currentColor" stroke-width="2"/>
        <path d="M55,25 L55,75" stroke="currentColor" stroke-width="2"/>
        <path d="M75,10 L90,25 L80,35 L65,20 Z" fill="none" stroke="currentColor" stroke-width="2"/>
        <path d="M65,20 L80,35" stroke="currentColor" stroke-width="2"/>
    </svg>`);
}

// src/tableStyleRenderer.ts
var import_obsidian9 = require("obsidian");
var TableStyleRenderer = class extends import_obsidian9.MarkdownRenderChild {
  /**
   * 
   * @param el 
   * @param tableId ID
   * @param styling 
   * @param plugin 
   */
  constructor(el, tableId, styling, plugin) {
    super(el);
    this.tableId = tableId;
    this.styling = styling;
    this.plugin = plugin;
  }
  /**
   * app
   */
  getApp() {
    return this.plugin.app;
  }
  /**
   * 
   */
  onload() {
    console.log(`\u8868\u683C\u6837\u5F0F\u6E32\u67D3\u5668\u52A0\u8F7D: \u8868\u683CID=${this.tableId}`);
    this.applyStyles();
    this.containerEl.classList.add(`table-${this.tableId}`);
    this.containerEl.setAttribute("data-table-styles-applied", "true");
  }
  /**
   * 
   */
  applyStyles() {
    if (!this.styling)
      return;
    if (this.styling.alignment && Array.isArray(this.styling.alignment)) {
      this.applyColumnAlignment(this.styling.alignment);
    }
    if (this.styling.cellStyles && Array.isArray(this.styling.cellStyles)) {
      this.applyCellStyles(this.styling.cellStyles);
    }
    if (this.styling.rowHeights && Array.isArray(this.styling.rowHeights)) {
      this.applyRowHeights(this.styling.rowHeights);
    }
    if (this.styling.colWidths && Array.isArray(this.styling.colWidths)) {
      this.applyColumnWidths(this.styling.colWidths);
    }
  }
  /**
   * 
   * @param alignments 
   */
  applyColumnAlignment(alignments) {
    const rows = this.containerEl.querySelectorAll("tr");
    rows.forEach((row) => {
      const cells = row.querySelectorAll("td, th");
      cells.forEach((cell, colIndex) => {
        if (alignments[colIndex]) {
          cell.style.textAlign = alignments[colIndex];
        }
      });
    });
  }
  /**
   * 
   * @param cellStyles 
   */
  applyCellStyles(cellStyles) {
    cellStyles.forEach((style) => {
      if (typeof style.row !== "number" || typeof style.col !== "number") {
        return;
      }
      const cell = this.findCell(style.row, style.col);
      if (!cell)
        return;
      if (style.textAlign)
        cell.style.textAlign = style.textAlign;
      if (style.verticalAlign)
        cell.style.verticalAlign = style.verticalAlign;
      if (style.backgroundColor)
        cell.style.backgroundColor = style.backgroundColor;
      if (style.color)
        cell.style.color = style.color;
      if (style.fontWeight)
        cell.style.fontWeight = style.fontWeight;
      if (style.fontStyle)
        cell.style.fontStyle = style.fontStyle;
    });
  }
  /**
   * 
   * @param heights 
   */
  applyRowHeights(heights) {
    console.log(`\u5E94\u7528\u884C\u9AD8: ${JSON.stringify(heights)}`);
    const rows = this.containerEl.querySelectorAll("tr");
    rows.forEach((row, rowIndex) => {
      if (rowIndex < heights.length && heights[rowIndex] && heights[rowIndex] !== "auto") {
        row.style.height = heights[rowIndex];
        console.log(`\u8BBE\u7F6E\u7B2C${rowIndex + 1}\u884C\u9AD8\u5EA6: ${heights[rowIndex]}`);
      }
    });
  }
  /**
   * 
   * @param widths 
   */
  applyColumnWidths(widths) {
    console.log(`\u5E94\u7528\u5217\u5BBD: ${JSON.stringify(widths)}`);
    let colgroup = this.containerEl.querySelector("colgroup");
    if (!colgroup) {
      colgroup = document.createElement("colgroup");
      this.containerEl.prepend(colgroup);
    } else {
      colgroup.innerHTML = "";
    }
    widths.forEach((width, index) => {
      const col = document.createElement("col");
      if (width && width !== "auto") {
        col.style.width = width;
        console.log(`\u8BBE\u7F6E\u7B2C${index + 1}\u5217\u5BBD\u5EA6: ${width}`);
      }
      if (colgroup) {
        colgroup.appendChild(col);
      }
    });
  }
  /**
   * 
   * @param rowIndex 
   * @param colIndex 
   * @returns null
   */
  findCell(rowIndex, colIndex) {
    const rows = this.containerEl.querySelectorAll("tr");
    if (!rows || rows.length <= rowIndex)
      return null;
    const cells = rows[rowIndex].querySelectorAll("td, th");
    if (!cells || cells.length <= colIndex)
      return null;
    return cells[colIndex];
  }
  /**
   * 
   */
  onunload() {
    console.log(`\u8868\u683C ${this.tableId} \u7684\u6837\u5F0F\u6E32\u67D3\u5668\u5DF2\u5378\u8F7D`);
  }
  /**
   * 
   */
  async applyTableStyles(tableElement, tableId) {
    var _a;
    try {
      if (tableElement.getAttribute("data-table-styles-applied") === "true") {
        return;
      }
      const data = await this.plugin.loadData();
      const tableData = (_a = data == null ? void 0 : data.tables) == null ? void 0 : _a[tableId];
      if (!tableData || !tableData.styling) {
        console.log(`\u6CA1\u6709\u627E\u5230\u5339\u914D\u7684\u8868\u683C\u6837\u5F0F\u6570\u636E\uFF1A${tableId}`);
        return;
      }
      console.log(`\u5E94\u7528\u8868\u683C\u6837\u5F0F - ID=${tableId}`, tableData.styling);
      if (tableData.styling.rowHeights && tableData.styling.rowHeights.length > 0) {
        const rows = tableElement.querySelectorAll("tr");
        tableData.styling.rowHeights.forEach((height, index) => {
          if (index < rows.length && height && height !== "auto") {
            rows[index].style.height = height;
            console.log(`\u5E94\u7528\u884C\u9AD8 - \u7D22\u5F15=${index}, \u9AD8\u5EA6=${height}`);
          }
        });
      }
      if (tableData.styling.colWidths && tableData.styling.colWidths.length > 0) {
        let colgroup = tableElement.querySelector("colgroup");
        if (!colgroup) {
          colgroup = document.createElement("colgroup");
          tableElement.insertBefore(colgroup, tableElement.firstChild);
        } else {
          colgroup.innerHTML = "";
        }
        tableData.styling.colWidths.forEach((width, index) => {
          const col = document.createElement("col");
          if (width && width !== "auto") {
            col.style.width = width;
            console.log(`\u5E94\u7528\u5217\u5BBD - \u7D22\u5F15=${index}, \u5BBD\u5EA6=${width}`);
          }
          if (colgroup) {
            colgroup.appendChild(col);
          }
        });
      }
      if (tableData.styling.alignment && tableData.styling.alignment.length > 0) {
        const rows = tableElement.querySelectorAll("tr");
        rows.forEach((row) => {
          const cells = row.querySelectorAll("th, td");
          cells.forEach((cell, cellIndex) => {
            if (cellIndex < tableData.styling.alignment.length) {
              const alignment = tableData.styling.alignment[cellIndex];
              if (alignment) {
                cell.style.textAlign = alignment;
              }
            }
          });
        });
      }
      if (tableData.styling.cellStyles && tableData.styling.cellStyles.length > 0) {
        tableData.styling.cellStyles.forEach((cellStyle) => {
          if (cellStyle.row !== void 0 && cellStyle.col !== void 0) {
            const rows = tableElement.querySelectorAll("tr");
            if (cellStyle.row < rows.length) {
              const row = rows[cellStyle.row];
              const cells = row.querySelectorAll("th, td");
              if (cellStyle.col < cells.length) {
                const cell = cells[cellStyle.col];
                if (cellStyle.backgroundColor) {
                  cell.style.backgroundColor = cellStyle.backgroundColor;
                }
                if (cellStyle.textColor) {
                  cell.style.color = cellStyle.textColor;
                }
                if (cellStyle.fontWeight) {
                  cell.style.fontWeight = cellStyle.fontWeight;
                }
                if (cellStyle.fontStyle) {
                  cell.style.fontStyle = cellStyle.fontStyle;
                }
              }
            }
          }
        });
      }
      tableElement.setAttribute("data-table-styles-applied", "true");
      tableElement.classList.add(`table-${tableId}`);
      console.log(`\u8868\u683C\u6837\u5F0F\u5E94\u7528\u5B8C\u6210 - ID=${tableId}`);
    } catch (error) {
      console.error("\u5E94\u7528\u8868\u683C\u6837\u5F0F\u65F6\u51FA\u9519:", error);
    }
  }
  /**
   * 
   */
  async applyPreviewModeStyles(containerEl) {
    try {
      console.log("\u9884\u89C8\u6A21\u5F0F\u6FC0\u6D3B\uFF0C\u5F00\u59CB\u5E94\u7528\u4FDD\u5B58\u7684\u8868\u683C\u6837\u5F0F");
      const tables = Array.from(containerEl.querySelectorAll("table")).filter((table) => {
        const isInCodeBlock = table.closest("pre") !== null || table.closest("code") !== null;
        return !isInCodeBlock;
      });
      console.log(`\u627E\u5230 ${tables.length} \u4E2A\u8868\u683C\u9700\u8981\u5E94\u7528\u6837\u5F0F`);
      if (!tables.length)
        return;
      const activeFile = this.getApp().workspace.getActiveFile();
      if (!activeFile) {
        console.log("\u672A\u627E\u5230\u6D3B\u52A8\u6587\u4EF6");
        return;
      }
      const content = await this.getApp().vault.read(activeFile);
      const tableInfos = this.plugin.tableIdManager.extractTableIdsFromMarkdown(content);
      console.log(`\u4ECE\u6587\u4EF6\u4E2D\u63D0\u53D6\u7684\u8868\u683C\u4FE1\u606F: ${tableInfos.length} \u4E2A\u8868\u683CID`);
      for (let index = 0; index < tables.length; index++) {
        const tableElement = tables[index];
        let tableId = tableElement.getAttribute("data-table-id");
        if (!tableId) {
          tableId = this.plugin.tableIdManager.getTableIdFromComment(tableElement);
          if (!tableId && index < tableInfos.length && tables.length === tableInfos.length) {
            tableId = tableInfos[index].id;
            if (tableId) {
              console.log(`\u901A\u8FC7\u4F4D\u7F6E\u5339\u914D\u627E\u5230\u8868\u683CID: ${tableId}`);
              tableElement.setAttribute("data-table-id", tableId);
            }
          }
          if (!tableId) {
            const tableFeature = this.plugin.tableIdManager.extractTableFeature(tableElement);
            let bestMatchId = "";
            let bestMatchScore = 0;
            for (const info of tableInfos) {
              const { id, feature } = info;
              if (!id)
                continue;
              const score = this.plugin.tableIdManager.calculateFeatureSimilarity(tableFeature, feature);
              console.log(`\u8868\u683CID ${id} \u7684\u7279\u5F81\u76F8\u4F3C\u5EA6: ${score.toFixed(2)}`);
              if (score > bestMatchScore) {
                bestMatchScore = score;
                bestMatchId = id;
              }
            }
            if (bestMatchId && bestMatchScore > 0.7) {
              console.log(`\u901A\u8FC7\u7279\u5F81\u76F8\u4F3C\u5EA6\u5339\u914D\u627E\u5230\u8868\u683CID: ${bestMatchId}\uFF08\u76F8\u4F3C\u5EA6: ${bestMatchScore.toFixed(2)}\uFF09`);
              tableId = bestMatchId;
              tableElement.setAttribute("data-table-id", tableId);
            }
          }
        }
        if (tableId) {
          console.log(`\u4E3A\u8868\u683C\u5E94\u7528\u6837\u5F0F - \u7D22\u5F15=${index}, ID=${tableId}`);
          await this.applyTableStyles(tableElement, tableId);
        } else {
          console.log(`\u65E0\u6CD5\u4E3A\u8868\u683C\u5E94\u7528\u6837\u5F0F - \u7D22\u5F15=${index}, \u672A\u627E\u5230ID`);
        }
      }
    } catch (error) {
      console.error("\u5E94\u7528\u9884\u89C8\u6A21\u5F0F\u8868\u683C\u6837\u5F0F\u65F6\u51FA\u9519:", error);
    }
  }
};
async function renderTablesWithStoredStyles(plugin) {
  var _a;
  function getApp() {
    return plugin.app;
  }
  try {
    console.log("\u5F00\u59CB\u6E32\u67D3\u8868\u683C\u6837\u5F0F");
    const activeView = getApp().workspace.getActiveViewOfType(import_obsidian9.MarkdownView);
    if (!activeView) {
      console.log("\u672A\u627E\u5230\u6D3B\u52A8\u89C6\u56FE\uFF0C\u65E0\u6CD5\u6E32\u67D3\u8868\u683C\u6837\u5F0F");
      return;
    }
    const activeFile = activeView.file;
    if (!activeFile) {
      console.log("\u672A\u627E\u5230\u6D3B\u52A8\u6587\u4EF6\uFF0C\u65E0\u6CD5\u6E32\u67D3\u8868\u683C\u6837\u5F0F");
      return;
    }
    const filePath = activeFile.path;
    console.log(`\u5F53\u524D\u6587\u4EF6\u8DEF\u5F84: ${filePath}`);
    let tables = {};
    if (plugin.tableDataExtractor) {
      tables = await plugin.tableDataExtractor.extractTableDataFromFile(activeFile);
      console.log(`\u4ECEMarkdown\u6587\u4EF6\u4E2D\u63D0\u53D6\u5230 ${Object.keys(tables).length} \u4E2A\u8868\u683C\u6570\u636E`);
    }
    if (Object.keys(tables).length === 0) {
      console.log("\u4ECEMarkdown\u6587\u4EF6\u4E2D\u672A\u63D0\u53D6\u5230\u8868\u683C\u6570\u636E\uFF0C\u5C1D\u8BD5\u4ECEdata.json\u83B7\u53D6");
      const pluginData = await plugin.loadData() || {};
      tables = pluginData.tables || {};
      if (!tables || Object.keys(tables).length === 0) {
        console.log("\u6CA1\u6709\u5B58\u50A8\u7684\u8868\u683C\u6570\u636E");
        return;
      }
    }
    const allTables = Array.from(document.querySelectorAll("table")).filter((table) => {
      const isInCodeBlock = table.closest("pre") !== null || table.closest("code") !== null;
      return !isInCodeBlock;
    });
    if (!allTables.length) {
      console.log("\u5F53\u524D\u6587\u4EF6\u4E2D\u6CA1\u6709\u8868\u683C");
      return;
    }
    console.log(`\u5F53\u524D\u6587\u4EF6\u4E2D\u6709 ${allTables.length} \u4E2A\u8868\u683C`);
    const renderQueue = [];
    const fileContent = await plugin.app.vault.read(activeFile);
    const tableInfos = plugin.tableIdManager.extractTableIdsFromMarkdown(fileContent);
    console.log(`\u4ECE\u6587\u4EF6\u5185\u5BB9\u4E2D\u63D0\u53D6\u5230 ${tableInfos.length} \u4E2A\u8868\u683C\u4FE1\u606F`);
    for (let i = 0; i < allTables.length; i++) {
      const table = allTables[i];
      let tableId = table.getAttribute("data-table-id");
      if (!tableId && i < tableInfos.length && allTables.length === tableInfos.length) {
        tableId = tableInfos[i].id;
        if (tableId) {
          console.log(`\u901A\u8FC7\u4F4D\u7F6E\u5339\u914D\u627E\u5230\u8868\u683CID: ${tableId}`);
          table.setAttribute("data-table-id", tableId);
        }
      }
      if (!tableId) {
        const tableFeature = plugin.tableIdManager.extractTableFeature(table);
        let bestMatchId = "";
        let bestMatchScore = 0;
        let matchedIndex = -1;
        for (let j = 0; j < tableInfos.length; j++) {
          const { id, feature } = tableInfos[j];
          if (!id)
            continue;
          const score = plugin.tableIdManager.calculateFeatureSimilarity(tableFeature, feature);
          console.log(`\u8868\u683CID ${id} \u7684\u7279\u5F81\u76F8\u4F3C\u5EA6: ${score.toFixed(2)}`);
          if (score > bestMatchScore) {
            bestMatchScore = score;
            bestMatchId = id;
            matchedIndex = j;
          }
        }
        if (bestMatchId && bestMatchScore > 0.7) {
          console.log(`\u901A\u8FC7\u7279\u5F81\u76F8\u4F3C\u5EA6\u5339\u914D\u627E\u5230\u8868\u683CID: ${bestMatchId}\uFF08\u76F8\u4F3C\u5EA6: ${bestMatchScore.toFixed(2)}\uFF09`);
          tableId = bestMatchId;
          table.setAttribute("data-table-id", tableId);
          if (matchedIndex >= 0) {
            tableInfos.splice(matchedIndex, 1);
          }
        }
      }
      if (tableId && tables[tableId]) {
        const tableData = tables[tableId];
        const isInCurrentFile = (_a = tableData.locations) == null ? void 0 : _a.some((loc) => loc.path === filePath);
        if (isInCurrentFile) {
          console.log(`\u4E3A\u8868\u683C ${tableId} \u6DFB\u52A0\u6E32\u67D3\u4EFB\u52A1`);
          renderQueue.push({
            table,
            tableId,
            tableData
          });
        }
      }
    }
    if (renderQueue.length > 0) {
      console.log(`\u5F00\u59CB\u5904\u7406 ${renderQueue.length} \u4E2A\u8868\u683C\u6E32\u67D3\u4EFB\u52A1`);
      await processRenderQueue(renderQueue, plugin);
    } else {
      console.log("\u6CA1\u6709\u9700\u8981\u6E32\u67D3\u7684\u8868\u683C");
    }
  } catch (error) {
    console.error("\u6E32\u67D3\u8868\u683C\u6837\u5F0F\u65F6\u51FA\u9519:", error);
  }
}
async function processRenderQueue(queue, plugin) {
  const batchSize = 3;
  let processedCount = 0;
  let successCount = 0;
  console.log(`\u5F00\u59CB\u5904\u7406\u6E32\u67D3\u961F\u5217\uFF0C\u5171 ${queue.length} \u4E2A\u8868\u683C`);
  const processBatch = async () => {
    try {
      const endIndex = Math.min(processedCount + batchSize, queue.length);
      for (let i = processedCount; i < endIndex; i++) {
        const { table, tableId, tableData } = queue[i];
        console.log(`\u5904\u7406\u961F\u5217\u4E2D\u7684\u8868\u683C ${i + 1}/${queue.length} - ID=${tableId}`);
        try {
          const success = await renderTableWithStyles(table, tableId, tableData, plugin);
          if (success) {
            successCount++;
          }
        } catch (error) {
          console.error(`\u5904\u7406\u8868\u683C ${tableId} \u65F6\u51FA\u9519:`, error);
        }
      }
      processedCount = endIndex;
      if (processedCount < queue.length) {
        return new Promise((resolve) => {
          window.requestAnimationFrame(() => {
            processBatch().then(resolve);
          });
        });
      }
    } catch (error) {
      console.error("\u5904\u7406\u8868\u683C\u6279\u6B21\u65F6\u51FA\u9519:", error);
    }
  };
  await processBatch();
  console.log(`\u5B8C\u6210\u4E86 ${processedCount} \u4E2A\u8868\u683C\u7684\u5904\u7406\uFF0C\u6210\u529F\u5E94\u7528\u6837\u5F0F: ${successCount}`);
}
async function renderTableWithStyles(table, tableId, tableData, plugin) {
  try {
    console.log(`\u5F00\u59CB\u4E3A\u8868\u683C ${tableId} \u5E94\u7528\u6837\u5F0F`);
    if (table.getAttribute("data-table-styles-applied") === "true") {
      console.log(`\u8868\u683C ${tableId} \u5DF2\u7ECF\u5E94\u7528\u4E86\u6837\u5F0F\uFF0C\u8DF3\u8FC7`);
      return true;
    }
    if (!tableData.styling) {
      console.log(`\u8868\u683C ${tableId} \u6CA1\u6709\u6709\u6548\u7684\u6837\u5F0F\u6570\u636E`);
      return false;
    }
    const ctx = getContextForTable(table, plugin);
    if (ctx) {
      try {
        ctx.addChild(new TableStyleRenderer(table, tableId, tableData.styling, plugin));
        console.log(`\u8868\u683C ${tableId} \u5DF2\u4F7F\u7528RenderChild\u5E94\u7528\u6837\u5F0F`);
      } catch (error) {
        console.error(`\u4F7F\u7528RenderChild\u5E94\u7528\u6837\u5F0F\u65F6\u51FA\u9519:`, error);
        applyStylesDirectly(table, tableData.styling);
        console.log(`\u8868\u683C ${tableId} \u56DE\u9000\u5230\u76F4\u63A5\u5E94\u7528\u6837\u5F0F`);
      }
    } else {
      applyStylesDirectly(table, tableData.styling);
      console.log(`\u8868\u683C ${tableId} \u5DF2\u76F4\u63A5\u5E94\u7528\u6837\u5F0F`);
    }
    table.setAttribute("data-table-styles-applied", "true");
    if (!table.classList.contains(`table-${tableId}`)) {
      table.classList.add(`table-${tableId}`);
    }
    console.log(`\u8868\u683C ${tableId} \u6837\u5F0F\u5E94\u7528\u5B8C\u6210`);
    return true;
  } catch (error) {
    console.error(`\u4E3A\u8868\u683C ${tableId} \u5E94\u7528\u6837\u5F0F\u65F6\u51FA\u9519:`, error);
    return false;
  }
}
function getContextForTable(table, plugin) {
  var _a, _b, _c;
  const activeView = plugin.app.workspace.getActiveViewOfType(import_obsidian9.MarkdownView);
  if (!activeView || activeView.getMode() !== "preview")
    return null;
  try {
    const sectionEl = table.closest("[data-section-id]");
    if (sectionEl) {
      const sectionId = sectionEl.getAttribute("data-section-id");
      if (sectionId && activeView.previewMode) {
        const sections = (_a = activeView.previewMode.renderer) == null ? void 0 : _a.sections;
        if (sections && sections[sectionId]) {
          return sections[sectionId];
        }
      }
    }
    if (activeView.previewMode) {
      const sectionInfo = (_c = (_b = activeView.previewMode.renderer) == null ? void 0 : _b.getSectionInfo) == null ? void 0 : _c.call(_b, table);
      if (sectionInfo && sectionInfo.section) {
        return sectionInfo.section;
      }
    }
    return null;
  } catch (e) {
    console.warn("\u83B7\u53D6\u8868\u683C\u6E32\u67D3\u4E0A\u4E0B\u6587\u5931\u8D25:", e);
    return null;
  }
}
function applyStylesDirectly(table, styling) {
  if (!styling)
    return;
  if (styling.rowHeights && Array.isArray(styling.rowHeights)) {
    const rows = table.querySelectorAll("tr");
    styling.rowHeights.forEach((height, index) => {
      if (index < rows.length && height && height !== "auto") {
        rows[index].style.height = height;
        console.log(`\u76F4\u63A5\u5E94\u7528\u884C\u9AD8 - \u7D22\u5F15=${index}, \u9AD8\u5EA6=${height}`);
      }
    });
  }
  if (styling.colWidths && Array.isArray(styling.colWidths)) {
    let colgroup = table.querySelector("colgroup");
    if (!colgroup) {
      colgroup = document.createElement("colgroup");
      table.insertBefore(colgroup, table.firstChild);
    } else {
      colgroup.innerHTML = "";
    }
    styling.colWidths.forEach((width, index) => {
      const col = document.createElement("col");
      if (width && width !== "auto") {
        col.style.width = width;
        console.log(`\u76F4\u63A5\u5E94\u7528\u5217\u5BBD - \u7D22\u5F15=${index}, \u5BBD\u5EA6=${width}`);
      }
      if (colgroup) {
        colgroup.appendChild(col);
      }
    });
  }
  if (styling.alignment && Array.isArray(styling.alignment)) {
    const rows = table.querySelectorAll("tr");
    rows.forEach((row) => {
      const cells = row.querySelectorAll("td, th");
      cells.forEach((cell, colIndex) => {
        if (styling.alignment[colIndex]) {
          cell.style.textAlign = styling.alignment[colIndex];
        }
      });
    });
  }
  if (styling.cellStyles && Array.isArray(styling.cellStyles)) {
    styling.cellStyles.forEach((style) => {
      if (typeof style.row !== "number" || typeof style.col !== "number") {
        return;
      }
      const rows = table.querySelectorAll("tr");
      if (!rows || rows.length <= style.row)
        return;
      const cells = rows[style.row].querySelectorAll("td, th");
      if (!cells || cells.length <= style.col)
        return;
      const cell = cells[style.col];
      if (style.textAlign)
        cell.style.textAlign = style.textAlign;
      if (style.verticalAlign)
        cell.style.verticalAlign = style.verticalAlign;
      if (style.backgroundColor)
        cell.style.backgroundColor = style.backgroundColor;
      if (style.color)
        cell.style.color = style.color;
      if (style.fontWeight)
        cell.style.fontWeight = style.fontWeight;
      if (style.fontStyle)
        cell.style.fontStyle = style.fontStyle;
    });
  }
  const tableId = table.getAttribute("data-table-id");
  if (tableId) {
    table.classList.add(`table-${tableId}`);
  }
}

// src/setupPreviewModeTableSelection.ts
function findMergeMarkers(table) {
  var _a;
  const cells = table.querySelectorAll("td, th");
  for (const cell of Array.from(cells)) {
    const content = ((_a = cell.textContent) == null ? void 0 : _a.trim()) || "";
    if (content === "^" || content === "<") {
      return true;
    }
  }
  return false;
}
function setupPreviewModeTableSelection(plugin) {
  try {
    plugin.currentEditingTable = null;
    const tables = Array.from(document.querySelectorAll("table")).filter((table) => {
      const isInCodeBlock = table.closest("pre") !== null || table.closest("code") !== null;
      return !isInCodeBlock;
    });
    if (!tables.length)
      return;
    console.log(`\u9884\u89C8\u6A21\u5F0F\u4E0B\u627E\u5230 ${tables.length} \u4E2A\u8868\u683C`);
    tables.forEach((table, index) => {
      table.removeEventListener("click", plugin.handleTableClick);
      table.addEventListener("click", plugin.handleTableClick);
      plugin.tableDetector.setupTableIndices(table);
      table.setAttribute("data-table-index", index.toString());
      const tableFeature = plugin.tableIdManager.extractTableFeature(table);
      if (tableFeature) {
        table.setAttribute("data-table-feature", JSON.stringify(tableFeature));
        table.setAttribute("data-rows", tableFeature.rows.toString());
        table.setAttribute("data-cols", tableFeature.cols.toString());
        if (tableFeature.position) {
          table.setAttribute("data-table-position", JSON.stringify(tableFeature.position));
        }
      }
      plugin.readTableIdFromMarkdown(table).then((tableId) => {
        if (tableId) {
          table.setAttribute("data-table-id", tableId);
          console.log(`\u8868\u683CID\u5DF2\u8BBE\u7F6E: ${tableId}`);
          if (tableFeature) {
            tableFeature.id = tableId;
            table.setAttribute("data-table-feature", JSON.stringify(tableFeature));
          }
        }
      }).catch((error) => {
        console.error("\u8BFB\u53D6\u8868\u683CID\u65F6\u51FA\u9519:", error);
      });
      if (plugin.settings.enableCellMerging !== false) {
        if (table.dataset.tableMergeProcessed !== "true") {
          const hasMergeMarkers = findMergeMarkers(table);
          if (hasMergeMarkers) {
            console.log(`\u8868\u683C\u5305\u542B\u5408\u5E76\u6807\u8BB0\uFF0C\u5E94\u7528\u5408\u5E76\u5355\u5143\u683C\u6E32\u67D3`);
            plugin.tableDetector.applyMergeCellsMarkers(table);
          }
        }
      }
    });
    renderTablesWithStoredStyles(plugin);
    console.log("\u9884\u89C8\u6A21\u5F0F\u4E0B\u8BBE\u7F6E\u4E86\u8868\u683C\u9009\u62E9");
  } catch (error) {
    console.error("\u8BBE\u7F6E\u9884\u89C8\u6A21\u5F0F\u8868\u683C\u9009\u62E9\u65F6\u51FA\u9519:", error);
  }
}

// src/tableResizer.ts
var TableResizer = class {
  /**
   * 
   * @param plugin 
   */
  constructor(plugin) {
    this.activeTable = null;
    this.resizeHandles = [];
    this.isResizing = false;
    this.currentHandle = null;
    this.startX = 0;
    this.startY = 0;
    this.startWidth = 0;
    this.startHeight = 0;
    this.columnIndex = -1;
    this.tableWidth = 0;
    this.targetIndex = -1;
    this.resizeType = "column";
    this.resizeGuide = null;
    this.plugin = plugin;
    console.log("TableResizer: \u521D\u59CB\u5316\u8868\u683C\u5927\u5C0F\u8C03\u6574\u5668");
  }
  // app
  getApp() {
    return this.plugin.app;
  }
  /**
   * 
   * @param table 
   */
  setupTableResize(table) {
    try {
      console.log("TableResizer: \u4E3A\u8868\u683C\u8BBE\u7F6E\u5927\u5C0F\u8C03\u6574\u529F\u80FD");
      this.removeResizeHandles();
      this.activeTable = table;
      this.addResizeHandles(table);
      console.log("TableResizer: \u8868\u683C\u5927\u5C0F\u8C03\u6574\u529F\u80FD\u8BBE\u7F6E\u5B8C\u6210");
    } catch (error) {
      console.error("TableResizer: \u8BBE\u7F6E\u8868\u683C\u5927\u5C0F\u8C03\u6574\u529F\u80FD\u65F6\u51FA\u9519:", error);
    }
  }
  /**
   * 
   * @param table 
   */
  addResizeHandles(table) {
    console.log("TableResizer: \u6DFB\u52A0\u62D6\u62FD\u53E5\u67C4");
    table.style.position = "relative";
    const rows = table.querySelectorAll("tr");
    if (rows.length === 0) {
      console.warn("TableResizer: \u8868\u683C\u6CA1\u6709\u884C");
      return;
    }
    const firstRowCells = rows[0].querySelectorAll("th, td");
    if (firstRowCells.length === 0) {
      console.warn("TableResizer: \u8868\u683C\u7B2C\u4E00\u884C\u6CA1\u6709\u5355\u5143\u683C");
      return;
    }
    console.log(`TableResizer: \u8868\u683C\u6709 ${rows.length} \u884C, ${firstRowCells.length} \u5217`);
    for (let i = 0; i < firstRowCells.length - 1; i++) {
      const cell = firstRowCells[i];
      const nextCell = firstRowCells[i + 1];
      const cellRect = cell.getBoundingClientRect();
      const tableRect = table.getBoundingClientRect();
      const handleLeft = cell.offsetLeft + cell.offsetWidth;
      const colHandle = document.createElement("div");
      colHandle.className = "table-resize-handle-col";
      colHandle.style.position = "absolute";
      colHandle.style.top = "0";
      colHandle.style.left = `${handleLeft}px`;
      colHandle.style.width = "5px";
      colHandle.style.height = "100%";
      colHandle.style.cursor = "col-resize";
      colHandle.style.zIndex = "100";
      colHandle.dataset.index = i.toString();
      colHandle.dataset.type = "column";
      console.log(`TableResizer: \u6DFB\u52A0\u5217\u62D6\u62FD\u53E5\u67C4 - \u7D22\u5F15=${i}, \u4F4D\u7F6E=${handleLeft}px`);
      this.addHandleEventListeners(colHandle);
      table.appendChild(colHandle);
      this.resizeHandles.push(colHandle);
    }
    for (let i = 0; i < rows.length - 1; i++) {
      const row = rows[i];
      const nextRow = rows[i + 1];
      const rowRect = row.getBoundingClientRect();
      const tableRect = table.getBoundingClientRect();
      const handleTop = row.offsetTop + row.offsetHeight;
      const rowHandle = document.createElement("div");
      rowHandle.className = "table-resize-handle-row";
      rowHandle.style.position = "absolute";
      rowHandle.style.left = "0";
      rowHandle.style.top = `${handleTop}px`;
      rowHandle.style.height = "5px";
      rowHandle.style.width = "100%";
      rowHandle.style.cursor = "row-resize";
      rowHandle.style.zIndex = "100";
      rowHandle.dataset.index = i.toString();
      rowHandle.dataset.type = "row";
      console.log(`TableResizer: \u6DFB\u52A0\u884C\u62D6\u62FD\u53E5\u67C4 - \u7D22\u5F15=${i}, \u4F4D\u7F6E=${handleTop}px`);
      this.addHandleEventListeners(rowHandle);
      table.appendChild(rowHandle);
      this.resizeHandles.push(rowHandle);
    }
  }
  /**
   * 
   * @param handle 
   */
  addHandleEventListeners(handle) {
    handle.addEventListener("mousedown", this.handleMouseDown.bind(this));
    handle.addEventListener("mouseenter", () => {
      handle.style.backgroundColor = "var(--interactive-accent)";
    });
    handle.addEventListener("mouseleave", () => {
      if (!this.isResizing || this.currentHandle !== handle) {
        handle.style.backgroundColor = "transparent";
      }
    });
  }
  /**
   * 
   * @param event 
   */
  handleMouseDown(event2) {
    if (!this.activeTable)
      return;
    event2.stopPropagation();
    event2.preventDefault();
    const handle = event2.target;
    this.currentHandle = handle;
    this.resizeType = handle.dataset.type;
    this.targetIndex = parseInt(handle.dataset.index || "-1");
    console.log(`TableResizer: \u5F00\u59CB\u62D6\u62FD - \u7C7B\u578B=${this.resizeType}, \u7D22\u5F15=${this.targetIndex}`);
    this.startX = event2.clientX;
    this.startY = event2.clientY;
    if (this.resizeType === "column") {
      const cells = this.activeTable.querySelectorAll(`tr:first-child > *:nth-child(${this.targetIndex + 1})`);
      if (cells.length > 0) {
        const cell = cells[0];
        this.startWidth = cell.offsetWidth;
        console.log(`TableResizer: \u5217\u521D\u59CB\u5BBD\u5EA6=${this.startWidth}px`);
      }
    } else {
      const rows = this.activeTable.querySelectorAll(`tr:nth-child(${this.targetIndex + 1})`);
      if (rows.length > 0) {
        const row = rows[0];
        this.startHeight = row.offsetHeight;
        console.log(`TableResizer: \u884C\u521D\u59CB\u9AD8\u5EA6=${this.startHeight}px`);
      }
    }
    this.createResizeGuide();
    this.isResizing = true;
    document.addEventListener("mousemove", this.handleMouseMove.bind(this));
    document.addEventListener("mouseup", this.handleMouseUp.bind(this));
  }
  /**
   * 
   */
  createResizeGuide() {
    if (!this.activeTable || !this.currentHandle)
      return;
    const guide = document.createElement("div");
    guide.className = `table-resize-guide table-resize-guide-${this.resizeType}`;
    guide.style.position = "absolute";
    guide.style.backgroundColor = "var(--interactive-accent)";
    guide.style.zIndex = "1000";
    if (this.resizeType === "column") {
      guide.style.width = "2px";
      guide.style.height = "100%";
      guide.style.top = "0";
      guide.style.left = this.currentHandle.style.left;
    } else {
      guide.style.height = "2px";
      guide.style.width = "100%";
      guide.style.left = "0";
      guide.style.top = this.currentHandle.style.top;
    }
    this.activeTable.appendChild(guide);
    this.resizeGuide = guide;
    console.log("TableResizer: \u521B\u5EFA\u8C03\u6574\u5927\u5C0F\u8F85\u52A9\u7EBF");
  }
  /**
   * 
   * @param event 
   */
  handleMouseMove(event2) {
    if (!this.isResizing || !this.activeTable || !this.currentHandle || !this.resizeGuide)
      return;
    const deltaX = event2.clientX - this.startX;
    const deltaY = event2.clientY - this.startY;
    if (this.resizeType === "column") {
      const newLeft = parseInt(this.currentHandle.style.left) + deltaX;
      this.resizeGuide.style.left = `${newLeft}px`;
      console.log(`TableResizer: \u8C03\u6574\u5217\u8F85\u52A9\u7EBF - \u4F4D\u7F6E=${newLeft}px`);
    } else {
      const newTop = parseInt(this.currentHandle.style.top) + deltaY;
      this.resizeGuide.style.top = `${newTop}px`;
      console.log(`TableResizer: \u8C03\u6574\u884C\u8F85\u52A9\u7EBF - \u4F4D\u7F6E=${newTop}px`);
    }
  }
  /**
   * 
   * @param event 
   */
  handleMouseUp(event2) {
    if (!this.isResizing || !this.activeTable)
      return;
    console.log("TableResizer: \u7ED3\u675F\u62D6\u62FD");
    const deltaX = event2.clientX - this.startX;
    const deltaY = event2.clientY - this.startY;
    if (this.resizeType === "column" && this.targetIndex >= 0) {
      const newWidth = Math.max(20, this.startWidth + deltaX);
      this.applyColumnWidth(this.targetIndex, newWidth);
      console.log(`TableResizer: \u5E94\u7528\u65B0\u5217\u5BBD - \u7D22\u5F15=${this.targetIndex}, \u5BBD\u5EA6=${newWidth}px`);
    } else if (this.resizeType === "row" && this.targetIndex >= 0) {
      const newHeight = Math.max(20, this.startHeight + deltaY);
      this.applyRowHeight(this.targetIndex, newHeight);
      console.log(`TableResizer: \u5E94\u7528\u65B0\u884C\u9AD8 - \u7D22\u5F15=${this.targetIndex}, \u9AD8\u5EA6=${newHeight}px`);
    }
    this.saveTableSizeData();
    if (this.resizeGuide) {
      this.resizeGuide.remove();
      this.resizeGuide = null;
    }
    this.isResizing = false;
    this.currentHandle = null;
    document.removeEventListener("mousemove", this.handleMouseMove.bind(this));
    document.removeEventListener("mouseup", this.handleMouseUp.bind(this));
  }
  /**
   * 
   * @param colIndex 
   * @param width 
   */
  applyColumnWidth(colIndex, width) {
    if (!this.activeTable)
      return;
    let colgroup = this.activeTable.querySelector("colgroup");
    if (!colgroup) {
      colgroup = document.createElement("colgroup");
      const firstRow = this.activeTable.querySelector("tr");
      if (firstRow) {
        const cellCount = firstRow.querySelectorAll("th, td").length;
        for (let i = 0; i < cellCount; i++) {
          const col = document.createElement("col");
          colgroup.appendChild(col);
        }
      }
      this.activeTable.prepend(colgroup);
    }
    const cols = colgroup.querySelectorAll("col");
    if (colIndex < cols.length) {
      const col = cols[colIndex];
      col.style.width = `${width}px`;
    }
  }
  /**
   * 
   * @param rowIndex 
   * @param height 
   */
  applyRowHeight(rowIndex, height) {
    if (!this.activeTable)
      return;
    const rows = this.activeTable.querySelectorAll("tr");
    if (rowIndex < rows.length) {
      const row = rows[rowIndex];
      row.style.height = `${height}px`;
    }
  }
  /**
   * 
   */
  async saveTableSizeData() {
    if (!this.activeTable)
      return;
    try {
      const tableId = this.activeTable.getAttribute("data-table-id");
      if (!tableId) {
        console.warn("TableResizer: \u65E0\u6CD5\u4FDD\u5B58\u8868\u683C\u5C3A\u5BF8\u6570\u636E\uFF0C\u8868\u683C\u6CA1\u6709ID");
        return;
      }
      console.log(`TableResizer: \u4FDD\u5B58\u8868\u683C\u5C3A\u5BF8\u6570\u636E - \u8868\u683CID=${tableId}`);
      const colWidths = [];
      const colgroup = this.activeTable.querySelector("colgroup");
      if (colgroup) {
        const cols = colgroup.querySelectorAll("col");
        cols.forEach((col) => {
          const width = col.style.width || "auto";
          colWidths.push(width);
        });
      }
      if (colWidths.length === 0) {
        const firstRow = this.activeTable.querySelector("tr");
        if (firstRow) {
          const cellCount = firstRow.querySelectorAll("th, td").length;
          for (let i = 0; i < cellCount; i++) {
            colWidths.push("auto");
          }
        }
      }
      const rowHeights = [];
      const rows = this.activeTable.querySelectorAll("tr");
      rows.forEach((row) => {
        const height = row.style.height || "auto";
        rowHeights.push(height);
      });
      console.log("TableResizer: \u6536\u96C6\u7684\u5C3A\u5BF8\u6570\u636E", { colWidths, rowHeights });
      let allData = await this.plugin.loadData() || {};
      if (!allData.tables) {
        allData.tables = {};
      }
      const activeFile = this.getApp().workspace.getActiveFile();
      if (!activeFile) {
        console.warn("TableResizer: \u65E0\u6CD5\u83B7\u53D6\u5F53\u524D\u6587\u4EF6\u8DEF\u5F84");
        return;
      }
      if (!allData.tables[tableId]) {
        allData.tables[tableId] = {
          id: tableId,
          locations: [{
            path: activeFile.path,
            isActive: true
          }],
          structure: {
            rowCount: rows.length,
            colCount: colWidths.length,
            hasHeaders: rows.length > 0 && rows[0].querySelectorAll("th").length > 0
          },
          styling: {
            rowHeights,
            colWidths,
            alignment: Array(colWidths.length).fill("left"),
            cellStyles: []
          }
        };
        console.log(`TableResizer: \u521B\u5EFA\u4E86\u65B0\u7684\u8868\u683C\u6570\u636E - ID=${tableId}`, allData.tables[tableId]);
      } else {
        if (!allData.tables[tableId].styling) {
          allData.tables[tableId].styling = {};
        }
        if (!allData.tables[tableId].locations) {
          allData.tables[tableId].locations = [{
            path: activeFile.path,
            isActive: true
          }];
        } else {
          const filePathExists = allData.tables[tableId].locations.some(
            (loc) => loc.path === activeFile.path
          );
          if (!filePathExists) {
            allData.tables[tableId].locations.push({
              path: activeFile.path,
              isActive: true
            });
          }
        }
        allData.tables[tableId].styling.rowHeights = rowHeights;
        allData.tables[tableId].styling.colWidths = colWidths;
        allData.tables[tableId].structure = {
          rowCount: rows.length,
          colCount: colWidths.length,
          hasHeaders: rows.length > 0 && rows[0].querySelectorAll("th").length > 0
        };
        console.log(`TableResizer: \u66F4\u65B0\u4E86\u73B0\u6709\u8868\u683C\u6570\u636E - ID=${tableId}`, allData.tables[tableId]);
      }
      await this.plugin.saveData(allData);
      if (this.plugin.settings.preferFileStorage && activeFile) {
        await this.plugin.tableDataExtractor.exportTableDataToFile(activeFile, tableId, allData.tables[tableId]);
        console.log(`TableResizer: \u5DF2\u5C06\u8868\u683C\u5927\u5C0F\u6570\u636E\u5BFC\u51FA\u5230\u6587\u4EF6 ${activeFile.path}`);
      }
      console.log("TableResizer: \u8868\u683C\u5C3A\u5BF8\u6570\u636E\u4FDD\u5B58\u6210\u529F");
      this.applyCurrentSizes();
    } catch (error) {
      console.error("TableResizer: \u4FDD\u5B58\u8868\u683C\u5C3A\u5BF8\u6570\u636E\u65F6\u51FA\u9519:", error);
    }
  }
  /**
   * 
   */
  applyCurrentSizes() {
    if (!this.activeTable)
      return;
    try {
      const colgroup = this.activeTable.querySelector("colgroup");
      if (colgroup) {
        const cols = colgroup.querySelectorAll("col");
        cols.forEach((col, index) => {
          const width = col.style.width;
          if (width) {
            console.log(`TableResizer: \u7ACB\u5373\u5E94\u7528\u5217\u5BBD - \u7D22\u5F15=${index}, \u5BBD\u5EA6=${width}`);
          }
        });
      }
      const rows = this.activeTable.querySelectorAll("tr");
      rows.forEach((row, index) => {
        const height = row.style.height;
        if (height) {
          console.log(`TableResizer: \u7ACB\u5373\u5E94\u7528\u884C\u9AD8 - \u7D22\u5F15=${index}, \u9AD8\u5EA6=${height}`);
        }
      });
    } catch (error) {
      console.error("TableResizer: \u5E94\u7528\u5F53\u524D\u5C3A\u5BF8\u65F6\u51FA\u9519:", error);
    }
  }
  /**
   * 
   */
  removeResizeHandles() {
    console.log("TableResizer: \u79FB\u9664\u62D6\u62FD\u53E5\u67C4");
    this.resizeHandles.forEach((handle) => {
      handle.remove();
    });
    this.resizeHandles = [];
    if (this.resizeGuide) {
      this.resizeGuide.remove();
      this.resizeGuide = null;
    }
  }
  /**
   * 
   */
  cleanup() {
    console.log("TableResizer: \u6E05\u7406\u8D44\u6E90");
    this.removeResizeHandles();
    this.activeTable = null;
    this.isResizing = false;
    this.currentHandle = null;
  }
};

// src/tableDataExtractor.ts
var TableDataExtractor = class {
  constructor(plugin) {
    this.plugin = plugin;
  }
  // app
  getApp() {
    return this.plugin.app;
  }
  /**
   * 
   * @param file 
   * @returns ID
   */
  async extractTableDataFromFile(file) {
    try {
      const fileContent = await this.getApp().vault.read(file);
      const result = {};
      const jsonCodeBlockRegex = /```json:table-data\s*\n([\s\S]*?)\n```/g;
      let jsonMatch;
      while ((jsonMatch = jsonCodeBlockRegex.exec(fileContent)) !== null) {
        try {
          const jsonStr = jsonMatch[1].trim();
          const jsonData = JSON.parse(jsonStr);
          if (Array.isArray(jsonData)) {
            for (const tableData of jsonData) {
              if (tableData.id) {
                this.processTableDataObject(tableData, result);
              }
            }
          } else if (jsonData.id) {
            this.processTableDataObject(jsonData, result);
          }
        } catch (error) {
          console.error("\u89E3\u6790JSON\u8868\u683C\u6570\u636E\u4EE3\u7801\u5757\u65F6\u51FA\u9519:", error);
        }
      }
      const csvCodeBlockRegex = /```csv:table-data\s*\n([\s\S]*?)\n```/g;
      let csvMatch;
      while ((csvMatch = csvCodeBlockRegex.exec(fileContent)) !== null) {
        try {
          const csvStr = csvMatch[1].trim();
          const csvLines = csvStr.split("\n");
          if (csvLines.length > 1) {
            const headers = csvLines[0].split(",");
            for (let i = 1; i < csvLines.length; i++) {
              const values = csvLines[i].split(",");
              const tableData = {};
              for (let j = 0; j < headers.length && j < values.length; j++) {
                if (values[j]) {
                  try {
                    tableData[headers[j]] = JSON.parse(values[j]);
                  } catch (e) {
                    tableData[headers[j]] = values[j];
                  }
                }
              }
              if (tableData.id) {
                this.processTableDataObject(tableData, result);
              }
            }
          }
        } catch (error) {
          console.error("\u89E3\u6790CSV\u8868\u683C\u6570\u636E\u4EE3\u7801\u5757\u65F6\u51FA\u9519:", error);
        }
      }
      const customCodeBlockRegex = /```table-data\s*\n([\s\S]*?)\n```/g;
      let customMatch;
      while ((customMatch = customCodeBlockRegex.exec(fileContent)) !== null) {
        try {
          const customStr = customMatch[1].trim();
          const customLines = customStr.split("\n");
          for (const line of customLines) {
            const tableData = this.parseCustomTableDataFormat(line);
            if (tableData && tableData.id) {
              result[tableData.id] = tableData;
            }
          }
        } catch (error) {
          console.error("\u89E3\u6790\u81EA\u5B9A\u4E49\u8868\u683C\u6570\u636E\u4EE3\u7801\u5757\u65F6\u51FA\u9519:", error);
        }
      }
      this.extractTableDataFromComments(fileContent, result);
      return result;
    } catch (error) {
      console.error("\u4ECE\u6587\u4EF6\u63D0\u53D6\u8868\u683C\u6570\u636E\u65F6\u51FA\u9519:", error);
      return {};
    }
  }
  /**
   * HTMLID
   * @param fileContent 
   * @param result 
   */
  extractTableDataFromComments(fileContent, result) {
    try {
      const commentRegex = /<!--\s*table-id:\s*([\w-]+)(?:\s*\|\s*([^>]*))?\s*-->/g;
      let match;
      while ((match = commentRegex.exec(fileContent)) !== null) {
        const tableId = match[1].trim();
        const dataString = match[2] ? match[2].trim() : null;
        if (tableId && dataString) {
          const tableData = this.parseCustomTableDataFormat(`${tableId}|${dataString}`);
          if (tableData && tableData.id) {
            result[tableData.id] = tableData;
          }
        } else if (tableId && !result[tableId]) {
          result[tableId] = this.createEmptyTableData(tableId);
        }
      }
    } catch (error) {
      console.error("\u4ECEHTML\u6CE8\u91CA\u63D0\u53D6\u8868\u683C\u6570\u636E\u65F6\u51FA\u9519:", error);
    }
  }
  /**
   * 
   * @param tableId ID
   * @returns 
   */
  createEmptyTableData(tableId) {
    return {
      id: tableId,
      locations: [],
      structure: {
        rowCount: 0,
        colCount: 0,
        hasHeaders: false,
        useTableWrapper: false,
        merges: []
      },
      styling: {
        rowHeights: [],
        colWidths: [],
        alignment: [],
        cellStyles: []
      }
    };
  }
  /**
   * 
   * @param tableData 
   * @param result 
   */
  processTableDataObject(tableData, result) {
    try {
      if (!tableData.structure) {
        tableData.structure = {
          rowCount: 0,
          colCount: 0,
          hasHeaders: false,
          useTableWrapper: false,
          merges: []
        };
      } else {
        if (tableData.structure.rowCount === void 0)
          tableData.structure.rowCount = 0;
        if (tableData.structure.colCount === void 0)
          tableData.structure.colCount = 0;
        if (tableData.structure.hasHeaders === void 0)
          tableData.structure.hasHeaders = false;
        if (tableData.structure.useTableWrapper === void 0)
          tableData.structure.useTableWrapper = false;
        if (!tableData.structure.merges)
          tableData.structure.merges = [];
      }
      if (!tableData.styling) {
        tableData.styling = {
          rowHeights: [],
          colWidths: [],
          alignment: [],
          cellStyles: []
        };
      } else {
        if (!tableData.styling.rowHeights)
          tableData.styling.rowHeights = [];
        if (!tableData.styling.colWidths)
          tableData.styling.colWidths = [];
        if (!tableData.styling.alignment)
          tableData.styling.alignment = [];
        if (!tableData.styling.cellStyles)
          tableData.styling.cellStyles = [];
        if (tableData.styling.cellStyles && !Array.isArray(tableData.styling.cellStyles)) {
          console.log("\u5C06cellStyles\u4ECE\u5BF9\u8C61\u8F6C\u6362\u4E3A\u6570\u7EC4");
          tableData.styling.cellStyles = [];
        }
      }
      if (!tableData.locations) {
        tableData.locations = [];
      }
      result[tableData.id] = tableData;
    } catch (error) {
      console.error("\u5904\u7406\u8868\u683C\u6570\u636E\u5BF9\u8C61\u65F6\u51FA\u9519:", error);
    }
  }
  /**
   * 
   * : tableId|key1:value1|key2:value2,...
   * @param line 
   * @returns 
   */
  parseCustomTableDataFormat(line) {
    try {
      const parts = line.split("|");
      if (parts.length < 1)
        return null;
      const tableId = parts[0].trim();
      if (!tableId)
        return null;
      const tableData = this.createEmptyTableData(tableId);
      for (let i = 1; i < parts.length; i++) {
        const part = parts[i];
        const colonIndex = part.indexOf(":");
        if (colonIndex === -1)
          continue;
        const key = part.substring(0, colonIndex).trim();
        let value = part.substring(colonIndex + 1).trim();
        switch (key) {
          case "rows":
            tableData.structure.rowCount = parseInt(value, 10) || 0;
            break;
          case "cols":
            tableData.structure.colCount = parseInt(value, 10) || 0;
            break;
          case "headers":
            tableData.structure.hasHeaders = value === "true";
            break;
          case "wrapper":
            tableData.structure.useTableWrapper = value === "true";
            break;
          case "width":
            tableData.styling.colWidths = value.split(",").map((w) => w.trim());
            break;
          case "align":
            tableData.styling.alignment = value.split(",").map((a) => a.trim());
            break;
          case "height":
            tableData.styling.rowHeights = value.split(",").map((h) => h.trim());
            break;
          case "loc":
            const locations = value.split(",").map((l) => {
              const locParts = l.split(":");
              if (locParts.length === 2) {
                return {
                  path: locParts[0].trim(),
                  isActive: locParts[1].trim() === "true"
                };
              }
              return null;
            }).filter((l) => l !== null);
            tableData.locations = locations;
            break;
          case "cellStyles":
            try {
              const parsedStyles = JSON.parse(value);
              if (Array.isArray(parsedStyles)) {
                tableData.styling.cellStyles = parsedStyles;
              } else if (typeof parsedStyles === "object") {
                console.log("\u5C06cellStyles\u4ECE\u5BF9\u8C61\u683C\u5F0F\u8F6C\u6362\u4E3A\u6570\u7EC4\u683C\u5F0F");
                tableData.styling.cellStyles = [];
              } else {
                tableData.styling.cellStyles = [];
              }
            } catch (e) {
              console.error("\u89E3\u6790\u5355\u5143\u683C\u6837\u5F0F\u65F6\u51FA\u9519:", e);
              tableData.styling.cellStyles = [];
            }
            break;
          case "merges":
            try {
              tableData.structure.merges = JSON.parse(value);
            } catch (e) {
              console.error("\u89E3\u6790\u5355\u5143\u683C\u5408\u5E76\u4FE1\u606F\u65F6\u51FA\u9519:", e);
              tableData.structure.merges = [];
            }
            break;
        }
      }
      console.log(`\u89E3\u6790\u5B8C\u6210\u7684\u8868\u683C\u6570\u636E ${tableId}:`, tableData);
      return tableData;
    } catch (error) {
      console.error("\u89E3\u6790\u81EA\u5B9A\u4E49\u8868\u683C\u6570\u636E\u683C\u5F0F\u65F6\u51FA\u9519:", error);
      return null;
    }
  }
  /**
   * 
   * @param table 
   * @param tableData 
   * @returns 
   */
  enhanceTableData(table, tableData) {
    const enhancedData = JSON.parse(JSON.stringify(tableData));
    const rows = table.querySelectorAll("tr");
    const rowCount = rows.length;
    let colCount = 0;
    const hasHeaderRow = table.querySelector("thead") !== null;
    rows.forEach((row) => {
      const cellCount = row.querySelectorAll("td, th").length;
      colCount = Math.max(colCount, cellCount);
    });
    if (!enhancedData.structure.rowCount || enhancedData.structure.rowCount === 0) {
      enhancedData.structure.rowCount = rowCount;
    }
    if (!enhancedData.structure.colCount || enhancedData.structure.colCount === 0) {
      enhancedData.structure.colCount = colCount;
    }
    if (enhancedData.structure.hasHeaders === void 0) {
      enhancedData.structure.hasHeaders = hasHeaderRow;
    }
    if (!enhancedData.styling.rowHeights || enhancedData.styling.rowHeights.length === 0) {
      enhancedData.styling.rowHeights = Array(rowCount).fill("auto");
    }
    if (!enhancedData.styling.colWidths || enhancedData.styling.colWidths.length === 0) {
      enhancedData.styling.colWidths = Array(colCount).fill("auto");
    }
    if (!enhancedData.styling.alignment || enhancedData.styling.alignment.length === 0) {
      enhancedData.styling.alignment = Array(colCount).fill("right");
      if (colCount > 0)
        enhancedData.styling.alignment[0] = "left";
    }
    return enhancedData;
  }
  /**
   * Markdown
   * @param file 
   * @param tableId ID
   * @param tableData 
   */
  async exportTableDataToFile(file, tableId, tableData) {
    try {
      if (!file || !tableId || !tableData)
        return;
      let fileContent = await this.getApp().vault.read(file);
      const tableIds = /* @__PURE__ */ new Set();
      const commentRegex = /<!-- table-id: ([\w-]+) -->/g;
      let match;
      while ((match = commentRegex.exec(fileContent)) !== null) {
        tableIds.add(match[1]);
      }
      tableIds.add(tableId);
      const existingTableData = await this.extractTableDataFromFile(file);
      existingTableData[tableId] = tableData;
      const tableDataArray = Array.from(tableIds).filter((id) => existingTableData[id]).map((id) => existingTableData[id]);
      const jsonBlockRegex = /```(json:table-data|table-data)\s*\n([\s\S]*?)\n```/g;
      const codeBlocks = [];
      while ((match = jsonBlockRegex.exec(fileContent)) !== null) {
        codeBlocks.push({
          start: match.index,
          end: match.index + match[0].length
        });
      }
      if (codeBlocks.length > 0) {
        for (let i = codeBlocks.length - 1; i >= 0; i--) {
          const block = codeBlocks[i];
          fileContent = fileContent.substring(0, block.start) + fileContent.substring(block.end);
        }
      }
      if (!fileContent.endsWith("\n\n")) {
        if (fileContent.endsWith("\n")) {
          fileContent += "\n";
        } else {
          fileContent += "\n\n";
        }
      }
      if (this.plugin.settings.useCompactFormat) {
        const compactData = this.convertToCompactFormat(tableDataArray);
        fileContent += "```table-data\n" + compactData + "\n```";
        console.log(`\u5DF2\u5C06\u8868\u683C\u6570\u636E\u4EE5\u7D27\u51D1\u683C\u5F0F\u5BFC\u51FA\u5230\u6587\u4EF6\u672B\u5C3E: ${file.path}, \u8868\u683C\u6570\u91CF: ${tableDataArray.length}`);
      } else {
        const dataToExport = JSON.stringify(tableDataArray, null, 2);
        fileContent += "```json:table-data\n" + dataToExport + "\n```";
        console.log(`\u5DF2\u5C06\u8868\u683C\u6570\u636E\u4EE5JSON\u683C\u5F0F\u5BFC\u51FA\u5230\u6587\u4EF6\u672B\u5C3E: ${file.path}, \u8868\u683C\u6570\u91CF: ${tableDataArray.length}`);
      }
      await this.getApp().vault.modify(file, fileContent);
    } catch (error) {
      console.error("\u5BFC\u51FA\u8868\u683C\u6570\u636E\u5230\u6587\u4EF6\u65F6\u51FA\u9519:", error);
    }
  }
  /**
   * 
   * : tableId|key1:value1|key2:value2,...
   * @param tableDataArray 
   * @returns 
   */
  convertToCompactFormat(tableDataArray) {
    try {
      const lines = [];
      for (const tableData of tableDataArray) {
        if (!tableData || !tableData.id)
          continue;
        let line = tableData.id;
        if (tableData.structure) {
          if (tableData.structure.rowCount) {
            line += `|rows:${tableData.structure.rowCount}`;
          }
          if (tableData.structure.colCount) {
            line += `|cols:${tableData.structure.colCount}`;
          }
          if (tableData.structure.hasHeaders !== void 0) {
            line += `|headers:${tableData.structure.hasHeaders}`;
          }
          if (tableData.structure.useTableWrapper !== void 0) {
            line += `|wrapper:${tableData.structure.useTableWrapper}`;
          }
        }
        if (tableData.styling) {
          if (tableData.styling.colWidths && tableData.styling.colWidths.length > 0) {
            line += `|width:${tableData.styling.colWidths.join(",")}`;
          }
          if (tableData.styling.rowHeights && tableData.styling.rowHeights.length > 0) {
            line += `|height:${tableData.styling.rowHeights.join(",")}`;
          }
          if (tableData.styling.alignment && tableData.styling.alignment.length > 0) {
            line += `|align:${tableData.styling.alignment.join(",")}`;
          }
          if (tableData.styling.cellStyles && Array.isArray(tableData.styling.cellStyles)) {
            try {
              const cellStylesStr = JSON.stringify(tableData.styling.cellStyles);
              line += `|cellStyles:${cellStylesStr}`;
            } catch (e) {
              console.error("\u5E8F\u5217\u5316\u5355\u5143\u683C\u6837\u5F0F\u65F6\u51FA\u9519:", e);
            }
          } else {
            line += `|cellStyles:[]`;
          }
        }
        if (tableData.structure && tableData.structure.merges) {
          try {
            const mergesStr = JSON.stringify(tableData.structure.merges);
            line += `|merges:${mergesStr}`;
          } catch (e) {
            console.error("\u5E8F\u5217\u5316\u5408\u5E76\u5355\u5143\u683C\u4FE1\u606F\u65F6\u51FA\u9519:", e);
          }
        }
        if (tableData.locations && tableData.locations.length > 0) {
          const locationsStr = tableData.locations.map((loc) => `${loc.path}:${loc.isActive}`).join(",");
          line += `|loc:${locationsStr}`;
        }
        lines.push(line);
      }
      return lines.join("\n");
    } catch (error) {
      console.error("\u8F6C\u6362\u4E3A\u7D27\u51D1\u683C\u5F0F\u65F6\u51FA\u9519:", error);
      return "";
    }
  }
};

// src/main.ts
var DEFAULT_SETTINGS = {
  nativeProcessing: true,
  paragraphs: true,
  enableCellMerging: true,
  confirmMergeNonEmpty: true,
  enableTableIds: true,
  idPrefix: "tbl",
  autoCenterMergedCells: true,
  toolbarEnabled: true,
  enableEditModeOperations: true,
  useTableWrapperComments: false,
  // 
  featureSimilarityThreshold: 0.7,
  // 70%
  preferFeatureMatching: false,
  // 
  preferFileStorage: true,
  // 
  autoExportToFile: false,
  // 
  useCompactFormat: true
  // 
};
var ObsidianSpreadsheet = class extends import_obsidian10.Plugin {
  constructor(app, manifest) {
    super(app, manifest);
    this.currentEditingTable = null;
    // 
    this.lastPreviewModeState = false;
    /**
     * 
     */
    this.handleTableClick = (event2) => {
      try {
        const table = event2.currentTarget;
        if (!table)
          return;
        this.removeAllTableHighlights();
        this.highlightSelectedTable(table);
        if (this.settings.toolbarEnabled) {
          this.tableToolbar.setActiveTable(table);
        }
        this.tableResizer.setupTableResize(table);
        console.log("\u8868\u683C\u70B9\u51FB\u4E8B\u4EF6\u5DF2\u5904\u7406");
      } catch (error) {
        console.error("\u5904\u7406\u8868\u683C\u70B9\u51FB\u4E8B\u4EF6\u65F6\u51FA\u9519:", error);
      }
    };
    /**
     * 
     * @param event 
     */
    this.handleDocumentClick = (event2) => {
      var _a;
      try {
        const isClickInToolbar = event2.target instanceof Node && ((_a = document.querySelector(".advanced-table-toolbar-container")) == null ? void 0 : _a.contains(event2.target));
        const isClickInTable = event2.target instanceof Node && event2.target.closest("table") !== null;
        if (!isClickInToolbar && !isClickInTable) {
          if (this.tableToolbar.activeTable) {
            this.tableToolbar.clearSelection();
          }
        }
      } catch (error) {
        console.error("\u5904\u7406\u6587\u6863\u70B9\u51FB\u4E8B\u4EF6\u65F6\u51FA\u9519:", error);
      }
    };
    this.handleTableClick = this.handleTableClick.bind(this);
    this.handleDocumentClick = this.handleDocumentClick.bind(this);
  }
  // 
  async onload() {
    try {
      console.log("Loading Advanced Table XT plugin");
      await this.loadSettings();
      if (this.settings.toolbarEnabled === void 0) {
        this.settings.toolbarEnabled = true;
        await this.saveSettings();
      }
      if (this.settings.enableEditModeOperations === void 0) {
        this.settings.enableEditModeOperations = true;
        await this.saveSettings();
      }
      if (this.settings.preferFileStorage === void 0) {
        this.settings.preferFileStorage = true;
        await this.saveSettings();
      }
      if (this.settings.autoExportToFile === void 0) {
        this.settings.autoExportToFile = false;
        await this.saveSettings();
      }
      loadIcons();
      console.log("Initializing plugin components");
      this.tableIdManager = new TableIdManager(this);
      this.markdownSourceEditor = new MarkdownSourceEditor(this);
      this.tableDetector = new MarkdownTableDetector(this);
      this.tableToolbar = new TableToolbar(this);
      this.tableResizer = new TableResizer(this);
      this.tableDataExtractor = new TableDataExtractor(this);
      this.ribbonIcon = this.addRibbonIcon("table-toolbar-toggle", "\u8868\u683C\u5DE5\u5177\u680F", (evt) => {
        this.toggleToolbarState();
      });
      this.addRibbonIcon("table-edit-mode", "\u7F16\u8F91\u6A21\u5F0F\u8868\u683C\u64CD\u4F5C", (evt) => {
        const activeView = this.app.workspace.getActiveViewOfType(import_obsidian10.MarkdownView);
        if (!activeView) {
          new import_obsidian10.Notice("\u672A\u627E\u5230\u6D3B\u52A8\u89C6\u56FE");
          return;
        }
        const isEditMode = activeView.getMode() === "source";
        if (!isEditMode) {
          new import_obsidian10.Notice("\u8BF7\u5207\u6362\u5230\u7F16\u8F91\u6A21\u5F0F\u4F7F\u7528\u6B64\u529F\u80FD");
          return;
        }
        const menu = new import_obsidian10.Menu();
        menu.addItem((item) => {
          item.setTitle("\u4E3A\u8868\u683C\u6DFB\u52A0ID").setIcon("table-id").onClick(async () => {
            await this.markdownSourceEditor.addTableIdToMarkdown();
          });
        });
        menu.addItem((item) => {
          item.setTitle("\u5411\u53F3\u5408\u5E76\u5355\u5143\u683C").setIcon("merge-right").onClick(async () => {
            await this.markdownSourceEditor.mergeCells("right");
          });
        });
        menu.addItem((item) => {
          item.setTitle("\u5411\u4E0B\u5408\u5E76\u5355\u5143\u683C").setIcon("merge-down").onClick(async () => {
            await this.markdownSourceEditor.mergeCells("down");
          });
        });
        menu.showAtMouseEvent(evt);
      });
      this.updateRibbonIcon();
      if (this.settings.toolbarEnabled) {
        this.createToolbar();
      }
      this.registerEvent(
        this.app.workspace.on("active-leaf-change", () => {
          if (this.settings.toolbarEnabled) {
            setTimeout(() => {
              this.setupTableSelection();
            }, 300);
          }
        })
      );
      this.registerEvent(
        this.app.workspace.on("layout-change", () => {
          if (this.settings.toolbarEnabled) {
            setTimeout(() => {
              this.setupTableSelection();
            }, 300);
          }
        })
      );
      this.registerEvent(
        this.app.workspace.on("editor-change", (editor, view) => {
          if (this.settings.toolbarEnabled && this.settings.enableEditModeOperations) {
            if (view instanceof import_obsidian10.MarkdownView && view.getMode() === "source") {
              this.debounce(() => {
                const tableInfo = this.markdownSourceEditor.locateTableInMarkdown(editor);
                if (tableInfo) {
                  this.setupEditModeTableSelection(editor);
                }
              }, 500)();
            }
          }
        })
      );
      this.registerDomEvent(document, "click", (evt) => {
        if (this.settings.toolbarEnabled && this.settings.enableEditModeOperations) {
          const activeView = this.app.workspace.getActiveViewOfType(import_obsidian10.MarkdownView);
          if (activeView && activeView.getMode() === "source") {
            setTimeout(() => {
              const editor = activeView.editor;
              const tableInfo = this.markdownSourceEditor.locateTableInMarkdown(editor);
              if (tableInfo) {
                this.setupEditModeTableSelection(editor);
              }
            }, 100);
          }
        }
      });
      this.addCommand({
        id: "add-table-id-in-edit-mode",
        name: "\u5728\u7F16\u8F91\u6A21\u5F0F\u4E0B\u4E3A\u8868\u683C\u6DFB\u52A0ID",
        editorCallback: async (editor) => {
          if (this.settings.enableEditModeOperations) {
            await this.markdownSourceEditor.addTableIdToMarkdown();
          } else {
            new import_obsidian10.Notice("\u7F16\u8F91\u6A21\u5F0F\u4E0B\u7684\u8868\u683C\u64CD\u4F5C\u5DF2\u7981\u7528\uFF0C\u8BF7\u5728\u8BBE\u7F6E\u4E2D\u542F\u7528");
          }
        }
      });
      this.addCommand({
        id: "merge-cell-right-in-edit-mode",
        name: "\u5728\u7F16\u8F91\u6A21\u5F0F\u4E0B\u5411\u53F3\u5408\u5E76\u5355\u5143\u683C",
        editorCallback: async (editor) => {
          if (this.settings.enableEditModeOperations) {
            await this.markdownSourceEditor.mergeCells("right");
          } else {
            new import_obsidian10.Notice("\u7F16\u8F91\u6A21\u5F0F\u4E0B\u7684\u8868\u683C\u64CD\u4F5C\u5DF2\u7981\u7528\uFF0C\u8BF7\u5728\u8BBE\u7F6E\u4E2D\u542F\u7528");
          }
        }
      });
      this.addCommand({
        id: "merge-cell-down-in-edit-mode",
        name: "\u5728\u7F16\u8F91\u6A21\u5F0F\u4E0B\u5411\u4E0B\u5408\u5E76\u5355\u5143\u683C",
        editorCallback: async (editor) => {
          if (this.settings.enableEditModeOperations) {
            await this.markdownSourceEditor.mergeCells("down");
          } else {
            new import_obsidian10.Notice("\u7F16\u8F91\u6A21\u5F0F\u4E0B\u7684\u8868\u683C\u64CD\u4F5C\u5DF2\u7981\u7528\uFF0C\u8BF7\u5728\u8BBE\u7F6E\u4E2D\u542F\u7528");
          }
        }
      });
      this.addCommand({
        id: "show-current-table-id",
        name: "\u663E\u793A\u5F53\u524D\u8868\u683CID",
        callback: async () => {
          await this.showCurrentTableId();
        }
      });
      this.addCommand({
        id: "split-merged-cells",
        name: "\u62C6\u5206\u5DF2\u5408\u5E76\u7684\u5355\u5143\u683C",
        editorCallback: async (editor) => {
          if (this.settings.enableEditModeOperations) {
            await this.markdownSourceEditor.splitMergedCells();
          } else {
            new import_obsidian10.Notice("\u7F16\u8F91\u6A21\u5F0F\u4E0B\u7684\u8868\u683C\u64CD\u4F5C\u5DF2\u7981\u7528\uFF0C\u8BF7\u5728\u8BBE\u7F6E\u4E2D\u542F\u7528");
          }
        }
      });
      this.addCommand({
        id: "fix-merge-markers",
        name: "\u4FEE\u590D\u8868\u683C\u5408\u5E76\u6807\u8BB0",
        editorCallback: async (editor) => {
          if (this.settings.enableEditModeOperations) {
            await this.markdownSourceEditor.detectAndFixMergeMarkers();
          } else {
            new import_obsidian10.Notice("\u7F16\u8F91\u6A21\u5F0F\u4E0B\u7684\u8868\u683C\u64CD\u4F5C\u5DF2\u7981\u7528\uFF0C\u8BF7\u5728\u8BBE\u7F6E\u4E2D\u542F\u7528");
          }
        }
      });
      this.registerMarkdownCodeBlockProcessor(
        "sheet",
        async (source, el, ctx) => {
          source = source.trim();
          ctx.addChild(
            new SheetElement(
              el,
              source,
              ctx,
              this.app,
              this
            )
          );
        }
      );
      this.registerMarkdownPostProcessor(async (el, ctx) => {
        var _a;
        if (!this.settings.nativeProcessing)
          return;
        if (((_a = ctx.frontmatter) == null ? void 0 : _a["disable-sheet"]) === true)
          return;
        const tableEls = el.querySelectorAll("table");
        if (tableEls.length) {
          for (const tableEl of Array.from(tableEls)) {
            if (!tableEl)
              return;
            if ((tableEl == null ? void 0 : tableEl.id) === "obsidian-sheets-parsed")
              return;
            if (this.settings.enableTableIds) {
              this.tableIdManager.ensureTableHasId(tableEl);
            }
            if (this.settings.enableCellMerging !== false) {
              this.renderMergedCells(tableEl, ctx);
              if (tableEl.querySelector("[rowspan], [colspan]")) {
                this.tableDetector.applyMergeCellsMarkers(tableEl);
              }
            }
          }
        }
      });
      this.addSettingTab(new SheetSettingsTab(this.app, this));
      console.log("Advanced Table XT plugin loaded successfully");
    } catch (error) {
      console.error("Error loading Advanced Table XT plugin:", error);
    }
    this.setupViewModeChangeListener();
    this.checkAndRenderTables();
    console.log("Advanced Table XT \u63D2\u4EF6\u5DF2\u52A0\u8F7D");
  }
  /**
   * 
   * @param func 
   * @param wait 
   */
  debounce(func, wait) {
    let timeout = null;
    return function(...args) {
      const context = this;
      const later = function() {
        timeout = null;
        func.apply(context, args);
      };
      if (timeout)
        clearTimeout(timeout);
      timeout = setTimeout(later, wait);
    };
  }
  //  - 
  createToolbar() {
    try {
      document.querySelectorAll(".advanced-table-toolbar-container").forEach((container) => {
        container.remove();
      });
      const toolbarContainer = document.createElement("div");
      toolbarContainer.className = "advanced-table-toolbar-container";
      document.body.appendChild(toolbarContainer);
      this.tableToolbar.createToolbar(toolbarContainer);
      document.addEventListener("click", this.handleDocumentClick);
      const activeView = this.app.workspace.getActiveViewOfType(import_obsidian10.MarkdownView);
      if (activeView) {
        const isEditMode = activeView.getMode() === "source";
        if (isEditMode) {
          const tableInfo = this.markdownSourceEditor.locateTableInMarkdown(activeView.editor);
          if (tableInfo) {
            this.setupEditModeTableSelection(activeView.editor);
          }
        } else {
          this.setupPreviewModeTableSelection();
        }
      }
      console.log("\u5DE5\u5177\u680F\u5DF2\u521B\u5EFA");
    } catch (error) {
      console.error("\u521B\u5EFA\u5DE5\u5177\u680F\u65F6\u51FA\u9519:", error);
    }
  }
  /**
   * 
   */
  setupTableSelection() {
    try {
      const activeView = this.app.workspace.getActiveViewOfType(import_obsidian10.MarkdownView);
      if (!activeView)
        return;
      const isEditMode = activeView.getMode() === "source";
      if (isEditMode) {
        this.setupEditModeTableSelection(activeView.editor);
      } else {
        this.setupPreviewModeTableSelection();
      }
    } catch (error) {
      console.error("\u8BBE\u7F6E\u8868\u683C\u9009\u62E9\u65F6\u51FA\u9519:", error);
    }
  }
  /**
   * 
   * @param editor 
   */
  setupEditModeTableSelection(editor) {
    try {
      const cursor = editor.getCursor();
      console.log(`\u7F16\u8F91\u6A21\u5F0F\u4E0B\u5149\u6807\u4F4D\u7F6E: \u884C=${cursor.line}, \u5217=${cursor.ch}`);
      const tableInfo = this.markdownSourceEditor.locateTableInMarkdown(editor);
      if (!tableInfo) {
        console.log("\u7F16\u8F91\u6A21\u5F0F\u4E0B\u672A\u627E\u5230\u8868\u683C");
        if (this.currentEditingTable) {
          this.currentEditingTable = null;
          if (this.tableToolbar) {
            this.tableToolbar.clearSelection();
          }
        }
        return;
      }
      console.log(`\u7F16\u8F91\u6A21\u5F0F\u4E0B\u627E\u5230\u8868\u683C: \u8303\u56F4=${tableInfo.startLine}-${tableInfo.endLine}`);
      if (!document.querySelector(".advanced-table-toolbar-container")) {
        this.createToolbar();
      }
      this.currentEditingTable = {
        startLine: tableInfo.startLine,
        endLine: tableInfo.endLine,
        content: tableInfo.content
      };
      this.tableToolbar.setActiveEditModeTable(this.currentEditingTable);
      const cellPosition = this.markdownSourceEditor.getCellPosition(editor);
      if (cellPosition) {
        console.log(`\u7F16\u8F91\u6A21\u5F0F\u4E0B\u5149\u6807\u4F4D\u4E8E\u5355\u5143\u683C: \u884C=${cellPosition.rowIndex}, \u5217=${cellPosition.colIndex}`);
      } else {
        console.log("\u7F16\u8F91\u6A21\u5F0F\u4E0B\u65E0\u6CD5\u786E\u5B9A\u5149\u6807\u6240\u5728\u5355\u5143\u683C");
      }
      console.log("\u7F16\u8F91\u6A21\u5F0F\u4E0B\u9009\u62E9\u4E86\u8868\u683C:", this.currentEditingTable);
    } catch (error) {
      console.error("\u8BBE\u7F6E\u7F16\u8F91\u6A21\u5F0F\u8868\u683C\u9009\u62E9\u65F6\u51FA\u9519:", error);
    }
  }
  /**
   * 
   */
  setupPreviewModeTableSelection() {
    try {
      setupPreviewModeTableSelection(this);
    } catch (error) {
      console.error("\u8BBE\u7F6E\u9884\u89C8\u6A21\u5F0F\u8868\u683C\u9009\u62E9\u65F6\u51FA\u9519:", error);
    }
  }
  onunload() {
    console.log("\u5378\u8F7D Advanced Table XT \u63D2\u4EF6");
    document.querySelectorAll(".advanced-table-toolbar-container").forEach((container) => {
      container.remove();
    });
    this.removeAllTableHighlights();
    this.tableResizer.cleanup();
    document.querySelectorAll("table[data-table-processed]").forEach((table) => {
      const tableEl = table;
      delete tableEl.dataset.tableProcessed;
      delete tableEl.dataset.tableSelected;
      tableEl.style.outline = "";
      tableEl.style.outlineOffset = "";
      tableEl.onclick = null;
    });
  }
  async loadSettings() {
    this.settings = Object.assign(
      {},
      DEFAULT_SETTINGS,
      await this.loadData()
    );
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  highlightSelectedTable(table) {
    this.removeAllTableHighlights();
    table.style.outline = "2px solid var(--interactive-accent)";
    table.style.outlineOffset = "2px";
    table.dataset.tableSelected = "true";
  }
  removeAllTableHighlights() {
    document.querySelectorAll('table[data-table-selected="true"]').forEach((table) => {
      const tableEl = table;
      tableEl.style.outline = "";
      tableEl.style.outlineOffset = "";
      delete tableEl.dataset.tableSelected;
    });
  }
  createTableData(table, tableId) {
    var _a;
    try {
      const commentId = this.tableIdManager.getTableIdentifier(table);
      if (!commentId || commentId !== tableId) {
        console.warn(`\u8868\u683CID\u9A8C\u8BC1\u5931\u8D25: \u4F20\u5165ID=${tableId}, HTML\u6CE8\u91CAID=${commentId || "\u65E0"}`);
        console.warn("\u53EA\u6709\u5728HTML\u6CE8\u91CA\u4E2D\u660E\u786E\u5B9A\u4E49\u7684\u8868\u683CID\u624D\u80FD\u521B\u5EFA\u6570\u636E");
        return;
      }
      const activeView = this.app.workspace.getActiveViewOfType(import_obsidian10.MarkdownView);
      if (!activeView) {
        console.warn("\u65E0\u6CD5\u83B7\u53D6\u5F53\u524D\u89C6\u56FE\uFF0C\u4E0D\u521B\u5EFA\u8868\u683C\u6570\u636E");
        return;
      }
      const filePath = (_a = activeView.file) == null ? void 0 : _a.path;
      if (!filePath) {
        console.warn("\u65E0\u6CD5\u83B7\u53D6\u6587\u4EF6\u8DEF\u5F84\uFF0C\u4E0D\u521B\u5EFA\u8868\u683C\u6570\u636E");
        return;
      }
      console.log(`\u4E3A\u6709\u6548\u7684HTML\u6CE8\u91CAID\u521B\u5EFA\u8868\u683C\u6570\u636E: ${tableId}`);
      this.tableToolbar.extractAndStoreTableInfo(tableId, table, filePath);
    } catch (error) {
      console.error("\u521B\u5EFA\u8868\u683C\u6570\u636E\u65F6\u51FA\u9519:", error);
    }
  }
  async saveTableData(tableData) {
    try {
      if (!tableData || !tableData.id) {
        console.warn("\u65E0\u6548\u7684\u8868\u683C\u6570\u636E\uFF0C\u7F3A\u5C11ID");
        return;
      }
      console.log(`\u51C6\u5907\u4FDD\u5B58\u8868\u683C\u6570\u636E: ${tableData.id}`);
      const activeFile = this.app.workspace.getActiveFile();
      let savedToFile = false;
      if (this.settings.preferFileStorage && activeFile && this.tableDataExtractor) {
        try {
          await this.tableDataExtractor.exportTableDataToFile(activeFile, tableData.id, tableData);
          console.log(`\u5DF2\u5C06\u8868\u683C\u6570\u636E\u4FDD\u5B58\u5230\u6587\u4EF6: ${activeFile.path}`);
          savedToFile = true;
        } catch (fileError) {
          console.error("\u4FDD\u5B58\u5230\u6587\u4EF6\u5931\u8D25\uFF0C\u5C06\u56DE\u9000\u5230data.json:", fileError);
          savedToFile = false;
        }
      }
      if (!savedToFile) {
        const existingData = await this.loadData() || {};
        if (!existingData.tables) {
          existingData.tables = {};
        }
        existingData.tables[tableData.id] = tableData;
        await this.saveData(existingData);
        console.log(`\u5DF2\u4FDD\u5B58\u8868\u683C\u6570\u636E\u5230data.json: ${tableData.id}`);
        if (!savedToFile && this.settings.autoExportToFile && this.tableDataExtractor && activeFile) {
          try {
            await this.tableDataExtractor.exportTableDataToFile(activeFile, tableData.id, tableData);
            console.log(`\u5DF2\u81EA\u52A8\u5C06\u8868\u683C\u6570\u636E\u5BFC\u51FA\u5230\u6587\u4EF6: ${activeFile.path}`);
          } catch (exportError) {
            console.error("\u81EA\u52A8\u5BFC\u51FA\u5230\u6587\u4EF6\u5931\u8D25:", exportError);
          }
        }
      }
    } catch (error) {
      console.error("\u4FDD\u5B58\u8868\u683C\u6570\u636E\u65F6\u51FA\u9519:", error);
    }
  }
  updateRibbonIcon() {
    if (!this.ribbonIcon)
      return;
    this.ribbonIcon.empty();
    if (this.settings.toolbarEnabled) {
      const iconEl = this.ribbonIcon.createEl("div", {
        cls: "ribbon-icon-active"
      });
      iconEl.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><line x1="3" y1="9" x2="21" y2="9"></line><line x1="3" y1="15" x2="21" y2="15"></line><line x1="9" y1="3" x2="9" y2="21"></line><line x1="15" y1="3" x2="15" y2="21"></line></svg>`;
      iconEl.style.color = "var(--interactive-accent)";
    } else {
      const iconEl = this.ribbonIcon.createEl("div");
      iconEl.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><line x1="3" y1="9" x2="21" y2="9"></line><line x1="3" y1="15" x2="21" y2="15"></line><line x1="9" y1="3" x2="9" y2="21"></line><line x1="15" y1="3" x2="15" y2="21"></line></svg>`;
    }
  }
  toggleToolbarState() {
    this.settings.toolbarEnabled = !this.settings.toolbarEnabled;
    this.saveSettings();
    this.updateRibbonIcon();
    if (this.settings.toolbarEnabled) {
      this.createToolbar();
      new import_obsidian10.Notice("\u8868\u683C\u5DE5\u5177\u680F\u5DF2\u542F\u7528");
    } else {
      document.querySelectorAll(".advanced-table-toolbar-container").forEach((container) => {
        container.remove();
      });
      new import_obsidian10.Notice("\u8868\u683C\u5DE5\u5177\u680F\u5DF2\u7981\u7528");
    }
  }
  /**
   * ID
   */
  async showCurrentTableId() {
    try {
      const activeView = this.app.workspace.getActiveViewOfType(import_obsidian10.MarkdownView);
      if (!activeView) {
        new import_obsidian10.Notice("\u672A\u627E\u5230\u6D3B\u52A8\u89C6\u56FE");
        return;
      }
      const isEditMode = activeView.getMode() === "source";
      let tableId = null;
      if (isEditMode) {
        tableId = await this.markdownSourceEditor.getCurrentTableId();
      } else {
        if (this.tableToolbar.activeTable) {
          tableId = this.tableIdManager.getTableIdentifier(this.tableToolbar.activeTable);
        }
      }
      if (tableId) {
        new import_obsidian10.Notice(`\u5F53\u524D\u8868\u683CID: ${tableId}`);
        console.log("\u5F53\u524D\u8868\u683CID:", tableId);
      } else {
        new import_obsidian10.Notice("\u672A\u627E\u5230\u8868\u683CID\uFF0C\u8BF7\u786E\u4FDD\u5149\u6807\u5728\u8868\u683C\u5185\u6216\u5DF2\u9009\u62E9\u8868\u683C");
      }
    } catch (error) {
      console.error("\u663E\u793A\u5F53\u524D\u8868\u683CID\u65F6\u51FA\u9519:", error);
    }
  }
  /**
   * 
   * @param tableEl 
   * @param ctx Markdown
   */
  renderMergedCells(tableEl, ctx) {
    var _a;
    try {
      if (tableEl.dataset.tableMergeProcessed === "true") {
        return;
      }
      const rawMarkdown = ((_a = ctx.getSectionInfo(tableEl)) == null ? void 0 : _a.text) || (0, import_obsidian10.htmlToMarkdown)(tableEl);
      if (!rawMarkdown)
        return;
      const lines = rawMarkdown.split("\n");
      const tableLines = lines.filter((line) => line.trim().startsWith("|") && line.trim().endsWith("|"));
      if (tableLines.length < 2)
        return;
      const contentLines = [tableLines[0]].concat(tableLines.slice(2));
      const rows = [];
      for (const line of contentLines) {
        const cells = line.split("|").filter((_, i, arr) => i > 0 && i < arr.length - 1).map((cell) => cell.trim());
        rows.push(cells);
      }
      const domRows = tableEl.querySelectorAll("tr");
      if (domRows.length !== rows.length)
        return;
      for (let rowIndex = 0; rowIndex < rows.length; rowIndex++) {
        const rowCells = rows[rowIndex];
        const domRow = domRows[rowIndex];
        const domCells = domRow.querySelectorAll("th, td");
        if (domCells.length !== rowCells.length)
          continue;
        for (let colIndex = 0; colIndex < rowCells.length; colIndex++) {
          const cellContent = rowCells[colIndex];
          const domCell = domCells[colIndex];
          if ((cellContent === "<" || cellContent === "\\<" || cellContent === " < " || cellContent === " \\< ") && colIndex > 0) {
            const leftCell = domCells[colIndex - 1];
            leftCell.colSpan = (leftCell.colSpan || 1) + 1;
            domCell.style.display = "none";
            if (this.settings.autoCenterMergedCells) {
              leftCell.style.textAlign = "center";
              leftCell.style.verticalAlign = "middle";
            }
            leftCell.classList.add("obs-merged-cell");
          } else if ((cellContent === "^" || cellContent === "\\^" || cellContent === " ^ " || cellContent === " \\^ ") && rowIndex > 0) {
            const aboveRow = domRows[rowIndex - 1];
            const aboveCells = aboveRow.querySelectorAll("th, td");
            if (colIndex < aboveCells.length) {
              const aboveCell = aboveCells[colIndex];
              aboveCell.rowSpan = (aboveCell.rowSpan || 1) + 1;
              domCell.style.display = "none";
              if (this.settings.autoCenterMergedCells) {
                aboveCell.style.textAlign = "center";
                aboveCell.style.verticalAlign = "middle";
              }
              aboveCell.classList.add("obs-merged-cell");
            }
          }
        }
      }
      tableEl.dataset.tableMergeProcessed = "true";
      console.log("\u5DF2\u6E32\u67D3\u8868\u683C\u5408\u5E76\u5355\u5143\u683C");
    } catch (error) {
      console.error("\u6E32\u67D3\u5408\u5E76\u5355\u5143\u683C\u65F6\u51FA\u9519:", error);
    }
  }
  /**
   * MarkdownID
   * DOM
   * @param table 
   * @returns Promise<string | null>
   */
  async readTableIdFromMarkdown(table) {
    try {
      const existingId = table.getAttribute("data-table-id");
      if (existingId) {
        console.log(`\u4ECE\u8868\u683C\u5143\u7D20\u5C5E\u6027\u4E2D\u83B7\u53D6ID: ${existingId}`);
        return existingId;
      }
      const activeView = this.app.workspace.getActiveViewOfType(import_obsidian10.MarkdownView);
      if (!activeView) {
        console.log("\u672A\u627E\u5230\u6D3B\u52A8\u89C6\u56FE");
        return null;
      }
      const activeFile = this.app.workspace.getActiveFile();
      if (!activeFile) {
        console.log("\u672A\u627E\u5230\u6D3B\u52A8\u6587\u4EF6");
        return null;
      }
      console.log(`\u5C1D\u8BD5\u4ECE\u6587\u4EF6\u5185\u5BB9\u4E2D\u67E5\u627E\u8868\u683CID: ${activeFile.path}`);
      const content = await this.app.vault.read(activeFile);
      const tableFeature = this.tableIdManager.extractTableFeature(table);
      console.log(`\u5F53\u524D\u8868\u683C\u7279\u5F81:`, tableFeature);
      const tableInfos = this.tableIdManager.extractTableIdsFromMarkdown(content);
      console.log(`\u4ECE\u6587\u4EF6\u4E2D\u63D0\u53D6\u7684\u8868\u683C\u4FE1\u606F:`, tableInfos);
      const allTables = Array.from(document.querySelectorAll("table"));
      const tableIndex = allTables.indexOf(table);
      console.log(`\u8868\u683C\u5728DOM\u4E2D\u7684\u4F4D\u7F6E: \u7B2C${tableIndex}\u4E2A\u8868\u683C\uFF08\u5171${allTables.length}\u4E2A\uFF09`);
      const similarityThreshold = this.settings.featureSimilarityThreshold || 0.7;
      if (this.settings.preferFeatureMatching) {
        if (tableFeature) {
          let bestMatchId = "";
          let bestMatchScore = 0;
          for (const { id, feature } of tableInfos) {
            if (!id)
              continue;
            const score = this.tableIdManager.calculateFeatureSimilarity(tableFeature, feature);
            console.log(`\u8868\u683CID ${id} \u7684\u7279\u5F81\u76F8\u4F3C\u5EA6: ${score.toFixed(2)}`);
            if (score > bestMatchScore) {
              bestMatchScore = score;
              bestMatchId = id;
            }
          }
          if (bestMatchId && bestMatchScore > similarityThreshold) {
            console.log(`\u901A\u8FC7\u7279\u5F81\u76F8\u4F3C\u5EA6\u5339\u914D\u627E\u5230\u8868\u683CID: ${bestMatchId}\uFF08\u76F8\u4F3C\u5EA6: ${bestMatchScore.toFixed(2)}\uFF09`);
            table.setAttribute("data-table-id", bestMatchId);
            return bestMatchId;
          }
        }
        if (tableIndex !== -1 && tableIndex < tableInfos.length) {
          const { id } = tableInfos[tableIndex];
          if (id) {
            console.log(`\u901A\u8FC7\u4F4D\u7F6E\u5339\u914D\u627E\u5230\u8868\u683CID: ${id}`);
            table.setAttribute("data-table-id", id);
            return id;
          }
        }
      } else {
        if (tableIndex !== -1 && tableIndex < tableInfos.length) {
          const { id } = tableInfos[tableIndex];
          if (id) {
            console.log(`\u901A\u8FC7\u4F4D\u7F6E\u7CBE\u786E\u5339\u914D\u627E\u5230\u8868\u683CID: ${id}`);
            table.setAttribute("data-table-id", id);
            return id;
          }
        }
        if (tableFeature) {
          let bestMatchId = "";
          let bestMatchScore = 0;
          for (const { id, feature } of tableInfos) {
            if (!id)
              continue;
            const score = this.tableIdManager.calculateFeatureSimilarity(tableFeature, feature);
            console.log(`\u8868\u683CID ${id} \u7684\u7279\u5F81\u76F8\u4F3C\u5EA6: ${score.toFixed(2)}`);
            if (score > bestMatchScore) {
              bestMatchScore = score;
              bestMatchId = id;
            }
          }
          if (bestMatchId && bestMatchScore > similarityThreshold) {
            console.log(`\u901A\u8FC7\u7279\u5F81\u76F8\u4F3C\u5EA6\u5339\u914D\u627E\u5230\u8868\u683CID: ${bestMatchId}\uFF08\u76F8\u4F3C\u5EA6: ${bestMatchScore.toFixed(2)}\uFF09`);
            table.setAttribute("data-table-id", bestMatchId);
            return bestMatchId;
          }
        }
      }
      if (tableFeature) {
        for (const { id, feature } of tableInfos) {
          if (!id)
            continue;
          if (feature.rows === tableFeature.rows && feature.cols === tableFeature.cols) {
            console.log(`\u901A\u8FC7\u8868\u683C\u7ED3\u6784\u5339\u914D\u627E\u5230\u8868\u683CID: ${id}`);
            table.setAttribute("data-table-id", id);
            return id;
          }
        }
      }
      if (this.settings.enableTableIds) {
        const newId = this.tableIdManager.generateTableId();
        console.log(`\u672A\u627E\u5230\u8868\u683CID\uFF0C\u751F\u6210\u65B0ID: ${newId}`);
        table.setAttribute("data-table-id", newId);
        return newId;
      }
      console.log("\u672A\u5728Markdown\u5185\u5BB9\u4E2D\u627E\u5230\u8868\u683CID\uFF0C\u4E14\u8868\u683CID\u529F\u80FD\u5DF2\u7981\u7528");
      return null;
    } catch (error) {
      console.error("\u4ECEMarkdown\u5185\u5BB9\u8BFB\u53D6\u8868\u683CID\u65F6\u51FA\u9519:", error);
      return null;
    }
  }
  /**
   * 
   */
  setupViewModeChangeListener() {
    if (this.viewModeChangeHandler) {
      this.app.workspace.off("active-leaf-change", this.viewModeChangeHandler);
      this.app.workspace.off("layout-change", this.viewModeChangeHandler);
    }
    this.viewModeChangeHandler = () => {
      this.checkAndRenderTables();
    };
    this.registerEvent(
      this.app.workspace.on("active-leaf-change", this.viewModeChangeHandler)
    );
    this.registerEvent(
      this.app.workspace.on("layout-change", this.viewModeChangeHandler)
    );
    console.log("\u5DF2\u8BBE\u7F6E\u89C6\u56FE\u6A21\u5F0F\u53D8\u5316\u76D1\u542C\u5668");
  }
  /**
   * 
   */
  checkAndRenderTables() {
    const activeView = this.app.workspace.getActiveViewOfType(import_obsidian10.MarkdownView);
    if (!activeView)
      return;
    const isPreviewMode = activeView.getMode() === "preview";
    if (isPreviewMode && !this.lastPreviewModeState) {
      setTimeout(() => {
        renderTablesWithStoredStyles(this);
      }, 300);
    }
    this.lastPreviewModeState = isPreviewMode;
  }
};
var main_default = ObsidianSpreadsheet;
